{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programming in Python This is an online textbook on Python and is a companion resource to the course Programming in Python offered as a part of the Online Degree Program, IIT-Madras. For more details about the course, check out our website . Note to students : This book is meant to be used as a reference. You may find content that has not been covered in the video lectures. Likewise, there may be some content that is present in the lectures which is not covered here. Additional content appearing in this book will not be considered for grading. In summary, please refer to chapters that you feel are relevant for the course. But you are under no obligation to read the entire book cover to cover. Interested students are always welcome to read the entire thing! Chapter-0: Warm-up Lesson-0 Chapter-1: Introduction to Python Lesson-1.1 Python shell | Replit Console Prompts | Output Emojis Literals and Variables Basic Data types | type() Comments Lesson-1.2 Operators Convention Expressions Type of Expressions Lesson-1.3 Arithmetic Expressions Boolean Expressions Lesson-1.4 Replit Editor Errors | Debugging Exceptions Wrong Code Snippets Lesson-1.5 Strings Quotes Length Operations Escape Characters Substrings Lesson-1.6 Strings Indexing Slicing Immutability Methods Chapter-2: Conditionals Lesson-2.1 Variables | Assignment operator | Dynamic Typing Referencing versus Defining | Keywords and Naming Rules Reusing Variables | Multiple Assignment | Deleting Variables Lesson-2.2 Input Type Conversion | Built-in Functions Lesson-2.3 Conditional Statements if if-else if-elif-else Nested Conditional Statements Defining Variables inside if Lesson-2.4 System libraries calendar time this Chapter-3: Loops Lesson-3.1 while loop break , continue Lesson-3.2 for loop range() Iterating through Strings Lesson-3.3 Nested loops while versus for print end sep Lesson-3.4 Formatted printing f-strings format() Format Specifiers Lesson-3.5 System libraries math random Lesson-3.6 Mathematics and Programming Limits Recurrence relations Rational approximation Chapter-4: Functions Lesson-4.1 Lesson-4.1 Introduction Examples Lesson-4.2 Arguments Positional Arguments Keyword Arguments Default Arguments Call by Value Lesson-4.3 Scope Local Global Namespaces locals globals Scope and Namespaces Lesson-4.3 Recursion Caution in Recursion Chapter-5: Lists and Tuples Lesson-4.4 Lists Introduction Iterating through Lists Growing a List Operations on Lists Useful Functions Lesson-5.2 Lists Mutability Call by Reference Lesson-5.3 Lists Simulating an IPL Innings Lesson-5.4 Lists List Methods Stack and Queue Strings and Lists split join Lesson-5.5 Lists Nested Lists Matrices Shallow and Deep Copy Lesson-5.6 Tuples Introduction More on Tuples Lists and Tuples Packing and Unpacking Chapter-6: Dictionaries and Sets Lesson-6.1 Dictionaries Introduction Examples Iterating over Dictionaries Growing a Dictionary Mutability Lesson-6.2 Text Processing Number of Sentences Number of Words Number of Unique Words Frequent Words Lesson-6.3 Dictionaries Pangrams and Dictionaries Dictionary Methods Lesson-6.4 Dictionaries in Action: LMS Assignment Model Submission Model Grader Lesson-6.5 Sets Introduction Iterating over Sets Growing Sets Set Operations Chapter-7: File Handling Lesson-7.1 File Handling Why Files File Handling Lesson-7.2 File Handling Creating a file in Replit Opening and Reading from a file Writing to a file Lesson-7.3 File Handling File object analogy Mode Lesson-7.4 File Handling File methods read readline readlines write writelines Lesson-7.5 File Handling CSV files Reading a CSV file Files to Collections Chapter-8: Object Oriented Programming Lesson-8.1 Lesson-8.1 Objects and Classes OOP in Python: an example Lesson-8.2 Classes and Objects self Class Attributes vs Object Attributes Lesson-8.3 Inheritance Concrete Example Parent-child relationship Method Overriding Lesson-8.4 Vector: Mathematical Preliminaries Vector: Specification Vector: Definition Collection of Vectors","title":"Home"},{"location":"#programming-in-python","text":"This is an online textbook on Python and is a companion resource to the course Programming in Python offered as a part of the Online Degree Program, IIT-Madras. For more details about the course, check out our website . Note to students : This book is meant to be used as a reference. You may find content that has not been covered in the video lectures. Likewise, there may be some content that is present in the lectures which is not covered here. Additional content appearing in this book will not be considered for grading. In summary, please refer to chapters that you feel are relevant for the course. But you are under no obligation to read the entire book cover to cover. Interested students are always welcome to read the entire thing!","title":"Programming in Python"},{"location":"#chapter-0-warm-up","text":"Lesson-0","title":"Chapter-0: Warm-up"},{"location":"#chapter-1-introduction-to-python","text":"Lesson-1.1 Python shell | Replit Console Prompts | Output Emojis Literals and Variables Basic Data types | type() Comments Lesson-1.2 Operators Convention Expressions Type of Expressions Lesson-1.3 Arithmetic Expressions Boolean Expressions Lesson-1.4 Replit Editor Errors | Debugging Exceptions Wrong Code Snippets Lesson-1.5 Strings Quotes Length Operations Escape Characters Substrings Lesson-1.6 Strings Indexing Slicing Immutability Methods","title":"Chapter-1: Introduction to Python"},{"location":"#chapter-2-conditionals","text":"Lesson-2.1 Variables | Assignment operator | Dynamic Typing Referencing versus Defining | Keywords and Naming Rules Reusing Variables | Multiple Assignment | Deleting Variables Lesson-2.2 Input Type Conversion | Built-in Functions Lesson-2.3 Conditional Statements if if-else if-elif-else Nested Conditional Statements Defining Variables inside if Lesson-2.4 System libraries calendar time this","title":"Chapter-2: Conditionals"},{"location":"#chapter-3-loops","text":"Lesson-3.1 while loop break , continue Lesson-3.2 for loop range() Iterating through Strings Lesson-3.3 Nested loops while versus for print end sep Lesson-3.4 Formatted printing f-strings format() Format Specifiers Lesson-3.5 System libraries math random Lesson-3.6 Mathematics and Programming Limits Recurrence relations Rational approximation","title":"Chapter-3: Loops"},{"location":"#chapter-4-functions","text":"Lesson-4.1 Lesson-4.1 Introduction Examples Lesson-4.2 Arguments Positional Arguments Keyword Arguments Default Arguments Call by Value Lesson-4.3 Scope Local Global Namespaces locals globals Scope and Namespaces Lesson-4.3 Recursion Caution in Recursion","title":"Chapter-4: Functions"},{"location":"#chapter-5-lists-and-tuples","text":"Lesson-4.4 Lists Introduction Iterating through Lists Growing a List Operations on Lists Useful Functions Lesson-5.2 Lists Mutability Call by Reference Lesson-5.3 Lists Simulating an IPL Innings Lesson-5.4 Lists List Methods Stack and Queue Strings and Lists split join Lesson-5.5 Lists Nested Lists Matrices Shallow and Deep Copy Lesson-5.6 Tuples Introduction More on Tuples Lists and Tuples Packing and Unpacking","title":"Chapter-5: Lists and Tuples"},{"location":"#chapter-6-dictionaries-and-sets","text":"Lesson-6.1 Dictionaries Introduction Examples Iterating over Dictionaries Growing a Dictionary Mutability Lesson-6.2 Text Processing Number of Sentences Number of Words Number of Unique Words Frequent Words Lesson-6.3 Dictionaries Pangrams and Dictionaries Dictionary Methods Lesson-6.4 Dictionaries in Action: LMS Assignment Model Submission Model Grader Lesson-6.5 Sets Introduction Iterating over Sets Growing Sets Set Operations","title":"Chapter-6: Dictionaries and Sets"},{"location":"#chapter-7-file-handling","text":"Lesson-7.1 File Handling Why Files File Handling Lesson-7.2 File Handling Creating a file in Replit Opening and Reading from a file Writing to a file Lesson-7.3 File Handling File object analogy Mode Lesson-7.4 File Handling File methods read readline readlines write writelines Lesson-7.5 File Handling CSV files Reading a CSV file Files to Collections","title":"Chapter-7: File Handling"},{"location":"#chapter-8-object-oriented-programming","text":"Lesson-8.1 Lesson-8.1 Objects and Classes OOP in Python: an example Lesson-8.2 Classes and Objects self Class Attributes vs Object Attributes Lesson-8.3 Inheritance Concrete Example Parent-child relationship Method Overriding Lesson-8.4 Vector: Mathematical Preliminaries Vector: Specification Vector: Definition Collection of Vectors","title":"Chapter-8: Object Oriented Programming"},{"location":"chapter-0/lesson-0/","text":"Lesson-0 What is Python? To answer this question, we need to first ask What is a programming language? A programming language is essentially a language in which you can tell your computer what to do. You will understand what that means as start programming. Every programming language has its own strengths and purposes. Python is a general-purpose programming language that can be used for a wide variety of purposes including but not limited to data science, automation, machine learning and software and web development. A typical python program to find the sum of the first 100 numbers looks like this: sum = 0 for number in range ( 1 , 101 ): sum += number print ( sum ) Do not worry too much about how the code works right now, we'll get into that over the course of the book. But now let's address a question you might have right now - why do we need to complicate things with programming languages to tell the computer what to do when we have simple applications like calculators that can do the same? Let's do a boring experiment: Let's add all the numbers from \\(1\\) through \\(100\\) on a calculator. How long did it take you? Now let's run the following program: How long did this code take you? Blazingly fast, isn't it? That's what coding enables you to do - Create ingenious solutions to problems. Programming also enables you to create applications. Applications like calculator that are designed for use by non-coders are created using code. Consider the following simple application. It takes two numbers as input and prints out their sum. The codes for these programs are in main.py files which you can view by pressing the Show files button. Come back and go through the code when you have learned some python. Why learn Python? The strongest reason is utility. Python powers a large number of applications and is used by companies like Google, Netflix, Dropbox, Quora. A closely related reason is popularity. If a language is popular in the developer community, then there must be something good about it. In a 2022 survey conducted by the company StackOverflow, Python was rated as the second most wanted language. Around 66% of the 65,000 developers who responded to the survey are currently developing with Python and have expressed interest in continuing to develop with it. Another strong reason to learn Python is that it lets us create beautiful things such as this animation 1 : Being able to create something like this is the end goal of this course. Musicians create music; musical instruments are their tools. Painters create paintings; the brush and the canvas are their tools. Coders create software; programming languages are their tools. Python is one of the most versatile and accessible languages out there. Python was designed to be human readable and easy while also being very powerful. This quality makes python the perfect first programming language. We will start from the basics and systematically cover the important aspects of the language. How easy is Python? Python has a vast collection of libraries that makes it easy to implement complex tasks. This is well described by this cheeky comic 2 that pops up when you enter import antigravity in IDLE. Lessons Organization This index is organized as a sequence of lessons. Lessons will be numbered as <chapter>.<lesson> . Each chapter will have about four lessons. These lessons are best read in the sequence in which they appear, starting from chapter-1 and going all the way up to chapter-12. If you are already familiar with Python, then have a look at the Table of Contents in the home page and jump into the lesson that seems least familiar. Each chapter introduces one important programming concept in Python. This will be that chapter's title. This doesn't mean that all the lessons in the chapter will focus on only that particular concept. For example, chapter-2 introduces the idea of conditionals, but built-in functions and Python's standard libraries also feature in the same week. The outline of the book is as follows: Chapter-1: Introduction to Python Chapter-2: Conditionals Chapter-3: Loops Chapter-4: Functions Chapter-5: Lists and Tuples Chapter-6: Sets and dictionaries Chapter-7: File handling Chapter-8: Object Oriented Programming How to read these lessons? Do not trust any piece of code blindly. Execute the code and observe the output. Think about the output. Verify if the explanation given in text matches your observations. Programming courses are among the few courses where the learner has an upper hand over instructors. No one can trick you. Code does not lie. All that is demanded of you is to make an effort to execute every snippet of code that you see in these lessons. Python Version We will be using Python-3.8 or higher throughout these lessons. If some of you are already familiar with Python and are used to Python-2, it is strongly recommended that you shift to Python-3. This is not an arbitrary choice as Python-2 has reached the end of its life. Setting up Replit Replit is an online environment where we can write code. It is an ideal place to learn programming and we will be using it extensively in this course. Head to http://www.replit.com/ and sign up using your Online Degree account. Replit provides an excellent tutorial to get you started. Installing Python on your System However, if you wish to use Python on your system, you can install it from here . You can refer to this guide to get a step-by-step process of installing Python. Having Python on your system will be useful in the subjects that you'll emcounter in the Diploma level. History Python first appeared on the programming landscape 30 years ago, in February 1991. It was created as a hobby project by a Dutch programmer, Guido van Rossum. He served as the benevolent dictator for life of Python\u2019s development until 2018, when he stepped down from the post. Guido Van Rossum at the Dropbox Headquarters in 2014 3 A popular question that gets asked often is how the language got its name. This is the answer from the official Python documentation: When he began implementing Python, Guido van Rossum was also reading the published scripts from \u201cMonty Python\u2019s Flying Circus\u201d , a BBC comedy series from the 1970s. Van Rossum thought he needed a name that was short, unique, and slightly mysterious, so he decided to call the language Python. Python is 30 years old. Programmers who boarded the Python-bus 30 years back lovingly talk of it as though it were a friend. This is not an exaggeration! This is a language that has been built by people like you and me, and is being used by thousands of people around the globe. Let us jump in with an open mind and see what it has to offer! Explore Check out the website of the Python Software Foundation and get to know more about the organization behind Python. Have a look at this interesting interview of Guido Van Rossum. This is a blog maintained by Dropbox. Another trivia: Guido worked at Dropbox for six and a half years. Try to watch documentaries and interviews on the web where Guido talks about how Python came into existence. It is always good to know about some non-technical aspects of the language, such as its history and something about the people who were behind its development. It gives a humanistic flavor to technology. We often forget that a lot of software is written by humans, for humans. In the next few weeks to come, StackOverflow might become the most visited website by most of you. Some of you might be familiar with it, but for the others, StackOverflow is a question-answer forum for programming related questions. It is extremely popular not just among beginners but even experienced developers. Do check it out, but use it wisely. Refrain from using it to get answers to assignment questions; you won't learn anything that way. You can also look into the official documentation on the python website . Thanks to Manim Community for the source code. The code that was used to render this animation can be found here . \u21a9 Credit to xkcd.com for the comic \u21a9 Image-Source: Wikipedia \u21a9","title":"Lesson-0"},{"location":"chapter-0/lesson-0/#lesson-0","text":"","title":"Lesson-0"},{"location":"chapter-0/lesson-0/#what-is-python","text":"To answer this question, we need to first ask What is a programming language? A programming language is essentially a language in which you can tell your computer what to do. You will understand what that means as start programming. Every programming language has its own strengths and purposes. Python is a general-purpose programming language that can be used for a wide variety of purposes including but not limited to data science, automation, machine learning and software and web development. A typical python program to find the sum of the first 100 numbers looks like this: sum = 0 for number in range ( 1 , 101 ): sum += number print ( sum ) Do not worry too much about how the code works right now, we'll get into that over the course of the book. But now let's address a question you might have right now - why do we need to complicate things with programming languages to tell the computer what to do when we have simple applications like calculators that can do the same? Let's do a boring experiment: Let's add all the numbers from \\(1\\) through \\(100\\) on a calculator. How long did it take you? Now let's run the following program: How long did this code take you? Blazingly fast, isn't it? That's what coding enables you to do - Create ingenious solutions to problems. Programming also enables you to create applications. Applications like calculator that are designed for use by non-coders are created using code. Consider the following simple application. It takes two numbers as input and prints out their sum. The codes for these programs are in main.py files which you can view by pressing the Show files button. Come back and go through the code when you have learned some python.","title":"What is Python?"},{"location":"chapter-0/lesson-0/#why-learn-python","text":"The strongest reason is utility. Python powers a large number of applications and is used by companies like Google, Netflix, Dropbox, Quora. A closely related reason is popularity. If a language is popular in the developer community, then there must be something good about it. In a 2022 survey conducted by the company StackOverflow, Python was rated as the second most wanted language. Around 66% of the 65,000 developers who responded to the survey are currently developing with Python and have expressed interest in continuing to develop with it. Another strong reason to learn Python is that it lets us create beautiful things such as this animation 1 : Being able to create something like this is the end goal of this course. Musicians create music; musical instruments are their tools. Painters create paintings; the brush and the canvas are their tools. Coders create software; programming languages are their tools. Python is one of the most versatile and accessible languages out there. Python was designed to be human readable and easy while also being very powerful. This quality makes python the perfect first programming language. We will start from the basics and systematically cover the important aspects of the language. How easy is Python? Python has a vast collection of libraries that makes it easy to implement complex tasks. This is well described by this cheeky comic 2 that pops up when you enter import antigravity in IDLE.","title":"Why learn Python?"},{"location":"chapter-0/lesson-0/#lessons","text":"","title":"Lessons"},{"location":"chapter-0/lesson-0/#organization","text":"This index is organized as a sequence of lessons. Lessons will be numbered as <chapter>.<lesson> . Each chapter will have about four lessons. These lessons are best read in the sequence in which they appear, starting from chapter-1 and going all the way up to chapter-12. If you are already familiar with Python, then have a look at the Table of Contents in the home page and jump into the lesson that seems least familiar. Each chapter introduces one important programming concept in Python. This will be that chapter's title. This doesn't mean that all the lessons in the chapter will focus on only that particular concept. For example, chapter-2 introduces the idea of conditionals, but built-in functions and Python's standard libraries also feature in the same week. The outline of the book is as follows: Chapter-1: Introduction to Python Chapter-2: Conditionals Chapter-3: Loops Chapter-4: Functions Chapter-5: Lists and Tuples Chapter-6: Sets and dictionaries Chapter-7: File handling Chapter-8: Object Oriented Programming","title":"Organization"},{"location":"chapter-0/lesson-0/#how-to-read-these-lessons","text":"Do not trust any piece of code blindly. Execute the code and observe the output. Think about the output. Verify if the explanation given in text matches your observations. Programming courses are among the few courses where the learner has an upper hand over instructors. No one can trick you. Code does not lie. All that is demanded of you is to make an effort to execute every snippet of code that you see in these lessons.","title":"How to read these lessons?"},{"location":"chapter-0/lesson-0/#python-version","text":"We will be using Python-3.8 or higher throughout these lessons. If some of you are already familiar with Python and are used to Python-2, it is strongly recommended that you shift to Python-3. This is not an arbitrary choice as Python-2 has reached the end of its life.","title":"Python Version"},{"location":"chapter-0/lesson-0/#setting-up-replit","text":"Replit is an online environment where we can write code. It is an ideal place to learn programming and we will be using it extensively in this course. Head to http://www.replit.com/ and sign up using your Online Degree account. Replit provides an excellent tutorial to get you started.","title":"Setting up Replit"},{"location":"chapter-0/lesson-0/#installing-python-on-your-system","text":"However, if you wish to use Python on your system, you can install it from here . You can refer to this guide to get a step-by-step process of installing Python. Having Python on your system will be useful in the subjects that you'll emcounter in the Diploma level.","title":"Installing Python on your System"},{"location":"chapter-0/lesson-0/#history","text":"Python first appeared on the programming landscape 30 years ago, in February 1991. It was created as a hobby project by a Dutch programmer, Guido van Rossum. He served as the benevolent dictator for life of Python\u2019s development until 2018, when he stepped down from the post. Guido Van Rossum at the Dropbox Headquarters in 2014 3 A popular question that gets asked often is how the language got its name. This is the answer from the official Python documentation: When he began implementing Python, Guido van Rossum was also reading the published scripts from \u201cMonty Python\u2019s Flying Circus\u201d , a BBC comedy series from the 1970s. Van Rossum thought he needed a name that was short, unique, and slightly mysterious, so he decided to call the language Python. Python is 30 years old. Programmers who boarded the Python-bus 30 years back lovingly talk of it as though it were a friend. This is not an exaggeration! This is a language that has been built by people like you and me, and is being used by thousands of people around the globe. Let us jump in with an open mind and see what it has to offer!","title":"History"},{"location":"chapter-0/lesson-0/#explore","text":"Check out the website of the Python Software Foundation and get to know more about the organization behind Python. Have a look at this interesting interview of Guido Van Rossum. This is a blog maintained by Dropbox. Another trivia: Guido worked at Dropbox for six and a half years. Try to watch documentaries and interviews on the web where Guido talks about how Python came into existence. It is always good to know about some non-technical aspects of the language, such as its history and something about the people who were behind its development. It gives a humanistic flavor to technology. We often forget that a lot of software is written by humans, for humans. In the next few weeks to come, StackOverflow might become the most visited website by most of you. Some of you might be familiar with it, but for the others, StackOverflow is a question-answer forum for programming related questions. It is extremely popular not just among beginners but even experienced developers. Do check it out, but use it wisely. Refrain from using it to get answers to assignment questions; you won't learn anything that way. You can also look into the official documentation on the python website . Thanks to Manim Community for the source code. The code that was used to render this animation can be found here . \u21a9 Credit to xkcd.com for the comic \u21a9 Image-Source: Wikipedia \u21a9","title":"Explore"},{"location":"chapter-1/lesson-1.1/","text":"Lesson-1.1 Python shell | Replit Console In this lesson, we will be working with the Python interpreter in Interactive Mode. It is also often called the Python shell. It is a tool that lets us execute individual lines of code and see the output right away. We will drop the phrase \"interactive mode\" and just refer to it as the interpreter. Have a look at the official Python documentation for more details about the Python Interpreter . If you have Python installed on your system, then the Python shell will look like this: In Replit, this corresponds to the console screen on the right of the repl. This will be our playground for quite sometime: Prompts The orange symbol that is displayed above is called a prompt. Its role is similar to that of the blinking cursor while editing documents. It is an invitation to type code. Code that is typed at the prompt is executed by the interpreter. In these lessons, we will use the following symbol to refer to the prompt: >>> . We are all set to write our first line of code: >>> print ( 'Hello World!' ) Hello World! Fire up a repl and type the code in the console. You will be getting the output on the next line. Output Let us take a closer look at the first line of code that we wrote. print () is called a built-in function in Python. A function is an object that accepts inputs and returns outputs. The term built-in refers to the fact that this function is something that is readily provided by Python for our use. >>> print ( 'Hello World!' ) Hello World ! >>> print ( \"Hello World!\" ) Hello World ! The sentence enclosed by the parentheses of the print () function is called a string . A string is a sequence of characters enclosed in quotes. Strings can either be in single quotes or double quotes. However, a single quote can't be matched against a double quote to enclose a string. We have used single quotes in line 1 and double quotes in line 3. Both lines give identical outputs. The ability to use both single quotes and double quotes comes in handy in situations like this: Problem Print a string that has an apostrophe in it: >>> print ( \"India's capital is New Delhi.\" ) Run the code given above and observe the output. print () can also be used to print numbers: >>> print ( 1 ) 1 >>> print ( 2.0 ) 2.0 Multiple items can be printed on the same line in the following way: >>> print ( 1 , 2 ) 1 2 >>> print ( 'online' , 'degree' , 'program' ) online degree program Notice the presence of a space between successive elements? print automatically seperates multiple values with a delimiter, which is space by default. If the print command is called without passing any input to it, then it prints a blank line: >>> print () >>> What happens if we just use type print without having the parentheses? >>> print <built-in function print> We don't get an error. Instead, the message is that print is a built-in function. But when you try the following code: >>> print 'Hello World!' File \"<stdin>\" , line 1 print 'Hello World!' ^ SyntaxError : Missing parentheses in call to 'print'. Did you mean print('Hello World!')? The interpreter hits back with a SyntaxError . Like human languages, programming languages have their own syntaxes that have to be followed to convey your commands to the computer. Programming language syntaxes, however, are far more strict and have to be followed exactly in order to run your code. Parantheses are used to execute and pass values (called arguments in programming jargon) to functions like print . Note the lack of parentheses in the above snippet which is also pointed out by the handy error message. We will learn the syntax for various concepts in python in the upcoming lessons. Emojis Before we jump into the serious stuff, let us try and print some emojis! >>> print ( ' \\N{smiling face with smiling eyes} ' ) \ud83d\ude0a >>> print ( ' \\N{grinning face} ' ) \ud83d\ude00 >>> print ( ' \\N{smiling face with halo} ' ) \ud83d\ude07 >>> print ( ' \\N{thinking face} ' ) \ud83e\udd14 Try this out in an interpreter of your choice! A full list of emojis can be found here . Literals and Variables Strings like 'Hello World!' and numbers like 1 , 2.0 are called literals in Python. Formally, a literal is something that describes a constant value. Variables are containers that are used to store values. Variables in Python are defined in the following way: >>> x = 1 >>> print ( x ) 1 >>> y = 'a string' >>> print ( y ) a string >>> foo_bar = 123.456 >>> print ( foo_bar ) 123.456 = is called the assignment operator. Whenever the assignment operator is present in a statement, it is used for one of the following purposes: define a new variable update an existing variable >>> x = 1 # define a new variable >>> x = x + 1 # update an existing variable >>> print ( x ) 2 The assignment operator is evaluated from right to left. That is, the expression to the right of the assignment operator is evaluated first. This result is then assigned to the variable on the left. Variables will be taken up in greater detail in the lessons of the second chapter. Basic Data Types | type() We will be looking at the following basic data types: Integer Float String Boolean Integer The int type represents integers. Python provides a command called type to determine the type of an object: >>> print ( 1 ) 1 >>> type ( 1 ) <class 'int'> Float The float type represents real numbers: >>> print ( 1.0 ) 1.0 >>> type ( 1.0 ) <class 'float'> The following is also a valid float literal: >>> print ( 1. ) 1.0 1. and 1.0 are one and the same literal. String The str type represents strings: >>> print ( 'one' ) one >>> type ( \"one\" ) <class 'str'> Boolean The bool type represents boolean values: >>> print ( True ) True >>> type ( False ) <class 'bool'> Please note that bool values are case sensitive. That is, true and false are not bool values. Comments A comment is a line of text that is not executed by the interpreter. Comments begin with the # symbol. The following are comments: >>> # This is a comment >>> # print(1) >>> As line-2 is a comment, 1 is not printed in the next line. Comments can also come at the end of a line of code: >>> print ( 1 ) # This line is printing the value 1 1 Adding comments is one of the ways to make code more readable. Its use will become clear in subsequent chapters.","title":"Lesson-1.1"},{"location":"chapter-1/lesson-1.1/#lesson-11","text":"","title":"Lesson-1.1"},{"location":"chapter-1/lesson-1.1/#python-shell-replit-console","text":"In this lesson, we will be working with the Python interpreter in Interactive Mode. It is also often called the Python shell. It is a tool that lets us execute individual lines of code and see the output right away. We will drop the phrase \"interactive mode\" and just refer to it as the interpreter. Have a look at the official Python documentation for more details about the Python Interpreter . If you have Python installed on your system, then the Python shell will look like this: In Replit, this corresponds to the console screen on the right of the repl. This will be our playground for quite sometime:","title":"Python shell | Replit Console"},{"location":"chapter-1/lesson-1.1/#prompts","text":"The orange symbol that is displayed above is called a prompt. Its role is similar to that of the blinking cursor while editing documents. It is an invitation to type code. Code that is typed at the prompt is executed by the interpreter. In these lessons, we will use the following symbol to refer to the prompt: >>> . We are all set to write our first line of code: >>> print ( 'Hello World!' ) Hello World! Fire up a repl and type the code in the console. You will be getting the output on the next line.","title":"Prompts"},{"location":"chapter-1/lesson-1.1/#output","text":"Let us take a closer look at the first line of code that we wrote. print () is called a built-in function in Python. A function is an object that accepts inputs and returns outputs. The term built-in refers to the fact that this function is something that is readily provided by Python for our use. >>> print ( 'Hello World!' ) Hello World ! >>> print ( \"Hello World!\" ) Hello World ! The sentence enclosed by the parentheses of the print () function is called a string . A string is a sequence of characters enclosed in quotes. Strings can either be in single quotes or double quotes. However, a single quote can't be matched against a double quote to enclose a string. We have used single quotes in line 1 and double quotes in line 3. Both lines give identical outputs. The ability to use both single quotes and double quotes comes in handy in situations like this: Problem Print a string that has an apostrophe in it: >>> print ( \"India's capital is New Delhi.\" ) Run the code given above and observe the output. print () can also be used to print numbers: >>> print ( 1 ) 1 >>> print ( 2.0 ) 2.0 Multiple items can be printed on the same line in the following way: >>> print ( 1 , 2 ) 1 2 >>> print ( 'online' , 'degree' , 'program' ) online degree program Notice the presence of a space between successive elements? print automatically seperates multiple values with a delimiter, which is space by default. If the print command is called without passing any input to it, then it prints a blank line: >>> print () >>> What happens if we just use type print without having the parentheses? >>> print <built-in function print> We don't get an error. Instead, the message is that print is a built-in function. But when you try the following code: >>> print 'Hello World!' File \"<stdin>\" , line 1 print 'Hello World!' ^ SyntaxError : Missing parentheses in call to 'print'. Did you mean print('Hello World!')? The interpreter hits back with a SyntaxError . Like human languages, programming languages have their own syntaxes that have to be followed to convey your commands to the computer. Programming language syntaxes, however, are far more strict and have to be followed exactly in order to run your code. Parantheses are used to execute and pass values (called arguments in programming jargon) to functions like print . Note the lack of parentheses in the above snippet which is also pointed out by the handy error message. We will learn the syntax for various concepts in python in the upcoming lessons.","title":"Output"},{"location":"chapter-1/lesson-1.1/#emojis","text":"Before we jump into the serious stuff, let us try and print some emojis! >>> print ( ' \\N{smiling face with smiling eyes} ' ) \ud83d\ude0a >>> print ( ' \\N{grinning face} ' ) \ud83d\ude00 >>> print ( ' \\N{smiling face with halo} ' ) \ud83d\ude07 >>> print ( ' \\N{thinking face} ' ) \ud83e\udd14 Try this out in an interpreter of your choice! A full list of emojis can be found here .","title":"Emojis"},{"location":"chapter-1/lesson-1.1/#literals-and-variables","text":"Strings like 'Hello World!' and numbers like 1 , 2.0 are called literals in Python. Formally, a literal is something that describes a constant value. Variables are containers that are used to store values. Variables in Python are defined in the following way: >>> x = 1 >>> print ( x ) 1 >>> y = 'a string' >>> print ( y ) a string >>> foo_bar = 123.456 >>> print ( foo_bar ) 123.456 = is called the assignment operator. Whenever the assignment operator is present in a statement, it is used for one of the following purposes: define a new variable update an existing variable >>> x = 1 # define a new variable >>> x = x + 1 # update an existing variable >>> print ( x ) 2 The assignment operator is evaluated from right to left. That is, the expression to the right of the assignment operator is evaluated first. This result is then assigned to the variable on the left. Variables will be taken up in greater detail in the lessons of the second chapter.","title":"Literals and Variables"},{"location":"chapter-1/lesson-1.1/#basic-data-types-type","text":"We will be looking at the following basic data types: Integer Float String Boolean","title":"Basic Data Types | type()"},{"location":"chapter-1/lesson-1.1/#integer","text":"The int type represents integers. Python provides a command called type to determine the type of an object: >>> print ( 1 ) 1 >>> type ( 1 ) <class 'int'>","title":"Integer"},{"location":"chapter-1/lesson-1.1/#float","text":"The float type represents real numbers: >>> print ( 1.0 ) 1.0 >>> type ( 1.0 ) <class 'float'> The following is also a valid float literal: >>> print ( 1. ) 1.0 1. and 1.0 are one and the same literal.","title":"Float"},{"location":"chapter-1/lesson-1.1/#string","text":"The str type represents strings: >>> print ( 'one' ) one >>> type ( \"one\" ) <class 'str'>","title":"String"},{"location":"chapter-1/lesson-1.1/#boolean","text":"The bool type represents boolean values: >>> print ( True ) True >>> type ( False ) <class 'bool'> Please note that bool values are case sensitive. That is, true and false are not bool values.","title":"Boolean"},{"location":"chapter-1/lesson-1.1/#comments","text":"A comment is a line of text that is not executed by the interpreter. Comments begin with the # symbol. The following are comments: >>> # This is a comment >>> # print(1) >>> As line-2 is a comment, 1 is not printed in the next line. Comments can also come at the end of a line of code: >>> print ( 1 ) # This line is printing the value 1 1 Adding comments is one of the ways to make code more readable. Its use will become clear in subsequent chapters.","title":"Comments"},{"location":"chapter-1/lesson-1.2/","text":"Lesson-1.2 Operators Arithmetic Operators The anatomy of an operation is given below: The following table gives the symbols for arithmetic operators and the operations that they correspond to: Operator Operation + Addition - Subtraction * Multiplication / Division // Floor division % Modulus ** Exponentiation All the operators in the above table are binary, i.e., they operate on two operands. Let us now take a look at each operator: >>> 10 + 5 15 >>> 10 - 5 5 >>> 10 * 5 50 >>> 10 / 5 2.0 >>> 10 // 5 2 >>> 10 % 5 0 >>> 10 ** 5 100000 The last three operators might be new. In more familiar terms, these are the mathematical operations that they correspond to: // is called the floor division operator. x // y gives the quotient when x is divided by y . For example, 8 // 3 is 2 . % is called the modulus operator. x % y gives the remainder when x is divided by y . For example, 10 % 3 is 1 . ** is called the exponentiation operator. x ** y returns \\(x^y\\) . / and // are two different operators. / gives the complete result of division, while // returns the quotient. For example, 5 / 2 results in 2.5 while 5 // 2 gives 2 . There are two more arithmetic operators of interest to us, unary plus and unary minus. These are the + and - signs. Unlike the operators that we have seen so far, these two are unary operators, i.e., they operate on one operand. For example: >>> - 2 - 2 >>> + 2 2 It is important to note that the symbols for plus and minus operators are the same as the ones for addition and subtraction. The context determines the nature of the operator: >>> - 1 # unary minus - 1 >>> 1 - 1 # subtraction operator Sometimes both of them could come together in the same expression: >>> 1 - - 1 2 >>> # The minus on the left is subtraction >>> # The minus on the right is unary minus In all the operations that we have seen so far, the operands have been literals. In general, the operands can also be variables: >>> x = 1 >>> y = x * 5 >>> print ( x , y ) 1 5 Relational Operators The following table gives the symbols for relational operators and the operations that they correspond to: Operator Operation > greater than < less than >= greater than or equal to <= less than or equal to == double equal to != not equal to All the operators in the above table are binary. Let us now take a look at each of them: >>> 10 > 5 True >>> 10 < 5 False >>> 10 >= 5 True >>> 10 <= 5 False >>> 10 == 5 False >>> 10 != 5 True Relational operators are also called comparison operators. The result of any comparison operation is a boolean value: True or False . The result of a comparison operation can be assigned to a variable: >>> x = 10 >>> y = 15 >>> z = y > x >>> print ( z ) True The == symbol corresponds to the equality operator and should not be confused with = , the assignment operator. Logical Operators The following table gives the logical operators and the operations that they correspond to: Operator Operation not negation and logical conjunction or logical disjunction and and or are binary operators; not is a unary operator. Let us now take a look at each of them: >>> True and False False >>> True or False True >>> x = False >>> y = not x >>> print ( y ) True The use of parenthesis after not is optional. For example: >>> x = True >>> not x False >>> x = False >>> not ( x ) True Convention Consider the following lines of code: >>> print ( 1 + 2 ) 3 >>> print ( 1 + 2 ) 3 Both lines 1 and 3 give the same output. Line-1 has a space before and after the + operator, while line-3 doesn't. Both ways are syntactically correct. In this course, we will be following the first convention: there is always a space separating the operator from the operands. This is also true for the = operator. >>> x = 2 # We will follow this >>> x = 2 # We will NOT follow this # But both conventions are valid Operator Chaining Python supports chaining relational operators. This enables you to evaluate chains of comparison without having to use logical operators. ```python >>> 10 < 11 <= 12 True # is the same as >>> 10 < 11 and 11 <= 12 True ``` Expressions An expression is some combination of literals, variables and operators. For example, the following are expressions: 1 + 4 / 4 ** 0 x / y + z * 2.0 3 > 4 and 1 < 10 not True and False Each expression evaluates to some value. This value has a type. In the above examples, the first two expressions result in a float , while the next two expressions result in a bool . In the next few sections, we shall study two types of expressions: Arithmetic: an expression whose type is either int or float Boolean: an expression whose type is bool Types of Expressions Arithmetic Expressions Let us now look at the type of simple arithmetic operations. In mathematics, the result of adding two integers is another integer. Is this true in the case of Python? First, let us execute the following statement in the interpreter and see what we get: >>> 1 + 2 3 The way to check the type of this expression is to use the type() function. For example, we have: >>> 1 + 2 3 >>> type ( 1 + 2 ) < class ' int '> So far the interpreter's behaviour conforms to our intuition. Let us now change this code slightly: >>> 1.0 + 2 3.0 >>> type ( 1.0 + 2 ) < class ' float '> We see that the result is 3.0 which is of type float . The conclusion is that float is more dominant than int as far as the addition operation is concerned. What about other operations? Let us check with the help of the following examples: >>> type ( 7.0 * 5 ) < class ' float '> >>> type ( 7.0 / 5 ) < class ' float '> >>> type ( 7.0 // 5 ) < class ' float '> >>> type ( 7.0 ** 5 ) < class ' float '> >>> type ( 7.0 % 5 ) < class ' float '> All the operations result in a float . From this we see that float is more dominant than int , irrespective of the operator involved. Boolean Expressions Expressions that involve a relational operator will result in a bool . For example: >>> 2 > 1 True >>> type ( 2 > 1 ) < class ' bool '> Expressions that involve logical operators will naturally result in a bool . For example: >>> True and False False >>> type ( True and False ) < class ' bool '> One way to analyze the outcome of boolean expressions that involve variables is to exhaustively list down the different combinations of values that variables can take and evaluate the expression for each such combination. For example, assume that X and Y are two boolean variables. Now, consider the following expression: >>> X or Y We can take the help of a concept called truth table to analyze the outcomes: X Y X or Y True True True True False True False True True False False False","title":"Lesson-1.2"},{"location":"chapter-1/lesson-1.2/#lesson-12","text":"","title":"Lesson-1.2"},{"location":"chapter-1/lesson-1.2/#operators","text":"","title":"Operators"},{"location":"chapter-1/lesson-1.2/#arithmetic-operators","text":"The anatomy of an operation is given below: The following table gives the symbols for arithmetic operators and the operations that they correspond to: Operator Operation + Addition - Subtraction * Multiplication / Division // Floor division % Modulus ** Exponentiation All the operators in the above table are binary, i.e., they operate on two operands. Let us now take a look at each operator: >>> 10 + 5 15 >>> 10 - 5 5 >>> 10 * 5 50 >>> 10 / 5 2.0 >>> 10 // 5 2 >>> 10 % 5 0 >>> 10 ** 5 100000 The last three operators might be new. In more familiar terms, these are the mathematical operations that they correspond to: // is called the floor division operator. x // y gives the quotient when x is divided by y . For example, 8 // 3 is 2 . % is called the modulus operator. x % y gives the remainder when x is divided by y . For example, 10 % 3 is 1 . ** is called the exponentiation operator. x ** y returns \\(x^y\\) . / and // are two different operators. / gives the complete result of division, while // returns the quotient. For example, 5 / 2 results in 2.5 while 5 // 2 gives 2 . There are two more arithmetic operators of interest to us, unary plus and unary minus. These are the + and - signs. Unlike the operators that we have seen so far, these two are unary operators, i.e., they operate on one operand. For example: >>> - 2 - 2 >>> + 2 2 It is important to note that the symbols for plus and minus operators are the same as the ones for addition and subtraction. The context determines the nature of the operator: >>> - 1 # unary minus - 1 >>> 1 - 1 # subtraction operator Sometimes both of them could come together in the same expression: >>> 1 - - 1 2 >>> # The minus on the left is subtraction >>> # The minus on the right is unary minus In all the operations that we have seen so far, the operands have been literals. In general, the operands can also be variables: >>> x = 1 >>> y = x * 5 >>> print ( x , y ) 1 5","title":"Arithmetic Operators"},{"location":"chapter-1/lesson-1.2/#relational-operators","text":"The following table gives the symbols for relational operators and the operations that they correspond to: Operator Operation > greater than < less than >= greater than or equal to <= less than or equal to == double equal to != not equal to All the operators in the above table are binary. Let us now take a look at each of them: >>> 10 > 5 True >>> 10 < 5 False >>> 10 >= 5 True >>> 10 <= 5 False >>> 10 == 5 False >>> 10 != 5 True Relational operators are also called comparison operators. The result of any comparison operation is a boolean value: True or False . The result of a comparison operation can be assigned to a variable: >>> x = 10 >>> y = 15 >>> z = y > x >>> print ( z ) True The == symbol corresponds to the equality operator and should not be confused with = , the assignment operator.","title":"Relational Operators"},{"location":"chapter-1/lesson-1.2/#logical-operators","text":"The following table gives the logical operators and the operations that they correspond to: Operator Operation not negation and logical conjunction or logical disjunction and and or are binary operators; not is a unary operator. Let us now take a look at each of them: >>> True and False False >>> True or False True >>> x = False >>> y = not x >>> print ( y ) True The use of parenthesis after not is optional. For example: >>> x = True >>> not x False >>> x = False >>> not ( x ) True Convention Consider the following lines of code: >>> print ( 1 + 2 ) 3 >>> print ( 1 + 2 ) 3 Both lines 1 and 3 give the same output. Line-1 has a space before and after the + operator, while line-3 doesn't. Both ways are syntactically correct. In this course, we will be following the first convention: there is always a space separating the operator from the operands. This is also true for the = operator. >>> x = 2 # We will follow this >>> x = 2 # We will NOT follow this # But both conventions are valid","title":"Logical Operators"},{"location":"chapter-1/lesson-1.2/#operator-chaining","text":"Python supports chaining relational operators. This enables you to evaluate chains of comparison without having to use logical operators. ```python >>> 10 < 11 <= 12 True # is the same as >>> 10 < 11 and 11 <= 12 True ```","title":"Operator Chaining"},{"location":"chapter-1/lesson-1.2/#expressions","text":"An expression is some combination of literals, variables and operators. For example, the following are expressions: 1 + 4 / 4 ** 0 x / y + z * 2.0 3 > 4 and 1 < 10 not True and False Each expression evaluates to some value. This value has a type. In the above examples, the first two expressions result in a float , while the next two expressions result in a bool . In the next few sections, we shall study two types of expressions: Arithmetic: an expression whose type is either int or float Boolean: an expression whose type is bool","title":"Expressions"},{"location":"chapter-1/lesson-1.2/#types-of-expressions","text":"","title":"Types of Expressions"},{"location":"chapter-1/lesson-1.2/#arithmetic-expressions","text":"Let us now look at the type of simple arithmetic operations. In mathematics, the result of adding two integers is another integer. Is this true in the case of Python? First, let us execute the following statement in the interpreter and see what we get: >>> 1 + 2 3 The way to check the type of this expression is to use the type() function. For example, we have: >>> 1 + 2 3 >>> type ( 1 + 2 ) < class ' int '> So far the interpreter's behaviour conforms to our intuition. Let us now change this code slightly: >>> 1.0 + 2 3.0 >>> type ( 1.0 + 2 ) < class ' float '> We see that the result is 3.0 which is of type float . The conclusion is that float is more dominant than int as far as the addition operation is concerned. What about other operations? Let us check with the help of the following examples: >>> type ( 7.0 * 5 ) < class ' float '> >>> type ( 7.0 / 5 ) < class ' float '> >>> type ( 7.0 // 5 ) < class ' float '> >>> type ( 7.0 ** 5 ) < class ' float '> >>> type ( 7.0 % 5 ) < class ' float '> All the operations result in a float . From this we see that float is more dominant than int , irrespective of the operator involved.","title":"Arithmetic Expressions"},{"location":"chapter-1/lesson-1.2/#boolean-expressions","text":"Expressions that involve a relational operator will result in a bool . For example: >>> 2 > 1 True >>> type ( 2 > 1 ) < class ' bool '> Expressions that involve logical operators will naturally result in a bool . For example: >>> True and False False >>> type ( True and False ) < class ' bool '> One way to analyze the outcome of boolean expressions that involve variables is to exhaustively list down the different combinations of values that variables can take and evaluate the expression for each such combination. For example, assume that X and Y are two boolean variables. Now, consider the following expression: >>> X or Y We can take the help of a concept called truth table to analyze the outcomes: X Y X or Y True True True True False True False True True False False False","title":"Boolean Expressions"},{"location":"chapter-1/lesson-1.3/","text":"Lesson-1.3 Arithmetic Expressions Precedence Let us start looking at arithmetic expressions that involve multiple operators: >>> 4 // 2 - 1 1 We can interpret this statement in two ways: (4 // 2) - 1 = 2 - 1 = 1 4 // (2 - 1) = 4 // 1 = 4 Clearly, we see that the interpreter is following the first way. When an expression has different operators, the interpreter has to make a decision about the way the expression is to be parenthesized, i.e., which operator takes precedence over the others. From the above example, we see that the floor division operator ( // ) has greater precedence than the subtraction operator ( - ). In general, the following table describes the precedence rules for operators. Those with higher precedence come at the top of the table. Operators in a given cell have the same precedence. For example, + and - have same precedence. Let us take another example: >>> 3 ** 2 * 4 - 4 32 Going by the precedence rules, we apply the parenthesis in the following sequence: (3 ** 2) * 4 - 4 ((3 ** 2) * 4) - 4 This is evaluated as: ((3 ** 2) * 4) - 4 = (9 * 4) - 4 = 36 - 4 = 32 Order Consider the following example: >>> 3 - 2 + 1 2 We can interpret this statement in two ways: (3 - 2) + 1 = 1 + 1 = 2 3 - (2 + 1) = 3 - 3 = 0 . The interpreter is following the first way. Does this mean that subtraction has greater precedence than addition? No, we just saw that they have the same precedence! We have to be careful here. Python evaluates expressions from left to right . There are two exceptions to this rule, the ** and = operator, both of which are evaluated from right to left. We shall return to this in a while. Now for another example. Consider the following expression: >>> 4 - 3 - 1 0 The two ways of doing this are: (4 - 3) - 1 = 1 - 1 = 0 4 - (3 - 1) = 4 - 2 = 2 The first way is the one followed by the interpreter. Going back to the evaluation order followed by Python, we see that this expression is evaluated from left to right. Let us take another example: >>> 8 % 4 % 2 0 Run the following code in the interpreter. Which of the following parenthesizations matches the expression given above? This is left as an exercise for you to try out. >>> ( 8 % 4 ) % 2 >>> 8 % ( 4 % 2 ) Finally, ** is a unique operator in this regard: >>> 2 ** 3 ** 0 2 The two ways of doing this are: (2 ** 3) ** 0 2 ** (3 ** 0) The interpreter is following the second way, i.e., the statement is being executed from right to left. This kind of execution happens only in the case of the exponentiation operator and the assignment operator. Boolean expressions The simplest example of an expression that results in a boolean value is given below: >>> 1 > 0 True >>> type ( 1 > 0 ) < class ' bool '> The following expression conveys the fact that 3.14 lies between 3 and 4: >>> 3 < 3.14 and 4 > 3.14 True This can also be written in the following manner: >>> 3 < 3.14 < 4 True Let us add some boolean literals into the mix: >>> 10 > 20 or True True As an exercise, try the following: >>> False or False or False or False or True Precedence and Order Similar to arithmetic operators, logical operators also have precedence. Boolean expressions are also going to evaluated from left to right: To see this rule in action, consider the following example: >>> not True and False False There are two different parenthesizations: not(True) and False = False and False = False not(True and False) = not(False) = True Clearly, the interpreter is following the first parenthesization. This is in accordance with the precedence rule for logical operators. The evaluation order is from left to right. But we will return to this in more detail in the section on short circuit evaluation. Another example, this time with and and or : >>> True or False and False True There are two different parenthesizations: (True or False) and False = True and False = False True or (False and False) = True or False = True According to the precedence rules, and has greater precedence than or . So, the second way is the one followed by Python. Beware of float ! Execute the following expression in the interpreter: >>> 10.00000000000000000000001 > 10 False This seems surprising! 10.00000000000000000000001 > 10 is a perfectly valid mathematical statement that evaluates to True . The reason this returns False in Python has to do with the way floating point numbers are represented. Python, and programming languages in general, do not support arbitrary precision for representing real numbers. When the number cannot be represented exactly, an approximate value is returned. As a result of this behaviour, we should be careful when using float values in expressions that involve comparisons. Another example: >>> 0.1 ** 100 == 0.0 False >>> 0.1 ** 1000 == 0.0 True The above expression presents a typical case of approximation when dealing with float . The number 0.1 ** 1000 is extremely small. So, the interpreter is going to represent that as 0. One more example follows: >>> 0.1 * 3 == 0.3 False Let us see what is happening here by starting with the expression to the left of the == operator: >>> 0.1 * 3 0.30000000000000004 Note : The following explanation can be skipped. The problem is with the way 0.1 is represented in binary - it has a non-terminating, recurring sequence of bits after the decimal point. As the computer uses a finite number of bits to represent data, this sequence will be truncated at some stage. This results in an approximate representation of 0.1 . For a more detailed explanation, refer to this resource. Short Circuit Evaluation Now, we come to an important feature in Python. Execute the following expression in the interpreter: >>> 1 / 0 Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ZeroDivisionError : division by zero Division by zero is not allowed, and the interpreter promptly hits back with an error message. This is not surprising. But what is surprising is the following statement: >>> True or ( 1 / 0 ) True No error message! How do we explain this behaviour? The expression is evaluated from left to right. The operator is or . Since the operand on the left is True , the whole expression will evaluate to True irrespective of the operand on the right. So, the interpreter skips evaluating the operand on the right. This behaviour is called short circuit evaluation. Consider a more complex example: >>> ( not (( 3 > 2 ) or ( 5 / 0 ))) and ( 10 / 0 ) False Let us break this down using the diagram given below. The arrows on the left give us an idea of the expression that has to be evaluated first. If we keep following the arrows, the last expression in this image on the bottom-left is the first to be evaluated. By following the arrows on the right, we can see that the two offending expressions - 5 / 0 and 10 / 0 - are never evaluated.","title":"Lesson-1.3"},{"location":"chapter-1/lesson-1.3/#lesson-13","text":"","title":"Lesson-1.3"},{"location":"chapter-1/lesson-1.3/#arithmetic-expressions","text":"","title":"Arithmetic Expressions"},{"location":"chapter-1/lesson-1.3/#precedence","text":"Let us start looking at arithmetic expressions that involve multiple operators: >>> 4 // 2 - 1 1 We can interpret this statement in two ways: (4 // 2) - 1 = 2 - 1 = 1 4 // (2 - 1) = 4 // 1 = 4 Clearly, we see that the interpreter is following the first way. When an expression has different operators, the interpreter has to make a decision about the way the expression is to be parenthesized, i.e., which operator takes precedence over the others. From the above example, we see that the floor division operator ( // ) has greater precedence than the subtraction operator ( - ). In general, the following table describes the precedence rules for operators. Those with higher precedence come at the top of the table. Operators in a given cell have the same precedence. For example, + and - have same precedence. Let us take another example: >>> 3 ** 2 * 4 - 4 32 Going by the precedence rules, we apply the parenthesis in the following sequence: (3 ** 2) * 4 - 4 ((3 ** 2) * 4) - 4 This is evaluated as: ((3 ** 2) * 4) - 4 = (9 * 4) - 4 = 36 - 4 = 32","title":"Precedence"},{"location":"chapter-1/lesson-1.3/#order","text":"Consider the following example: >>> 3 - 2 + 1 2 We can interpret this statement in two ways: (3 - 2) + 1 = 1 + 1 = 2 3 - (2 + 1) = 3 - 3 = 0 . The interpreter is following the first way. Does this mean that subtraction has greater precedence than addition? No, we just saw that they have the same precedence! We have to be careful here. Python evaluates expressions from left to right . There are two exceptions to this rule, the ** and = operator, both of which are evaluated from right to left. We shall return to this in a while. Now for another example. Consider the following expression: >>> 4 - 3 - 1 0 The two ways of doing this are: (4 - 3) - 1 = 1 - 1 = 0 4 - (3 - 1) = 4 - 2 = 2 The first way is the one followed by the interpreter. Going back to the evaluation order followed by Python, we see that this expression is evaluated from left to right. Let us take another example: >>> 8 % 4 % 2 0 Run the following code in the interpreter. Which of the following parenthesizations matches the expression given above? This is left as an exercise for you to try out. >>> ( 8 % 4 ) % 2 >>> 8 % ( 4 % 2 ) Finally, ** is a unique operator in this regard: >>> 2 ** 3 ** 0 2 The two ways of doing this are: (2 ** 3) ** 0 2 ** (3 ** 0) The interpreter is following the second way, i.e., the statement is being executed from right to left. This kind of execution happens only in the case of the exponentiation operator and the assignment operator.","title":"Order"},{"location":"chapter-1/lesson-1.3/#boolean-expressions","text":"The simplest example of an expression that results in a boolean value is given below: >>> 1 > 0 True >>> type ( 1 > 0 ) < class ' bool '> The following expression conveys the fact that 3.14 lies between 3 and 4: >>> 3 < 3.14 and 4 > 3.14 True This can also be written in the following manner: >>> 3 < 3.14 < 4 True Let us add some boolean literals into the mix: >>> 10 > 20 or True True As an exercise, try the following: >>> False or False or False or False or True","title":"Boolean expressions"},{"location":"chapter-1/lesson-1.3/#precedence-and-order","text":"Similar to arithmetic operators, logical operators also have precedence. Boolean expressions are also going to evaluated from left to right: To see this rule in action, consider the following example: >>> not True and False False There are two different parenthesizations: not(True) and False = False and False = False not(True and False) = not(False) = True Clearly, the interpreter is following the first parenthesization. This is in accordance with the precedence rule for logical operators. The evaluation order is from left to right. But we will return to this in more detail in the section on short circuit evaluation. Another example, this time with and and or : >>> True or False and False True There are two different parenthesizations: (True or False) and False = True and False = False True or (False and False) = True or False = True According to the precedence rules, and has greater precedence than or . So, the second way is the one followed by Python.","title":"Precedence and Order"},{"location":"chapter-1/lesson-1.3/#beware-of-float","text":"Execute the following expression in the interpreter: >>> 10.00000000000000000000001 > 10 False This seems surprising! 10.00000000000000000000001 > 10 is a perfectly valid mathematical statement that evaluates to True . The reason this returns False in Python has to do with the way floating point numbers are represented. Python, and programming languages in general, do not support arbitrary precision for representing real numbers. When the number cannot be represented exactly, an approximate value is returned. As a result of this behaviour, we should be careful when using float values in expressions that involve comparisons. Another example: >>> 0.1 ** 100 == 0.0 False >>> 0.1 ** 1000 == 0.0 True The above expression presents a typical case of approximation when dealing with float . The number 0.1 ** 1000 is extremely small. So, the interpreter is going to represent that as 0. One more example follows: >>> 0.1 * 3 == 0.3 False Let us see what is happening here by starting with the expression to the left of the == operator: >>> 0.1 * 3 0.30000000000000004 Note : The following explanation can be skipped. The problem is with the way 0.1 is represented in binary - it has a non-terminating, recurring sequence of bits after the decimal point. As the computer uses a finite number of bits to represent data, this sequence will be truncated at some stage. This results in an approximate representation of 0.1 . For a more detailed explanation, refer to this resource.","title":"Beware of float!"},{"location":"chapter-1/lesson-1.3/#short-circuit-evaluation","text":"Now, we come to an important feature in Python. Execute the following expression in the interpreter: >>> 1 / 0 Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ZeroDivisionError : division by zero Division by zero is not allowed, and the interpreter promptly hits back with an error message. This is not surprising. But what is surprising is the following statement: >>> True or ( 1 / 0 ) True No error message! How do we explain this behaviour? The expression is evaluated from left to right. The operator is or . Since the operand on the left is True , the whole expression will evaluate to True irrespective of the operand on the right. So, the interpreter skips evaluating the operand on the right. This behaviour is called short circuit evaluation. Consider a more complex example: >>> ( not (( 3 > 2 ) or ( 5 / 0 ))) and ( 10 / 0 ) False Let us break this down using the diagram given below. The arrows on the left give us an idea of the expression that has to be evaluated first. If we keep following the arrows, the last expression in this image on the bottom-left is the first to be evaluated. By following the arrows on the right, we can see that the two offending expressions - 5 / 0 and 10 / 0 - are never evaluated.","title":"Short Circuit Evaluation"},{"location":"chapter-1/lesson-1.4/","text":"Lesson-1.4 Replit Editor We have been using Replit's console to type code so far. We will now move to the editor in Replit. The advantage of using the editor is that code typed here gets automatically saved. Think about it like Google Docs for code. The window to the left of the console is the editor. After typing code, click on the green Run button on the top. The output of the code will appear in the console on the right. We will completely shift to the editor from now. This means dropping the prompt symbol before each line of code. Errors Introduction Enter the following line of code in the editor and run it: print ( '123) This is the output that we get in the console: File \"main.py\", line 1 print('123) ^ SyntaxError: EOL while scanning string literal Lines 1-4 represent an error message. It is the interpreter's way of warning us that there is something wrong with the code. Error messages usually come with some information about the errors which helps us understand what has gone wrong. In this case, we have a SyntaxError , i.e., something is wrong with the syntax. The remaining part of the message gives the details: EOL stands for E nd O f L ine scanning a string literal There was an issue with the end of line while scanning a string literal. The ^ sign points to the place where the error occurred. This acts as a visual aid while trying to trace the error. Going back to the code, the ending quote ' is missing. We can now fix it: print ( '123' ) Debugging Among software professionals, there is an alternative term used for errors in code: bugs. The process of fixing bugs is called debugging . The process usually works as follows: Run : run the code Detect : the interpreter intimates the coder of the error Understand : the coder has to understand the error message and go back to the code to see what went wrong Update : fix the error by modifying or updating one or more lines of the code Now, the coder closes the loop by running the code again. If the code throws another error, the whole process repeats. Debugging code forms an important part of programming. While working on huge codebases it might take several hours or even days to fix bugs. Exceptions We now move to a different set of errors. These are no longer syntax errors. Let us take an example: 1 / 0 The output is: Traceback (most recent call last): File \"main.py\", line 1, in <module> 1 / 0 ZeroDivisionError: division by zero The error message is quite clear here. We are trying to divide by zero and the interpreter is rightly objecting to it. This is called a ZeroDivisionError . But in terms of syntax, there is no error here. Such errors that are detected by the interpreter during the program's execution are called exceptions . We will keep returning to the idea of exceptions in every chapter. Let us look at another exception: 1 + 'one' The output is: Traceback (most recent call last): File \"main.py\", line 1, in <module> 1 + 'one' TypeError: unsupported operand type(s) for +: 'int' and 'str' The interpreter throws a TypeError . The message accompanying the error is more suggestive: an integer and a string cannot be added, i.e., for the + operator, int and str cannot be the type of the two operands. The next exception that we will frequently encounter is NameError . print ( 'There is no problem with this line' ) print ( x ** 2 ) The output is: There is no problem with this line Traceback (most recent call last): File \"main.py\", line 2, in <module> print(x ** 2) NameError: name 'x' is not defined Notice that the first line in the code gets printed correctly. The interpreter starts executing the code from top to bottom. The first line is error free. It is the second line which has a problem. NameError occurs when we try to reference a variable that has not been defined before. We will look at what referencing a variable means in the next chapter. Wrong Code Snippets Wherever we wish to demonstrate examples of incorrect code, we will do it in the following manner: ##### Alarm! Wrong code snippet! ##### # Incorrect code will go here # ##### Alarm! Wrong code snippet! #####","title":"Lesson-1.4"},{"location":"chapter-1/lesson-1.4/#lesson-14","text":"","title":"Lesson-1.4"},{"location":"chapter-1/lesson-1.4/#replit-editor","text":"We have been using Replit's console to type code so far. We will now move to the editor in Replit. The advantage of using the editor is that code typed here gets automatically saved. Think about it like Google Docs for code. The window to the left of the console is the editor. After typing code, click on the green Run button on the top. The output of the code will appear in the console on the right. We will completely shift to the editor from now. This means dropping the prompt symbol before each line of code.","title":"Replit Editor"},{"location":"chapter-1/lesson-1.4/#errors","text":"","title":"Errors"},{"location":"chapter-1/lesson-1.4/#introduction","text":"Enter the following line of code in the editor and run it: print ( '123) This is the output that we get in the console: File \"main.py\", line 1 print('123) ^ SyntaxError: EOL while scanning string literal Lines 1-4 represent an error message. It is the interpreter's way of warning us that there is something wrong with the code. Error messages usually come with some information about the errors which helps us understand what has gone wrong. In this case, we have a SyntaxError , i.e., something is wrong with the syntax. The remaining part of the message gives the details: EOL stands for E nd O f L ine scanning a string literal There was an issue with the end of line while scanning a string literal. The ^ sign points to the place where the error occurred. This acts as a visual aid while trying to trace the error. Going back to the code, the ending quote ' is missing. We can now fix it: print ( '123' )","title":"Introduction"},{"location":"chapter-1/lesson-1.4/#debugging","text":"Among software professionals, there is an alternative term used for errors in code: bugs. The process of fixing bugs is called debugging . The process usually works as follows: Run : run the code Detect : the interpreter intimates the coder of the error Understand : the coder has to understand the error message and go back to the code to see what went wrong Update : fix the error by modifying or updating one or more lines of the code Now, the coder closes the loop by running the code again. If the code throws another error, the whole process repeats. Debugging code forms an important part of programming. While working on huge codebases it might take several hours or even days to fix bugs.","title":"Debugging"},{"location":"chapter-1/lesson-1.4/#exceptions","text":"We now move to a different set of errors. These are no longer syntax errors. Let us take an example: 1 / 0 The output is: Traceback (most recent call last): File \"main.py\", line 1, in <module> 1 / 0 ZeroDivisionError: division by zero The error message is quite clear here. We are trying to divide by zero and the interpreter is rightly objecting to it. This is called a ZeroDivisionError . But in terms of syntax, there is no error here. Such errors that are detected by the interpreter during the program's execution are called exceptions . We will keep returning to the idea of exceptions in every chapter. Let us look at another exception: 1 + 'one' The output is: Traceback (most recent call last): File \"main.py\", line 1, in <module> 1 + 'one' TypeError: unsupported operand type(s) for +: 'int' and 'str' The interpreter throws a TypeError . The message accompanying the error is more suggestive: an integer and a string cannot be added, i.e., for the + operator, int and str cannot be the type of the two operands. The next exception that we will frequently encounter is NameError . print ( 'There is no problem with this line' ) print ( x ** 2 ) The output is: There is no problem with this line Traceback (most recent call last): File \"main.py\", line 2, in <module> print(x ** 2) NameError: name 'x' is not defined Notice that the first line in the code gets printed correctly. The interpreter starts executing the code from top to bottom. The first line is error free. It is the second line which has a problem. NameError occurs when we try to reference a variable that has not been defined before. We will look at what referencing a variable means in the next chapter.","title":"Exceptions"},{"location":"chapter-1/lesson-1.4/#wrong-code-snippets","text":"Wherever we wish to demonstrate examples of incorrect code, we will do it in the following manner: ##### Alarm! Wrong code snippet! ##### # Incorrect code will go here # ##### Alarm! Wrong code snippet! #####","title":"Wrong Code Snippets"},{"location":"chapter-1/lesson-1.5/","text":"Lesson-1.5 Strings Quotes: single, double and triple We briefly looked at strings in the first lesson. A string is any sequence of characters enclosed within single or double quotes. Some examples: \"this is a string\" 'this is also a string' '1 + 1 = 2' \"!, ?, _, @ are special characters\" \"if you need to use apostrophe ('), you can use double quotes\" It is a good practice to stick to either single or double quotes when using strings. Interestingly, Python also supports triple quotes ''' , especially for multi-line strings, i.e., strings that span multiple lines. Let us say that we want the following lines to be captured in a single string: first line second line third line The following code will throw a SyntaxError : x = 'first line second line third line ' print ( x ) This is where ''' comes in: x = '''first line second line third line''' print ( x ) After executing the above code, head to the console and type x . You will see the following output: 'first line\\nsecond line\\nthird line' The \\n character that you see above is called a newline character. Head to the section on escape characters in this lesson to know more about them. Length The length of a string is the number of characters in it. Python provides a built-in function called len to find the length of a string: x = 'good' print ( len ( x )) The code given above will give 4 as the output. If you are familiar with other programming languages, such as C, you might be aware of a character data type. Python doesn't have a separate data type for characters. A character in Python is represented by a string of length 1. In the following examples, x and y are strings of length 1. x = 'a' y = 'b' We can also define empty strings: x = '' print ( len ( x )) As expected, the length of the empty string is 0. Operations on strings Concatenation We can concatenate two strings using the + operator. Concatenation is just a fancy term for joining two strings together: string1 = 'first' string2 = ',' string3 = 'second' string4 = string1 + string2 + string3 print ( string4 ) The output is: first,second Replication We can make multiple copies of a string and string them all together using the * operator: s = 'good' five_s = s * 5 print ( five_s ) The is the output: goodgoodgoodgoodgood The * operator has made the string look too good! This is a fine demonstration of that ancient adage: \"multiplication is repeated addition\": s = 'good' s * 5 == s + s + s + s + s # This expression evaluates to True Comparison We can compare two strings. To begin with, we have the == operator: x = 'python' print ( x == 'python' , x == 'nohtyp' ) The output is: True False Two strings are equal if and only if both of them represent exactly the same sequence of characters. Now, consider the following lines of code: print ( 'good' > 'bad' ) print ( 'nine' < 'one' ) print ( 'a' < 'ab' < 'abc' < 'b' ) The output is: True True True It is clear from the above examples that the length of the string is not a metric used by Python to compare strings. Instead, Python uses the familiar alphabetical ordering to compare two strings. More precisely it employs what is known as lexicographic ordering : Lexicographic ordering The first characters from the two strings are compared. If they differ this determines the outcome of the comparison. If they are equal, then the second character of both the strings are compared. This process continues until either string is exhausted. This leads to another question. How does Python compare two characters? The answer is given in one of Python's official tutorials : Python\u2019s string type uses the Unicode standard for representing characters, which lets Python programs work with different possible characters. What is the Unicode standard? Unicode is a specification that aims to list every character used by human languages and give each character its own unique code. The Unicode standard describes how characters are represented by code points . Another unfamiliar term. What is a code point? A code point value is an integer. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Python provides a built-in function called ord that returns the code point of any given character. For example: print ( ord ( 'a' ), ord ( 'b' )) print ( ord ( 'a' ), ord ( 'A' )) The output is: 97 98 97 65 Now, we clearly see why 'a' < 'b' returns True . This is because the code point for 'a' and 'b' are 97 and 98 respectively. As 97 < 98, 'a' < 'b' . We can also infer that 'A' < 'a' should return True . Escape characters In Python, the backslash - \\ - is called the escape character. One of its uses is to represent certain white-space characters such as tabs and newlines. We will look at them one by one using the following examples: print ( 'This is the first sentence. \\n This is the second sentence.' ) The output is as follows: This is the first sentence. This is the second sentence. \\n is a newline character. Its effect is to introduce a new line. Note that even though there are two separate characters: \\ and n , \\n is still regarded as a single character. To verify this, execute the following code. You should get 1 as the output. x = ' \\n ' print ( len ( x )) Another useful character is the tab: \\t : print ( 'a \\t b' ) This will give the output: a b There is also a way to escape the quotes: \\' . This can come in handy when using the apostrophe symbol in strings with single quotes: print ( 'India \\' s capital is New Delhi' ) This gives the output: India's capital is New Delhi Now remove the backslash from the above string and try to print it. You will get an error. Why do you think that happens? Substrings A string is a substring of another string if the first string is contained in the second. For example, 'good' is a substring of 'very good' , whereas 'very good' is not a substring of 'verygood' . Python provides a keyword - in - which can be used to check if a given string is a substring of another string. For example: a = 'good' b = 'very good' present = a in b print ( present ) not_present = b in a print ( not_present ) This gives the output: True False in is a powerful keyword which has several other uses. It can also be used along with not in the following manner: a = 'abc' b = 'ab' print ( a not in b ) This gives the output: True","title":"Lesson-1.5"},{"location":"chapter-1/lesson-1.5/#lesson-15","text":"","title":"Lesson-1.5"},{"location":"chapter-1/lesson-1.5/#strings","text":"","title":"Strings"},{"location":"chapter-1/lesson-1.5/#quotes-single-double-and-triple","text":"We briefly looked at strings in the first lesson. A string is any sequence of characters enclosed within single or double quotes. Some examples: \"this is a string\" 'this is also a string' '1 + 1 = 2' \"!, ?, _, @ are special characters\" \"if you need to use apostrophe ('), you can use double quotes\" It is a good practice to stick to either single or double quotes when using strings. Interestingly, Python also supports triple quotes ''' , especially for multi-line strings, i.e., strings that span multiple lines. Let us say that we want the following lines to be captured in a single string: first line second line third line The following code will throw a SyntaxError : x = 'first line second line third line ' print ( x ) This is where ''' comes in: x = '''first line second line third line''' print ( x ) After executing the above code, head to the console and type x . You will see the following output: 'first line\\nsecond line\\nthird line' The \\n character that you see above is called a newline character. Head to the section on escape characters in this lesson to know more about them.","title":"Quotes: single, double and triple"},{"location":"chapter-1/lesson-1.5/#length","text":"The length of a string is the number of characters in it. Python provides a built-in function called len to find the length of a string: x = 'good' print ( len ( x )) The code given above will give 4 as the output. If you are familiar with other programming languages, such as C, you might be aware of a character data type. Python doesn't have a separate data type for characters. A character in Python is represented by a string of length 1. In the following examples, x and y are strings of length 1. x = 'a' y = 'b' We can also define empty strings: x = '' print ( len ( x )) As expected, the length of the empty string is 0.","title":"Length"},{"location":"chapter-1/lesson-1.5/#operations-on-strings","text":"","title":"Operations on strings"},{"location":"chapter-1/lesson-1.5/#concatenation","text":"We can concatenate two strings using the + operator. Concatenation is just a fancy term for joining two strings together: string1 = 'first' string2 = ',' string3 = 'second' string4 = string1 + string2 + string3 print ( string4 ) The output is: first,second","title":"Concatenation"},{"location":"chapter-1/lesson-1.5/#replication","text":"We can make multiple copies of a string and string them all together using the * operator: s = 'good' five_s = s * 5 print ( five_s ) The is the output: goodgoodgoodgoodgood The * operator has made the string look too good! This is a fine demonstration of that ancient adage: \"multiplication is repeated addition\": s = 'good' s * 5 == s + s + s + s + s # This expression evaluates to True","title":"Replication"},{"location":"chapter-1/lesson-1.5/#comparison","text":"We can compare two strings. To begin with, we have the == operator: x = 'python' print ( x == 'python' , x == 'nohtyp' ) The output is: True False Two strings are equal if and only if both of them represent exactly the same sequence of characters. Now, consider the following lines of code: print ( 'good' > 'bad' ) print ( 'nine' < 'one' ) print ( 'a' < 'ab' < 'abc' < 'b' ) The output is: True True True It is clear from the above examples that the length of the string is not a metric used by Python to compare strings. Instead, Python uses the familiar alphabetical ordering to compare two strings. More precisely it employs what is known as lexicographic ordering : Lexicographic ordering The first characters from the two strings are compared. If they differ this determines the outcome of the comparison. If they are equal, then the second character of both the strings are compared. This process continues until either string is exhausted. This leads to another question. How does Python compare two characters? The answer is given in one of Python's official tutorials : Python\u2019s string type uses the Unicode standard for representing characters, which lets Python programs work with different possible characters. What is the Unicode standard? Unicode is a specification that aims to list every character used by human languages and give each character its own unique code. The Unicode standard describes how characters are represented by code points . Another unfamiliar term. What is a code point? A code point value is an integer. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Python provides a built-in function called ord that returns the code point of any given character. For example: print ( ord ( 'a' ), ord ( 'b' )) print ( ord ( 'a' ), ord ( 'A' )) The output is: 97 98 97 65 Now, we clearly see why 'a' < 'b' returns True . This is because the code point for 'a' and 'b' are 97 and 98 respectively. As 97 < 98, 'a' < 'b' . We can also infer that 'A' < 'a' should return True .","title":"Comparison"},{"location":"chapter-1/lesson-1.5/#escape-characters","text":"In Python, the backslash - \\ - is called the escape character. One of its uses is to represent certain white-space characters such as tabs and newlines. We will look at them one by one using the following examples: print ( 'This is the first sentence. \\n This is the second sentence.' ) The output is as follows: This is the first sentence. This is the second sentence. \\n is a newline character. Its effect is to introduce a new line. Note that even though there are two separate characters: \\ and n , \\n is still regarded as a single character. To verify this, execute the following code. You should get 1 as the output. x = ' \\n ' print ( len ( x )) Another useful character is the tab: \\t : print ( 'a \\t b' ) This will give the output: a b There is also a way to escape the quotes: \\' . This can come in handy when using the apostrophe symbol in strings with single quotes: print ( 'India \\' s capital is New Delhi' ) This gives the output: India's capital is New Delhi Now remove the backslash from the above string and try to print it. You will get an error. Why do you think that happens?","title":"Escape characters"},{"location":"chapter-1/lesson-1.5/#substrings","text":"A string is a substring of another string if the first string is contained in the second. For example, 'good' is a substring of 'very good' , whereas 'very good' is not a substring of 'verygood' . Python provides a keyword - in - which can be used to check if a given string is a substring of another string. For example: a = 'good' b = 'very good' present = a in b print ( present ) not_present = b in a print ( not_present ) This gives the output: True False in is a powerful keyword which has several other uses. It can also be used along with not in the following manner: a = 'abc' b = 'ab' print ( a not in b ) This gives the output: True","title":"Substrings"},{"location":"chapter-1/lesson-1.6/","text":"Lesson-1.6 Strings We looked at string operations in the previous lesson. A quick recap of what we have seen so far: Length of a string using the len function Concatenation of two strings using the + operator Replication of strings using the * operator String comparison using relational operators such as >, <, == Use of in keyword In this lesson, we will explore the sequential nature of strings. This will also serve as an introduction to lists in Python. In addition, we will also look at string methods. Indexing A string is a sequence of characters. Sequences support indexing. What do we mean by that? Consider the following image: Given a word such as \"world\", we say that 'w' is the first letter in the word, 'o' is the second letter and so on. What we are referring to is the position of the letter in the word. The \"index\" is just a formal way of denoting the position of an element in the sequence. In computer science, starting the index from 0 is a widespread convention. This is called zero-based numbering . Once this is defined, we can go ahead and access characters that are at a given position in a string: word = 'world' print ( word [ 0 ]) print ( word [ 1 ]) print ( word [ 2 ]) print ( word [ 3 ]) print ( word [ 4 ]) This will give the output: w o r l d Given a variable, say word , that holds a string literal, word[i] gives the character at index i in the string. Informally, this would be the letter at position i + 1 in the string. Now, let us turn to the following code: word = 'world' print ( word [ 5 ]) This gives the following output: Traceback (most recent call last): File \"main.py\", line 2, in <module> print(word[5]) IndexError: string index out of range The interpreter throws an IndexError as we are trying to access an index that is out of range. The length of the string is 5 . Since we start the index from 0 , the last character will be at index 4 . Anything greater than that is going to throw an error. Now, let us turn to the other end of the spectrum: word = 'world' print ( word [ - 1 ]) Surprisingly, there is no error and the output is: d Python supports negative indexing. This can be best understood using the following image: Think about it as follows. You keep moving down a flight of stairs starting from the top most step. When you reach the last step, you think that you cannot go down any further. At that moment, some invisible hand magically transports you back to the top most step and you begin your descent all over again. A good image that captures this analogy is the Penrose stairs: Image credit: Wikipedia An index of -1 points to the last element in the sequence. From this, we keep moving backwards until we reach the first element in the sequence which is at index -5 . word = 'world' print ( word [ - 1 ]) # ... please add the remaining lines! print ( word [ - 5 ]) Unlike the Penrose stairs, we cannot keep repeating this forever. print(word[-6]) will throw an IndexError . Slicing Slicing is a way of extracting a substring from a string using the slice() function. Assume that you have a collection of email ids of students in IIT-M. Let us say all email ids are of this form: branch_year_number@iitm.ac.in Each branch is given a two-letter code. For example, CS stands for Computer Science and ME stands for Mechanical Engineering. The year is some two digit number that represents the year of joining. For example, it would be 11 if the year of joining is 2011 . Finally, number is a three digit roll number. Some sample email ids are as follows: CS_10_014@iitm.ac.in ME_11_123@iitm.ac.in BT_17_001@iitm.ac.in Given a string, we would like to extract the roll number of the student from it. How do we do this? Python provides a way to extract this information using the concept of slicing: email = 'CS_10_014@iitm.ac.in' roll = email [ 6 : 9 ] print ( roll ) The slicing operator - start:stop - will be our knife in slicing sequences! Let us see how it works. The substring that we want to extract is 014 . In terms of indices, this will be 6, 7, 8 in the string email . So, we start slicing at the index 6 and stop before the index 9 . In general, email[start : stop] will be the substring starting at index start and stopping before the index stop , i.e., the character at the index stop will be excluded from the substring. Few more examples using the same string: email = 'CS_10_014@iitm.ac.in' branch = email [ 0 : 2 ] year = email [ 3 : 5 ] roll = email [ 6 : 9 ] college = email [ 10 : 14 ] # Print each one of them and check the output Slicing is quite powerful. If we want the institute roll number, including the branch, we could do the following: email = 'CS_10_014@iitm.ac.in' in_roll = email [ : 9 ] print ( in_roll ) This outputs CS_10_014 . If no starting index is specified in the slice, then start will default to 0 . Likewise, if no stopping index is specified, stop will default to the end of the string or len(email) . Now, consider: email = 'CS_10_014@iitm.ac.in' domain = email [ - 10 : ] print ( domain ) This outputs iitm.ac.in . Think for a while about the output. It is just a combination of negative indexing and slicing. Use the following visual to get a better understanding of slicing: Using the above visual, we can now very easily process the following slices: word = 'world' print ( word [ - 4 : 3 ]) print ( word [ 1 : - 2 ]) Immutability Execute the following code and observe the output: word = 'some string' word [ 0 ] = 'S' The interpreter throws a TypeError with the following error message: 'str' object does not support item assignment . We say that something is \"mutable\" if it can be changed, modified. Therefore, an object is immutable if it cannot be changed or modified. Strings are immutable . One or more characters in the string literal present in word cannot be modified in-place . Note that this is different from the following: word = 'some string' word = 'Some string' Here, we are not modifying the variable word in-place. Instead, we are assigning it an entirely new string literal in line-2. Thus there are two different string literals - 'some string' and 'Some string' - and the former has NOT been transformed into the latter. The number on the arrow represents the line number in the code. word binds to the string on top after line-1. word binds to the string on the bottom after line-2. Note that there are two different strings here; one doesn't transform into the other. The concept of mutable and immutable objects will be explored in considerable detail in chapter-5. Methods Consider the following problem: Accept a sentence as input from the user and output the same sentence with the first letter in the sentence capitalized. For example, if the input is 'this is a chair.' , the output should be 'This is a chair.' . Solution sentence = input () cap_sentence = sentence . capitalize () print ( cap_sentence ) capitalize is called a method. Methods are essentially functions, but they are defined for specific objects. So, they have to be called by using the object for which they have been defined. In the case of capitalize , it is a method that is defined for the str data type. If we try to call it using an int object, we will get an error: ##### Alarm! Wrong code snippet! a = 1 a . capitalize () ##### Alarm! Wrong code snippet! Getting back to the previous code snippet, sentence.capitalize() returns a string, which is then assigned to a new variable called cap_sentence . There are plenty of other methods associated with strings. Let us look at one more method which features in the solution to this interesting problem: Check whether a given string is a valid name of a person. It is safe to assume that we are not thinking about Elon Musk's son, in which case, a name usually has only alphabets without any special characters and numbers. The method isalpha checks for just this requirement: # name is some pre-defined string valid = name . isalpha () print ( valid ) name.isalpha() returns a boolean value. If every character in the string is an alphabet and the string is non-empty, it returns True , and False otherwise. A comprehensive list of string methods can be found here .","title":"Lesson-1.6"},{"location":"chapter-1/lesson-1.6/#lesson-16","text":"","title":"Lesson-1.6"},{"location":"chapter-1/lesson-1.6/#strings","text":"We looked at string operations in the previous lesson. A quick recap of what we have seen so far: Length of a string using the len function Concatenation of two strings using the + operator Replication of strings using the * operator String comparison using relational operators such as >, <, == Use of in keyword In this lesson, we will explore the sequential nature of strings. This will also serve as an introduction to lists in Python. In addition, we will also look at string methods.","title":"Strings"},{"location":"chapter-1/lesson-1.6/#indexing","text":"A string is a sequence of characters. Sequences support indexing. What do we mean by that? Consider the following image: Given a word such as \"world\", we say that 'w' is the first letter in the word, 'o' is the second letter and so on. What we are referring to is the position of the letter in the word. The \"index\" is just a formal way of denoting the position of an element in the sequence. In computer science, starting the index from 0 is a widespread convention. This is called zero-based numbering . Once this is defined, we can go ahead and access characters that are at a given position in a string: word = 'world' print ( word [ 0 ]) print ( word [ 1 ]) print ( word [ 2 ]) print ( word [ 3 ]) print ( word [ 4 ]) This will give the output: w o r l d Given a variable, say word , that holds a string literal, word[i] gives the character at index i in the string. Informally, this would be the letter at position i + 1 in the string. Now, let us turn to the following code: word = 'world' print ( word [ 5 ]) This gives the following output: Traceback (most recent call last): File \"main.py\", line 2, in <module> print(word[5]) IndexError: string index out of range The interpreter throws an IndexError as we are trying to access an index that is out of range. The length of the string is 5 . Since we start the index from 0 , the last character will be at index 4 . Anything greater than that is going to throw an error. Now, let us turn to the other end of the spectrum: word = 'world' print ( word [ - 1 ]) Surprisingly, there is no error and the output is: d Python supports negative indexing. This can be best understood using the following image: Think about it as follows. You keep moving down a flight of stairs starting from the top most step. When you reach the last step, you think that you cannot go down any further. At that moment, some invisible hand magically transports you back to the top most step and you begin your descent all over again. A good image that captures this analogy is the Penrose stairs: Image credit: Wikipedia An index of -1 points to the last element in the sequence. From this, we keep moving backwards until we reach the first element in the sequence which is at index -5 . word = 'world' print ( word [ - 1 ]) # ... please add the remaining lines! print ( word [ - 5 ]) Unlike the Penrose stairs, we cannot keep repeating this forever. print(word[-6]) will throw an IndexError .","title":"Indexing"},{"location":"chapter-1/lesson-1.6/#slicing","text":"Slicing is a way of extracting a substring from a string using the slice() function. Assume that you have a collection of email ids of students in IIT-M. Let us say all email ids are of this form: branch_year_number@iitm.ac.in Each branch is given a two-letter code. For example, CS stands for Computer Science and ME stands for Mechanical Engineering. The year is some two digit number that represents the year of joining. For example, it would be 11 if the year of joining is 2011 . Finally, number is a three digit roll number. Some sample email ids are as follows: CS_10_014@iitm.ac.in ME_11_123@iitm.ac.in BT_17_001@iitm.ac.in Given a string, we would like to extract the roll number of the student from it. How do we do this? Python provides a way to extract this information using the concept of slicing: email = 'CS_10_014@iitm.ac.in' roll = email [ 6 : 9 ] print ( roll ) The slicing operator - start:stop - will be our knife in slicing sequences! Let us see how it works. The substring that we want to extract is 014 . In terms of indices, this will be 6, 7, 8 in the string email . So, we start slicing at the index 6 and stop before the index 9 . In general, email[start : stop] will be the substring starting at index start and stopping before the index stop , i.e., the character at the index stop will be excluded from the substring. Few more examples using the same string: email = 'CS_10_014@iitm.ac.in' branch = email [ 0 : 2 ] year = email [ 3 : 5 ] roll = email [ 6 : 9 ] college = email [ 10 : 14 ] # Print each one of them and check the output Slicing is quite powerful. If we want the institute roll number, including the branch, we could do the following: email = 'CS_10_014@iitm.ac.in' in_roll = email [ : 9 ] print ( in_roll ) This outputs CS_10_014 . If no starting index is specified in the slice, then start will default to 0 . Likewise, if no stopping index is specified, stop will default to the end of the string or len(email) . Now, consider: email = 'CS_10_014@iitm.ac.in' domain = email [ - 10 : ] print ( domain ) This outputs iitm.ac.in . Think for a while about the output. It is just a combination of negative indexing and slicing. Use the following visual to get a better understanding of slicing: Using the above visual, we can now very easily process the following slices: word = 'world' print ( word [ - 4 : 3 ]) print ( word [ 1 : - 2 ])","title":"Slicing"},{"location":"chapter-1/lesson-1.6/#immutability","text":"Execute the following code and observe the output: word = 'some string' word [ 0 ] = 'S' The interpreter throws a TypeError with the following error message: 'str' object does not support item assignment . We say that something is \"mutable\" if it can be changed, modified. Therefore, an object is immutable if it cannot be changed or modified. Strings are immutable . One or more characters in the string literal present in word cannot be modified in-place . Note that this is different from the following: word = 'some string' word = 'Some string' Here, we are not modifying the variable word in-place. Instead, we are assigning it an entirely new string literal in line-2. Thus there are two different string literals - 'some string' and 'Some string' - and the former has NOT been transformed into the latter. The number on the arrow represents the line number in the code. word binds to the string on top after line-1. word binds to the string on the bottom after line-2. Note that there are two different strings here; one doesn't transform into the other. The concept of mutable and immutable objects will be explored in considerable detail in chapter-5.","title":"Immutability"},{"location":"chapter-1/lesson-1.6/#methods","text":"Consider the following problem: Accept a sentence as input from the user and output the same sentence with the first letter in the sentence capitalized. For example, if the input is 'this is a chair.' , the output should be 'This is a chair.' . Solution sentence = input () cap_sentence = sentence . capitalize () print ( cap_sentence ) capitalize is called a method. Methods are essentially functions, but they are defined for specific objects. So, they have to be called by using the object for which they have been defined. In the case of capitalize , it is a method that is defined for the str data type. If we try to call it using an int object, we will get an error: ##### Alarm! Wrong code snippet! a = 1 a . capitalize () ##### Alarm! Wrong code snippet! Getting back to the previous code snippet, sentence.capitalize() returns a string, which is then assigned to a new variable called cap_sentence . There are plenty of other methods associated with strings. Let us look at one more method which features in the solution to this interesting problem: Check whether a given string is a valid name of a person. It is safe to assume that we are not thinking about Elon Musk's son, in which case, a name usually has only alphabets without any special characters and numbers. The method isalpha checks for just this requirement: # name is some pre-defined string valid = name . isalpha () print ( valid ) name.isalpha() returns a boolean value. If every character in the string is an alphabet and the string is non-empty, it returns True , and False otherwise. A comprehensive list of string methods can be found here .","title":"Methods"},{"location":"chapter-2/lesson-2.1/","text":"Lesson-2.1 Variables Introduction Variables are containers that are used to store values. Variables in Python are defined by using the assignment operator = . For example: x = 1 y = 100. z = \"good\" Variables can also be updated using the assignment operator: x = 1 print ( 'The initial value of x is' , x ) x = 2 print ( 'The value after updating x is' , x ) The output is: The initial value of x is 1 The value after updating x is 2 Assignment Operator The syntax of the assignment statement is as follows: variable_name = expression The assignment operator works from right to left. That is, the expression on the right is evaluated first. The value of this expression is assigned to the variable on the left. For example: x = 1 + 2 * 3 / 2 print ( x ) The output is: 4.0 Having a literal to the left of the assignment operator will result in an error: ##### Alarm! Wrong code snippet! ##### 3 = x ##### Alarm! Wrong code snippet! ##### This will throw the following error: SyntaxError: cannot assign to literal The assignment statement maps or binds the variable name on the left to an object on the right. A closer look at the anatomy of an assignment statement: The numbers on the arrow correspond to the line numbers in the code. The variables on the left side of the arrow bind to the objects on the right side after the corresponding line is executed. For example, the variable x binds to the object 8 - in this case an int literal - after line 1 is executed. Note the period at the end of line 2 which makes 10 a float . After the execution of line 2, 18.0 gets stored in x . The interesting part is line 3. Note that y = x makes both x and y bind to the same object. When x is updated in line-4, it binds to a new object. However, the value of y is not disturbed by this operation. It continues to be bound to the object 18.0 even after line-4 is executed. As a final point, the assignment operator should not be confused with the equality operator: x = 2 # this is the assignment operator x == 2 # this is the equality operator The assignment operator is used for creating or updating variables whereas the equality operator is used when two expressions need to be compared. They cannot be used interchangeably! Dynamic Typing Python supports what is called dynamic typing. In a dynamically typed language, a variable is simply a value bound to a name; the value has a type \u2014 like int or str \u2014 but the variable itself doesn't [ refer ]. For example: 1 2 3 4 5 6 a = 1 print ( type ( a )) a = 1 / 2 print ( type ( a )) a = \"IIT Madras\" print ( type ( a )) The output is: <class 'int'> <class 'float'> <class 'str'> In the above example, a was initially bound to a value of type int . After its update in line 3, it was bound to a value of type float and after line 5, it becomes a str . The image in the previous section will give a clearer picture of why this is the case. Referencing versus Defining When a variable that has already been defined is used in an expression, we say that the variable is being referenced. For example: x = 2 print ( x * x , 'is the square of' , x ) In line-2, we are referencing the variable x which was assigned a value in line-1. If a variable is referenced before it has been assigned a value, the interpreter throws an exception called NameError : print ( someVar ) This is the output: NameError: name 'someVar' is not defined Keywords and Naming Rules Keywords are certain words in the Python language that have a special meaning. Some of them are listed below: not , and , or , if , for , while , in , is , def , class We have already seen some of them - not, and, or . We will come across all these keywords in upcoming chapters. Keywords cannot be used as names for variables. For example, the following line of code will throw a SyntaxError when executed: ##### Alarm! Wrong code snippet! ##### and = 2 ##### Alarm! Wrong code snippet! ##### Along with this restriction, there are certain other rules which have to be followed while choosing the names of variables in Python [ refer ]: A variable name can only contain alpha-numeric (alphabets and numbers) characters and underscores: a - z A - Z 0 - 9 _ A variable name must start with a letter or the underscore character. A few observations that directly follow from the above rules: A variable name cannot start with a number. Variable names are case-sensitive ( age , Age and AGE are three different variables). Note that these are not merely conventions. Violating any one of these rules will result in a SyntaxError . As an example, the following code will throw a SyntaxError when executed: ##### Alarm! Wrong code snippet! ##### 3 a = 1 ##### Alarm! Wrong code snippet! ##### SyntaxError: invalid decimal literal Reusing Variables Variables can be used in computing the value of other variables. This is something that will routinely come up in programming and data science. Consider the following sequence of mathematical equations. We wish to evaluate the value of z at x = 10 : $$ y=x^2 $$ $$ z=(x+1)(y+1) $$ This can be computed as follows: x = 10 y = x ** 2 z = ( x + 1 ) * ( y + 1 ) Multiple Assignment Consider the following statement that defines two variables x and y . x = 1 y = 2 Python allows a compact way of writing this assignment on the same line. The following code assigns 1 to the variable x and 2 to the variable y : x , y = 1 , 2 Note that the order matters. The following code assigns 2 to the variable x and 1 to the variable y : x , y = 2 , 1 To understand how this works, we need to get into the concept of packing and unpacking tuples, which we will visit in chapter 5. Treat this as a useful feature for the time being. Another way of doing multiple assignments is to initialize multiple variables with the same value: x = y = z = 10 print ( x , y , z ) The output is: 10 10 10 Though x , y and z start off by being equal, the equality is broken the moment even one of the three variables is updated: x = x * 1 y = y * 2 z = z * 3 print ( x , y , z ) The output is: 10 20 30 Assignment Shortcuts Execute the code given below and observe the output. What do you think is happening? x = 1 x += 1 print ( x ) += is something that we haven't seen before. x += a Increment the value of x by a . In other words, add a to x and store the result in x . It is equivalent to the statement x = x + a . This is not just limited to the addition operator. The following table gives a summary of the shortcuts for some of the arithmetic operators: Shortcut Meaning x += a x = x + a x -= a x = x - a x *= a x = x * a x /= a x = x / a x %= a x = x % a x **= a x = x ** a Note that the arithmetic operator must always come before the assignment operator in a shortcut. Swapping them will not work: x = 1 x =+ 1 print ( x ) This will give 1 as the output. This is because + is treated as the unary operator here. Statements like x =* 1 or x =/ 2 will result in errors! Deleting Variables Variables can be deleted by using the del keyword: 1 2 3 4 5 x = 100 print ( 'x is a variable whose value is' , x ) print ( 'we are now going to delete x' ) del x print ( x ) When this code is executed, line 5 throws a NameError . This is because x was deleted in line 4 and we are trying to access a variable that is no longer defined at line 5.","title":"Lesson-2.1"},{"location":"chapter-2/lesson-2.1/#lesson-21","text":"","title":"Lesson-2.1"},{"location":"chapter-2/lesson-2.1/#variables","text":"","title":"Variables"},{"location":"chapter-2/lesson-2.1/#introduction","text":"Variables are containers that are used to store values. Variables in Python are defined by using the assignment operator = . For example: x = 1 y = 100. z = \"good\" Variables can also be updated using the assignment operator: x = 1 print ( 'The initial value of x is' , x ) x = 2 print ( 'The value after updating x is' , x ) The output is: The initial value of x is 1 The value after updating x is 2","title":"Introduction"},{"location":"chapter-2/lesson-2.1/#assignment-operator","text":"The syntax of the assignment statement is as follows: variable_name = expression The assignment operator works from right to left. That is, the expression on the right is evaluated first. The value of this expression is assigned to the variable on the left. For example: x = 1 + 2 * 3 / 2 print ( x ) The output is: 4.0 Having a literal to the left of the assignment operator will result in an error: ##### Alarm! Wrong code snippet! ##### 3 = x ##### Alarm! Wrong code snippet! ##### This will throw the following error: SyntaxError: cannot assign to literal The assignment statement maps or binds the variable name on the left to an object on the right. A closer look at the anatomy of an assignment statement: The numbers on the arrow correspond to the line numbers in the code. The variables on the left side of the arrow bind to the objects on the right side after the corresponding line is executed. For example, the variable x binds to the object 8 - in this case an int literal - after line 1 is executed. Note the period at the end of line 2 which makes 10 a float . After the execution of line 2, 18.0 gets stored in x . The interesting part is line 3. Note that y = x makes both x and y bind to the same object. When x is updated in line-4, it binds to a new object. However, the value of y is not disturbed by this operation. It continues to be bound to the object 18.0 even after line-4 is executed. As a final point, the assignment operator should not be confused with the equality operator: x = 2 # this is the assignment operator x == 2 # this is the equality operator The assignment operator is used for creating or updating variables whereas the equality operator is used when two expressions need to be compared. They cannot be used interchangeably! Dynamic Typing Python supports what is called dynamic typing. In a dynamically typed language, a variable is simply a value bound to a name; the value has a type \u2014 like int or str \u2014 but the variable itself doesn't [ refer ]. For example: 1 2 3 4 5 6 a = 1 print ( type ( a )) a = 1 / 2 print ( type ( a )) a = \"IIT Madras\" print ( type ( a )) The output is: <class 'int'> <class 'float'> <class 'str'> In the above example, a was initially bound to a value of type int . After its update in line 3, it was bound to a value of type float and after line 5, it becomes a str . The image in the previous section will give a clearer picture of why this is the case.","title":"Assignment Operator"},{"location":"chapter-2/lesson-2.1/#referencing-versus-defining","text":"When a variable that has already been defined is used in an expression, we say that the variable is being referenced. For example: x = 2 print ( x * x , 'is the square of' , x ) In line-2, we are referencing the variable x which was assigned a value in line-1. If a variable is referenced before it has been assigned a value, the interpreter throws an exception called NameError : print ( someVar ) This is the output: NameError: name 'someVar' is not defined","title":"Referencing versus Defining"},{"location":"chapter-2/lesson-2.1/#keywords-and-naming-rules","text":"Keywords are certain words in the Python language that have a special meaning. Some of them are listed below: not , and , or , if , for , while , in , is , def , class We have already seen some of them - not, and, or . We will come across all these keywords in upcoming chapters. Keywords cannot be used as names for variables. For example, the following line of code will throw a SyntaxError when executed: ##### Alarm! Wrong code snippet! ##### and = 2 ##### Alarm! Wrong code snippet! ##### Along with this restriction, there are certain other rules which have to be followed while choosing the names of variables in Python [ refer ]: A variable name can only contain alpha-numeric (alphabets and numbers) characters and underscores: a - z A - Z 0 - 9 _ A variable name must start with a letter or the underscore character. A few observations that directly follow from the above rules: A variable name cannot start with a number. Variable names are case-sensitive ( age , Age and AGE are three different variables). Note that these are not merely conventions. Violating any one of these rules will result in a SyntaxError . As an example, the following code will throw a SyntaxError when executed: ##### Alarm! Wrong code snippet! ##### 3 a = 1 ##### Alarm! Wrong code snippet! ##### SyntaxError: invalid decimal literal","title":"Keywords and Naming Rules"},{"location":"chapter-2/lesson-2.1/#reusing-variables","text":"Variables can be used in computing the value of other variables. This is something that will routinely come up in programming and data science. Consider the following sequence of mathematical equations. We wish to evaluate the value of z at x = 10 : $$ y=x^2 $$ $$ z=(x+1)(y+1) $$ This can be computed as follows: x = 10 y = x ** 2 z = ( x + 1 ) * ( y + 1 )","title":"Reusing Variables"},{"location":"chapter-2/lesson-2.1/#multiple-assignment","text":"Consider the following statement that defines two variables x and y . x = 1 y = 2 Python allows a compact way of writing this assignment on the same line. The following code assigns 1 to the variable x and 2 to the variable y : x , y = 1 , 2 Note that the order matters. The following code assigns 2 to the variable x and 1 to the variable y : x , y = 2 , 1 To understand how this works, we need to get into the concept of packing and unpacking tuples, which we will visit in chapter 5. Treat this as a useful feature for the time being. Another way of doing multiple assignments is to initialize multiple variables with the same value: x = y = z = 10 print ( x , y , z ) The output is: 10 10 10 Though x , y and z start off by being equal, the equality is broken the moment even one of the three variables is updated: x = x * 1 y = y * 2 z = z * 3 print ( x , y , z ) The output is: 10 20 30","title":"Multiple Assignment"},{"location":"chapter-2/lesson-2.1/#assignment-shortcuts","text":"Execute the code given below and observe the output. What do you think is happening? x = 1 x += 1 print ( x ) += is something that we haven't seen before. x += a Increment the value of x by a . In other words, add a to x and store the result in x . It is equivalent to the statement x = x + a . This is not just limited to the addition operator. The following table gives a summary of the shortcuts for some of the arithmetic operators: Shortcut Meaning x += a x = x + a x -= a x = x - a x *= a x = x * a x /= a x = x / a x %= a x = x % a x **= a x = x ** a Note that the arithmetic operator must always come before the assignment operator in a shortcut. Swapping them will not work: x = 1 x =+ 1 print ( x ) This will give 1 as the output. This is because + is treated as the unary operator here. Statements like x =* 1 or x =/ 2 will result in errors!","title":"Assignment Shortcuts"},{"location":"chapter-2/lesson-2.1/#deleting-variables","text":"Variables can be deleted by using the del keyword: 1 2 3 4 5 x = 100 print ( 'x is a variable whose value is' , x ) print ( 'we are now going to delete x' ) del x print ( x ) When this code is executed, line 5 throws a NameError . This is because x was deleted in line 4 and we are trying to access a variable that is no longer defined at line 5.","title":"Deleting Variables"},{"location":"chapter-2/lesson-2.2/","text":"Lesson-2.2 Input Accepting input from the user routinely happens in programming. Any piece of software shipped to a customer needs to have a functional interface that will let the user interact with the software. We all have used apps like Facebook, Instagram and Twitter. These apps regularly accept input from the user, though we seldom look at it from a programming perspective. Take the case of commenting on a post in Facebook. The text entered in the comment box is the input. The code running in the backend processes this input and then displays it as a comment in a visually appealing form. Python provides a built-in function called input () to accept input from the user. This is a simple yet powerful function: x = input () print ( 'The input entered by the user is' , x ) Execute the code given above and head to the console. Here the interpreter waits patiently for you to enter text. Press Enter after entering the input. This acts as a cue for the interpreter to understand that you have completed entering your input. This text is stored in the variable x . The way it looks in the console is as follows: 1 The input entered by the user is 1 Sometimes we may want to prompt the user to enter a particular type of input. This can be done by passing the instruction as an argument to the input function: x = input ( 'Enter an integer between 0 and 10: ' ) print ( 'The number entered by the user is' , x ) Let us now look at the type of the variable x : x = input () print ( 'The input entered by the user is of type' , type ( x )) Execute the above code with the following input types: int , float , str and bool . What is the output in each case? We see that the input () function always returns a string. Even if the user enters a number, say 123 , that is processed as the string '123' . If we want to accept an integer as input, how do we do it? We take the help of an operation called type conversion. Type Conversion If we want to convert a string into an integer, Python provides a built-in function called int () : 1 2 3 4 x = '123' print ( 'The type of x is' , type ( x )) y = int ( x ) print ( 'The type of y is' , type ( y )) The operation in line 3 is called type conversion, i.e., we are converting an object of type str into an object of type int . The inverse operation also works. Predictably, the function needed for this purpose is str () : 1 2 3 4 x = 123 print ( 'The type of x is' , type ( x )) y = str ( x ) print ( 'The type of y is' , type ( y )) If we want to accept an integer input from the user, we first take a string as input and then convert it into an integer: 1 2 3 x = input ( 'Enter an integer: ' ) x = int ( x ) print ( 'The integer entered by the user is' , x ) Instead of writing this in two lines, we could write this in a single line: 1 2 x = int ( input ()) print ( 'The integer entered by the user is' , x ) What we have done in line 1 is to compose two functions. That is, pass the output of the inner function - input () - as the input of the outer function - int () . In the above code, what happens if the input entered is a float value? x = int ( input ()) # user enters a float value here The code will throw a ValueError . Let us take a concrete example. When the command int ( '1.23' ) is entered, the interpreter tries to convert the string '1.23' into an integer. But the number enclosed within the quotes is not an int , but a float . This number cannot be converted into an integer, hence the error. Built-in Functions We have been using the term built-in functions quite often. These are functions that have already been defined. Loosely speaking, a function in Python is an object that accepts inputs and produces outputs. For example, print () is a built-in function that accepts an input and prints it to the console. We will look at few more functions which will come in handy. round () accepts a number as input and returns the integer closest to it. For example, round ( 1.2 ) returns 1 , while round ( 1.9 ) returns 2 . abs () accepts a number as input and returns its absolute value. For example, abs ( - 1.2 ) returns 1.2 . int () is a bit involved. If an integer enclosed within quotes (string) is entered as input, then the output is that integer. We have already seen this: int ( '123' ) is 123 . If a float is entered as input, then the decimal part is thrown away and the integer part is returned. For example, int ( 1.2 ) returns 1 and int ( - 2.5 ) returns - 2 . Do note that if a float is passed in the form of a string, a ValueError will be thrown i.e., int ( '2.5' ) will result in the following message: ValueError: invalid literal for int() with base 10: '2.5' pow () is another useful function. pow ( x , y ) returns the value of \\(x^{y}\\) . This performs the same function as the ** operator. In general, the ** operator is faster than the pow function. But for small numbers, the difference is not perceptible. In fact, using the pow () function increases readability of code. An extra feature of pow () is that it supports a third argument: pow(x, y, z) returns the value of \\(x^{y} \\text{ mod } z\\) . That is, it gives the remainder when \\(x^y\\) is divided by \\(z\\) . isinstance () is used to check if an object is of a specified type. For example isinstance ( 3 , int ) returns the value True as the literal 3 is of type int . The first argument could be any object, not just a literal. For example, if x is a variable of type str then, isinstance ( x , str ) will again return True . The Python documentation provides an exhaustive list of built-in functions.","title":"Lesson-2.2"},{"location":"chapter-2/lesson-2.2/#lesson-22","text":"","title":"Lesson-2.2"},{"location":"chapter-2/lesson-2.2/#input","text":"Accepting input from the user routinely happens in programming. Any piece of software shipped to a customer needs to have a functional interface that will let the user interact with the software. We all have used apps like Facebook, Instagram and Twitter. These apps regularly accept input from the user, though we seldom look at it from a programming perspective. Take the case of commenting on a post in Facebook. The text entered in the comment box is the input. The code running in the backend processes this input and then displays it as a comment in a visually appealing form. Python provides a built-in function called input () to accept input from the user. This is a simple yet powerful function: x = input () print ( 'The input entered by the user is' , x ) Execute the code given above and head to the console. Here the interpreter waits patiently for you to enter text. Press Enter after entering the input. This acts as a cue for the interpreter to understand that you have completed entering your input. This text is stored in the variable x . The way it looks in the console is as follows: 1 The input entered by the user is 1 Sometimes we may want to prompt the user to enter a particular type of input. This can be done by passing the instruction as an argument to the input function: x = input ( 'Enter an integer between 0 and 10: ' ) print ( 'The number entered by the user is' , x ) Let us now look at the type of the variable x : x = input () print ( 'The input entered by the user is of type' , type ( x )) Execute the above code with the following input types: int , float , str and bool . What is the output in each case? We see that the input () function always returns a string. Even if the user enters a number, say 123 , that is processed as the string '123' . If we want to accept an integer as input, how do we do it? We take the help of an operation called type conversion.","title":"Input"},{"location":"chapter-2/lesson-2.2/#type-conversion","text":"If we want to convert a string into an integer, Python provides a built-in function called int () : 1 2 3 4 x = '123' print ( 'The type of x is' , type ( x )) y = int ( x ) print ( 'The type of y is' , type ( y )) The operation in line 3 is called type conversion, i.e., we are converting an object of type str into an object of type int . The inverse operation also works. Predictably, the function needed for this purpose is str () : 1 2 3 4 x = 123 print ( 'The type of x is' , type ( x )) y = str ( x ) print ( 'The type of y is' , type ( y )) If we want to accept an integer input from the user, we first take a string as input and then convert it into an integer: 1 2 3 x = input ( 'Enter an integer: ' ) x = int ( x ) print ( 'The integer entered by the user is' , x ) Instead of writing this in two lines, we could write this in a single line: 1 2 x = int ( input ()) print ( 'The integer entered by the user is' , x ) What we have done in line 1 is to compose two functions. That is, pass the output of the inner function - input () - as the input of the outer function - int () . In the above code, what happens if the input entered is a float value? x = int ( input ()) # user enters a float value here The code will throw a ValueError . Let us take a concrete example. When the command int ( '1.23' ) is entered, the interpreter tries to convert the string '1.23' into an integer. But the number enclosed within the quotes is not an int , but a float . This number cannot be converted into an integer, hence the error.","title":"Type Conversion"},{"location":"chapter-2/lesson-2.2/#built-in-functions","text":"We have been using the term built-in functions quite often. These are functions that have already been defined. Loosely speaking, a function in Python is an object that accepts inputs and produces outputs. For example, print () is a built-in function that accepts an input and prints it to the console. We will look at few more functions which will come in handy. round () accepts a number as input and returns the integer closest to it. For example, round ( 1.2 ) returns 1 , while round ( 1.9 ) returns 2 . abs () accepts a number as input and returns its absolute value. For example, abs ( - 1.2 ) returns 1.2 . int () is a bit involved. If an integer enclosed within quotes (string) is entered as input, then the output is that integer. We have already seen this: int ( '123' ) is 123 . If a float is entered as input, then the decimal part is thrown away and the integer part is returned. For example, int ( 1.2 ) returns 1 and int ( - 2.5 ) returns - 2 . Do note that if a float is passed in the form of a string, a ValueError will be thrown i.e., int ( '2.5' ) will result in the following message: ValueError: invalid literal for int() with base 10: '2.5' pow () is another useful function. pow ( x , y ) returns the value of \\(x^{y}\\) . This performs the same function as the ** operator. In general, the ** operator is faster than the pow function. But for small numbers, the difference is not perceptible. In fact, using the pow () function increases readability of code. An extra feature of pow () is that it supports a third argument: pow(x, y, z) returns the value of \\(x^{y} \\text{ mod } z\\) . That is, it gives the remainder when \\(x^y\\) is divided by \\(z\\) . isinstance () is used to check if an object is of a specified type. For example isinstance ( 3 , int ) returns the value True as the literal 3 is of type int . The first argument could be any object, not just a literal. For example, if x is a variable of type str then, isinstance ( x , str ) will again return True . The Python documentation provides an exhaustive list of built-in functions.","title":"Built-in Functions"},{"location":"chapter-2/lesson-2.3/","text":"Lesson-2.3 Conditional Statements Suppose you had to solve the following problem: Problem Accept an integer as input from the user. If the number is greater than zero, print positive and if number is less than zero, print negative , else print zero . This problem can solved by so called Conditional Statements. Conditional Statements is a very important concept in Computer Science in general and are the building blocks to solutions for very complex problems. Conditional Statements, as the name suggests, allow for conditional execution of code. We will we see what this means in detail in the coming sections. if statement Let's start off with a simpler version of the earlier problem Problem Accept an integer as input from the user. If the number is greater than zero, print non-negative . if is a keyword in Python. The text adjacent to if is a boolean expression, usually called the if-condition or just the condition . Line-3 is the body of if . If the condition evaluates to True , then line-3 is executed. If it is False , then line-3 doesn't get executed. The following diagram captures the terms that have been introduced: The control flow of the if-statement as a flow chart is given below: Thus we can solve the problem with if: 1 2 3 x = int ( input ()) if x >= 0 : print ( 'non-negative' ) Note that line 3 in the solution code is indented. In this case, the indentation corresponds to four spaces. It is very important to keep this consistent throughout the program. In all lessons, the first level of indentation will have four space . To understand how indentation works and why it is necessary, consider the following code blocks: Lines 3-5 in the following codes make up the if-block . Lines 4 and 5 which are indented make up the body of if . Whenever the if-condition evaluates to True , the interpreter enters the body of if and executes the lines sequentially. The indentation helps in separating the body of the if-block from the rest of the code. Positive x Negative x 1 2 3 4 5 6 # Left x = 1 if x >= 0 : print ( 'non-negative' ) print ( 'inside if' ) print ( 'outside if' ) The condition is True . So lines 4 and 5 are going to be executed. Once we exit the if-block, the interpreter will resume execution from line 6. The output will be: 1 2 3 non-negative inside if outside if 1 2 3 4 5 6 # Right x = - 1 if x >= 0 : print ( 'non-negative' ) print ( 'inside if' ) print ( 'outside if' ) The condition is False . So, lines 4 and 5 are not going to be executed. The interpreter will skip the body of if and directly move to line 6. The output will be 1 outside if if-else Let us add one more level of complexity to the problem. Problem Problem Accept an integer as input from the user. If the number is greater than or equal to zero, print: non-negative . If the number is less than zero, print negative . else is a keyword in Python. When the if-condition evaluates to True , the statements inside the body of the if-block are evaluated. When the condition evaluates to False , the statements inside the body of the else-block are evaluated. A visual representation of the control flow: Now that with else we can add additional conditional branching to our code and solve the question: 1 2 3 4 5 x = int ( input ()) if x >= 0 : print ( 'non-negative' ) else : print ( 'negative' ) Line 2 checks if x is greater than or equal to 0 . Upon failing that condition, the else block executes. Points to remember: if and else are at the same level of indentation. else can never occur independent of an if in conditional statements. else cannot have any new condition associated with it. The following code demonstrates the last two points: ##### Alarm! Wrong code snippet! ##### else : print ( 1 ) ##### Alarm! Wrong code snippet! ##### ##### Alarm! Wrong code snippet! ##### x , y = 1 , 2 if x >= y : print ( 1 ) else x < y : print ( 1 ) ##### Alarm! Wrong code snippet! ##### if-elif-else This final tool will help us solve the original problem: Problem Accept an integer as input from the user. If the number is greater than zero, print positive and if number is less than zero, print negative , else print zero . elif is a keyword in Python. It is a shorthand for else-if. With this final weapon in our conditional statements arsenal, we can solve the problem as thus 1 2 3 4 5 6 7 8 x = int ( input ()) if x > 0 : print ( 'positive' ) elif x == 0 : print ( 'zero' ) else : print ( 'negative' ) # End of code To understand how this works, let us consider three different inputs and the corresponding outputs. Input Output x = 1 positive x = 0 zero x = -1 negative The entire if - elif - else block has three sub-blocks in it: if-block: lines 2-3 elif-block: lines 4-5 else-block: lines 6-7 This is the process followed by the interpreter in executing the if - elif - else block: If the if-condition evaluates to True , line 3 is executed and then the control transfers to line-8. If the if condition evaluates to False , the control transfers to the elif block. If the elif condition evaluates to True , then line 5 is executed and then the control transfers to line 8. If the elif condition is False , the control transfers to the else block and line 7 is executed. As there are no more conditions to check, control naturally transfers to line 8. A visual representation of the process is given below: The general syntax: if <condition-1>: <statement-1> elif <condition-2>: <statement-2> else: <statement-3> Some features to note: Exactly one of the three statements gets executed. The moment either an if or an elif condition evaluates to True , the body of that block is executed and the flow exits out of the entire if - elif - else block. There could be multiple elif conditions after the if . An else condition cannot come before an elif . The final else block is not mandatory and can be removed. If the else is present, it can only come at the end. Nested conditional statements Consider the following problem: Accept three distinct integers as input from the user. If the numbers have been entered in ascending order, print in ascending order . If not, print not in ascending order . An incomplete solution is given below: # Incomplete solution x = int ( input ()) y = int ( input ()) z = int ( input ()) if x < y : print ( 'in ascending order' ) else : print ( 'not in ascending order' ) The problem with the above solution is that it doesn't check if y < z . So, for an input like x, y, z = 1, 3, 2 , it will print in ascending order , which is incorrect. The complete solution is given below: x = int ( input ()) y = int ( input ()) z = int ( input ()) if x < y : if y < z : print ( 'in ascending order' ) else : print ( 'not in ascending order' ) else : print ( 'not in ascending order' ) Whenever a new if block is introduced, its body should have exactly one level of indentation with respect to its if condition. Since line 7 makes up the body of the if block starting at line 6, it has one level of indentation with respect to line 6. However, line 6 is already at the first level of indentation with respect to line 5, so line 7 has two levels of indentation with respect to line 5. According to the convention we have chosen, two levels of indentation will correspond to eight spaces. Having a conditional statement inside another conditional statement is called nesting. The if-block from lines 5-9 forms the outer block. The if-else block from lines 6-9 forms the inner block. The else in line 8 is paired with the if in line 6 as they are at the same level of indentation. For similar reasons, the else in line 10 is paired with the if in line 5. Defining variables inside if Consider the following snippet of code: x = int ( input ()) if x % 5 == 0 : output = 'the number is divisible by 5' print ( output ) Run the code multiple times, varying the input each time. What do you observe? Whenever the input is a multiple of 5, the code runs without any error. When the input is not divisible by 5, the code throws a NameError . This is because, we are trying to reference a variable that has not been defined. The variable output is created only if line 3 is executed during run-time. Its mere presence in the code is not enough.","title":"Lesson-2.3"},{"location":"chapter-2/lesson-2.3/#lesson-23","text":"","title":"Lesson-2.3"},{"location":"chapter-2/lesson-2.3/#conditional-statements","text":"Suppose you had to solve the following problem: Problem Accept an integer as input from the user. If the number is greater than zero, print positive and if number is less than zero, print negative , else print zero . This problem can solved by so called Conditional Statements. Conditional Statements is a very important concept in Computer Science in general and are the building blocks to solutions for very complex problems. Conditional Statements, as the name suggests, allow for conditional execution of code. We will we see what this means in detail in the coming sections.","title":"Conditional Statements"},{"location":"chapter-2/lesson-2.3/#if-statement","text":"Let's start off with a simpler version of the earlier problem Problem Accept an integer as input from the user. If the number is greater than zero, print non-negative . if is a keyword in Python. The text adjacent to if is a boolean expression, usually called the if-condition or just the condition . Line-3 is the body of if . If the condition evaluates to True , then line-3 is executed. If it is False , then line-3 doesn't get executed. The following diagram captures the terms that have been introduced: The control flow of the if-statement as a flow chart is given below: Thus we can solve the problem with if: 1 2 3 x = int ( input ()) if x >= 0 : print ( 'non-negative' ) Note that line 3 in the solution code is indented. In this case, the indentation corresponds to four spaces. It is very important to keep this consistent throughout the program. In all lessons, the first level of indentation will have four space . To understand how indentation works and why it is necessary, consider the following code blocks: Lines 3-5 in the following codes make up the if-block . Lines 4 and 5 which are indented make up the body of if . Whenever the if-condition evaluates to True , the interpreter enters the body of if and executes the lines sequentially. The indentation helps in separating the body of the if-block from the rest of the code. Positive x Negative x 1 2 3 4 5 6 # Left x = 1 if x >= 0 : print ( 'non-negative' ) print ( 'inside if' ) print ( 'outside if' ) The condition is True . So lines 4 and 5 are going to be executed. Once we exit the if-block, the interpreter will resume execution from line 6. The output will be: 1 2 3 non-negative inside if outside if 1 2 3 4 5 6 # Right x = - 1 if x >= 0 : print ( 'non-negative' ) print ( 'inside if' ) print ( 'outside if' ) The condition is False . So, lines 4 and 5 are not going to be executed. The interpreter will skip the body of if and directly move to line 6. The output will be 1 outside if","title":"if statement"},{"location":"chapter-2/lesson-2.3/#if-else","text":"Let us add one more level of complexity to the problem. Problem Problem Accept an integer as input from the user. If the number is greater than or equal to zero, print: non-negative . If the number is less than zero, print negative . else is a keyword in Python. When the if-condition evaluates to True , the statements inside the body of the if-block are evaluated. When the condition evaluates to False , the statements inside the body of the else-block are evaluated. A visual representation of the control flow: Now that with else we can add additional conditional branching to our code and solve the question: 1 2 3 4 5 x = int ( input ()) if x >= 0 : print ( 'non-negative' ) else : print ( 'negative' ) Line 2 checks if x is greater than or equal to 0 . Upon failing that condition, the else block executes. Points to remember: if and else are at the same level of indentation. else can never occur independent of an if in conditional statements. else cannot have any new condition associated with it. The following code demonstrates the last two points: ##### Alarm! Wrong code snippet! ##### else : print ( 1 ) ##### Alarm! Wrong code snippet! ##### ##### Alarm! Wrong code snippet! ##### x , y = 1 , 2 if x >= y : print ( 1 ) else x < y : print ( 1 ) ##### Alarm! Wrong code snippet! #####","title":"if-else"},{"location":"chapter-2/lesson-2.3/#if-elif-else","text":"This final tool will help us solve the original problem: Problem Accept an integer as input from the user. If the number is greater than zero, print positive and if number is less than zero, print negative , else print zero . elif is a keyword in Python. It is a shorthand for else-if. With this final weapon in our conditional statements arsenal, we can solve the problem as thus 1 2 3 4 5 6 7 8 x = int ( input ()) if x > 0 : print ( 'positive' ) elif x == 0 : print ( 'zero' ) else : print ( 'negative' ) # End of code To understand how this works, let us consider three different inputs and the corresponding outputs. Input Output x = 1 positive x = 0 zero x = -1 negative The entire if - elif - else block has three sub-blocks in it: if-block: lines 2-3 elif-block: lines 4-5 else-block: lines 6-7 This is the process followed by the interpreter in executing the if - elif - else block: If the if-condition evaluates to True , line 3 is executed and then the control transfers to line-8. If the if condition evaluates to False , the control transfers to the elif block. If the elif condition evaluates to True , then line 5 is executed and then the control transfers to line 8. If the elif condition is False , the control transfers to the else block and line 7 is executed. As there are no more conditions to check, control naturally transfers to line 8. A visual representation of the process is given below: The general syntax: if <condition-1>: <statement-1> elif <condition-2>: <statement-2> else: <statement-3> Some features to note: Exactly one of the three statements gets executed. The moment either an if or an elif condition evaluates to True , the body of that block is executed and the flow exits out of the entire if - elif - else block. There could be multiple elif conditions after the if . An else condition cannot come before an elif . The final else block is not mandatory and can be removed. If the else is present, it can only come at the end.","title":"if-elif-else"},{"location":"chapter-2/lesson-2.3/#nested-conditional-statements","text":"Consider the following problem: Accept three distinct integers as input from the user. If the numbers have been entered in ascending order, print in ascending order . If not, print not in ascending order . An incomplete solution is given below: # Incomplete solution x = int ( input ()) y = int ( input ()) z = int ( input ()) if x < y : print ( 'in ascending order' ) else : print ( 'not in ascending order' ) The problem with the above solution is that it doesn't check if y < z . So, for an input like x, y, z = 1, 3, 2 , it will print in ascending order , which is incorrect. The complete solution is given below: x = int ( input ()) y = int ( input ()) z = int ( input ()) if x < y : if y < z : print ( 'in ascending order' ) else : print ( 'not in ascending order' ) else : print ( 'not in ascending order' ) Whenever a new if block is introduced, its body should have exactly one level of indentation with respect to its if condition. Since line 7 makes up the body of the if block starting at line 6, it has one level of indentation with respect to line 6. However, line 6 is already at the first level of indentation with respect to line 5, so line 7 has two levels of indentation with respect to line 5. According to the convention we have chosen, two levels of indentation will correspond to eight spaces. Having a conditional statement inside another conditional statement is called nesting. The if-block from lines 5-9 forms the outer block. The if-else block from lines 6-9 forms the inner block. The else in line 8 is paired with the if in line 6 as they are at the same level of indentation. For similar reasons, the else in line 10 is paired with the if in line 5.","title":"Nested conditional statements"},{"location":"chapter-2/lesson-2.3/#defining-variables-inside-if","text":"Consider the following snippet of code: x = int ( input ()) if x % 5 == 0 : output = 'the number is divisible by 5' print ( output ) Run the code multiple times, varying the input each time. What do you observe? Whenever the input is a multiple of 5, the code runs without any error. When the input is not divisible by 5, the code throws a NameError . This is because, we are trying to reference a variable that has not been defined. The variable output is created only if line 3 is executed during run-time. Its mere presence in the code is not enough.","title":"Defining variables inside if"},{"location":"chapter-2/lesson-2.4/","text":"Lesson-2.4 Library A library is a collection of functions that share a common theme. This is a loose definition and will become clear when we start working with a library. calendar Consider the following problem: In the year \\(3000\\) , \\(15^{\\text{th}}\\) \u200b August will fall on which day of the week? Python to the rescue: import calendar calendar . prmonth ( 3000 , 8 ) When the above code is executed, the output is: August 3000 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 15th of August falls on a Friday. Isn't that lovely? It took just two lines of code! calendar is one among several libraries in Python's standard library. A comprehensive list can be found here . Going back to the code, calendar is the name of the library and import is the keyword used to include this library as a part of the code. calendar is a collection of functions that are related to calendars. prmonth () is one such function. It accepts <year> and <month> , as input and displays the calendar for <month> in the year <year> . If we want to use a function in calendar , we must first import the library. Let us see what happens if skip this step: # import calendar calendar . prmonth ( 3000 , 8 ) It gives the following error: NameError: name 'calendar' is not defined To access a function defined inside a library, we use the following syntax: <calendar>.<function>(<arguments>) Another way to solve the problem is to use the function weekday : import calendar print ( calendar . weekday ( 3000 , 8 , 15 )) The output of the above code is 4 . Days are mapped to numbers as follows: Day Number Monday 0 Tuesday 1 Wednesday 2 Thursday 3 Friday 4 Saturday 5 Sunday 6 time Let us now try to answer this hypothetical question: Problem You are stranded on an island in the middle of the Indian Ocean. The island has a computing device that has just one application installed in it: a Python interpreter. You wish to know the current date and time. Solution from time import ctime print ( 'The current time is:' , ctime ()) The output is: The current time is: Fri Apr 2 12:24:43 2021 The syntax of the import statement in line-1 looks different. from is a new keyword. The first line of the code is essentially doing the following: from the library called time import the function called ctime . This way of importing functions is useful when we need just one or two functions from a given library: from time import ctime , sleep print ( 'Current time is:' , ctime ()) print ( 'I am going to sleep for 10 seconds' ) sleep ( 10 ) print ( 'Current time is:' , ctime ()) sleep(x) is a function in time that suspends the execution of the program for x seconds. If we would be using several functions in the library, then it is a bad idea to keep importing each of them individually. In such cases, it is good to fall back on importing the entire library. this As a fun exercise, consider the following code: import this This gives the following output: The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! These are some nuggets of wisdom from Tim Peters, a \"major contributor to the Python programming language\" refer . Some of the points make immediate sense, such as \"readability counts\".","title":"Lesson-2.4"},{"location":"chapter-2/lesson-2.4/#lesson-24","text":"","title":"Lesson-2.4"},{"location":"chapter-2/lesson-2.4/#library","text":"A library is a collection of functions that share a common theme. This is a loose definition and will become clear when we start working with a library.","title":"Library"},{"location":"chapter-2/lesson-2.4/#calendar","text":"Consider the following problem: In the year \\(3000\\) , \\(15^{\\text{th}}\\) \u200b August will fall on which day of the week? Python to the rescue: import calendar calendar . prmonth ( 3000 , 8 ) When the above code is executed, the output is: August 3000 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 15th of August falls on a Friday. Isn't that lovely? It took just two lines of code! calendar is one among several libraries in Python's standard library. A comprehensive list can be found here . Going back to the code, calendar is the name of the library and import is the keyword used to include this library as a part of the code. calendar is a collection of functions that are related to calendars. prmonth () is one such function. It accepts <year> and <month> , as input and displays the calendar for <month> in the year <year> . If we want to use a function in calendar , we must first import the library. Let us see what happens if skip this step: # import calendar calendar . prmonth ( 3000 , 8 ) It gives the following error: NameError: name 'calendar' is not defined To access a function defined inside a library, we use the following syntax: <calendar>.<function>(<arguments>) Another way to solve the problem is to use the function weekday : import calendar print ( calendar . weekday ( 3000 , 8 , 15 )) The output of the above code is 4 . Days are mapped to numbers as follows: Day Number Monday 0 Tuesday 1 Wednesday 2 Thursday 3 Friday 4 Saturday 5 Sunday 6","title":"calendar"},{"location":"chapter-2/lesson-2.4/#time","text":"Let us now try to answer this hypothetical question: Problem You are stranded on an island in the middle of the Indian Ocean. The island has a computing device that has just one application installed in it: a Python interpreter. You wish to know the current date and time. Solution from time import ctime print ( 'The current time is:' , ctime ()) The output is: The current time is: Fri Apr 2 12:24:43 2021 The syntax of the import statement in line-1 looks different. from is a new keyword. The first line of the code is essentially doing the following: from the library called time import the function called ctime . This way of importing functions is useful when we need just one or two functions from a given library: from time import ctime , sleep print ( 'Current time is:' , ctime ()) print ( 'I am going to sleep for 10 seconds' ) sleep ( 10 ) print ( 'Current time is:' , ctime ()) sleep(x) is a function in time that suspends the execution of the program for x seconds. If we would be using several functions in the library, then it is a bad idea to keep importing each of them individually. In such cases, it is good to fall back on importing the entire library.","title":"time"},{"location":"chapter-2/lesson-2.4/#this","text":"As a fun exercise, consider the following code: import this This gives the following output: The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! These are some nuggets of wisdom from Tim Peters, a \"major contributor to the Python programming language\" refer . Some of the points make immediate sense, such as \"readability counts\".","title":"this"},{"location":"chapter-3/lesson-3.1/","text":"Lesson-3.1 Loops Introduction Consider the following problem: Print the sum of the first five positive integers. With our current knowledge of Python, how do we solve this? print ( 1 + 2 + 3 + 4 + 5 ) Not a very elegant solution, but it gets the job done. Now, how about the following problem? Print the sum of the first 1,000,000 positive integers. The earlier approach is not going to work. One million is just too big a number to count down to. Let's take a diversion and instead ponder: If it takes about five seconds on average to write a number followed by the + symbol, how much time will it take to find the sum of all 1 million numbers? Let's find an answer using python: 1 2 3 4 5 6 7 num = 1_000_000 # _ in a number is used when we have large numbers; improves readability avg_time = 5 seconds = num * avg_time minutes = seconds / 60 hours = minutes / 60 days = hours / 24 print ( 'Approximate number of days =' , round ( days )) It will take nearly 58 days to sum all 1 million integers! This is assuming that we work like machines that don't need food or sleep. All of this just to do something as trivial as finding the sum of numbers. This is where loops come in. while while is a keyword in Python. The expression adjacent to while is a boolean expression, called the while condition , or just the condition . The loopy solution to the problem: 1 2 3 4 5 6 7 total = 0 num = 0 while num < 1_000_000 : num = num + 1 total = total + num print ( total ) # Rest of code will follow below this comment There's a lot to unpack here. Lines 4 and 5 make up the body of while. If the condition evaluates to True , control enters the body of while. The lines in the body are sequentially executed. After the last line in the body is executed, the control loops back to line 3, where the condition is evaluated again. As long as the condition is True , the body of while keeps getting executed. The moment the condition becomes False , the body of the while is skipped and control transfers to line 6. The body of the while loop must always be indented; this helps to separate it from the rest of the code. A visual representation is given below: Let us consider another example: Keep accepting integers as input from the user until the user enters a negative number. Print the sum of the positive numbers entered by the user. Print 0 if the user doesn't enter any positive integer. The visual representation of the code is given below: One final example before closing this section: Keep accepting integers as input from the user until the user enters a negative number. Print the maximum among the positive numbers entered by the user. Print 0 if the user doesn't enter any positive integer. Solution 1 2 3 4 5 6 7 8 9 10 # Initialize num = int ( input ()) max_num = 0 # Loop while num >= 0 : if num > max_num : max_num = num num = int ( input ()) # Print output print ( max_num ) Note that lines 6-8 make up the body of while and are indented. Lines 1, 4 and 9 have some comments which are meant to help the reader understand what is happening in the code that follows them. Loop Control Statements break and continue are keywords in Python and are associated with loops. The break statement is used to exit out of a loop without executing any code that comes below it. For example: 1 2 3 4 5 6 num = 1 while True : if ( num % 2 == 0 ) and ( num % 3 == 0 ) and ( num % 4 == 0 ): break num = num + 1 print ( num ) The above code prints the smallest positive integer that is divisible by 2, 3 and 4, which is the same as the LCM of \\((2, 3, 4)\\) . The moment this number is found, the code breaks out of the loop. The continue statement is used to move to the next iteration of the loop, skipping whatever code comes below it. For example: 1 2 3 4 5 6 x = 0 while x < 50 : x = x + 1 if x % 3 != 0 : continue print ( x ) The code given above prints all positive integers less than or equal to 50 that are divisible by 3. Whenever x is not divisible by 3, we do not want to print the number, so we continue to the next iteration. The similarity between break and continue is that whenever either statement is encountered in a loop, all the statements that follow it are skipped. The main difference is that, break exits the loop whereas continue moves to the next iteration. break and continue are interesting features offered by Python. However, it is important to note that both the examples that we just discussed can be written without using break or continue . It is left as an exercise for the reader to figure out how this can be done.","title":"Lesson-3.1"},{"location":"chapter-3/lesson-3.1/#lesson-31","text":"","title":"Lesson-3.1"},{"location":"chapter-3/lesson-3.1/#loops","text":"","title":"Loops"},{"location":"chapter-3/lesson-3.1/#introduction","text":"Consider the following problem: Print the sum of the first five positive integers. With our current knowledge of Python, how do we solve this? print ( 1 + 2 + 3 + 4 + 5 ) Not a very elegant solution, but it gets the job done. Now, how about the following problem? Print the sum of the first 1,000,000 positive integers. The earlier approach is not going to work. One million is just too big a number to count down to. Let's take a diversion and instead ponder: If it takes about five seconds on average to write a number followed by the + symbol, how much time will it take to find the sum of all 1 million numbers? Let's find an answer using python: 1 2 3 4 5 6 7 num = 1_000_000 # _ in a number is used when we have large numbers; improves readability avg_time = 5 seconds = num * avg_time minutes = seconds / 60 hours = minutes / 60 days = hours / 24 print ( 'Approximate number of days =' , round ( days )) It will take nearly 58 days to sum all 1 million integers! This is assuming that we work like machines that don't need food or sleep. All of this just to do something as trivial as finding the sum of numbers. This is where loops come in.","title":"Introduction"},{"location":"chapter-3/lesson-3.1/#while","text":"while is a keyword in Python. The expression adjacent to while is a boolean expression, called the while condition , or just the condition . The loopy solution to the problem: 1 2 3 4 5 6 7 total = 0 num = 0 while num < 1_000_000 : num = num + 1 total = total + num print ( total ) # Rest of code will follow below this comment There's a lot to unpack here. Lines 4 and 5 make up the body of while. If the condition evaluates to True , control enters the body of while. The lines in the body are sequentially executed. After the last line in the body is executed, the control loops back to line 3, where the condition is evaluated again. As long as the condition is True , the body of while keeps getting executed. The moment the condition becomes False , the body of the while is skipped and control transfers to line 6. The body of the while loop must always be indented; this helps to separate it from the rest of the code. A visual representation is given below: Let us consider another example: Keep accepting integers as input from the user until the user enters a negative number. Print the sum of the positive numbers entered by the user. Print 0 if the user doesn't enter any positive integer. The visual representation of the code is given below: One final example before closing this section: Keep accepting integers as input from the user until the user enters a negative number. Print the maximum among the positive numbers entered by the user. Print 0 if the user doesn't enter any positive integer. Solution 1 2 3 4 5 6 7 8 9 10 # Initialize num = int ( input ()) max_num = 0 # Loop while num >= 0 : if num > max_num : max_num = num num = int ( input ()) # Print output print ( max_num ) Note that lines 6-8 make up the body of while and are indented. Lines 1, 4 and 9 have some comments which are meant to help the reader understand what is happening in the code that follows them.","title":"while"},{"location":"chapter-3/lesson-3.1/#loop-control-statements","text":"break and continue are keywords in Python and are associated with loops. The break statement is used to exit out of a loop without executing any code that comes below it. For example: 1 2 3 4 5 6 num = 1 while True : if ( num % 2 == 0 ) and ( num % 3 == 0 ) and ( num % 4 == 0 ): break num = num + 1 print ( num ) The above code prints the smallest positive integer that is divisible by 2, 3 and 4, which is the same as the LCM of \\((2, 3, 4)\\) . The moment this number is found, the code breaks out of the loop. The continue statement is used to move to the next iteration of the loop, skipping whatever code comes below it. For example: 1 2 3 4 5 6 x = 0 while x < 50 : x = x + 1 if x % 3 != 0 : continue print ( x ) The code given above prints all positive integers less than or equal to 50 that are divisible by 3. Whenever x is not divisible by 3, we do not want to print the number, so we continue to the next iteration. The similarity between break and continue is that whenever either statement is encountered in a loop, all the statements that follow it are skipped. The main difference is that, break exits the loop whereas continue moves to the next iteration. break and continue are interesting features offered by Python. However, it is important to note that both the examples that we just discussed can be written without using break or continue . It is left as an exercise for the reader to figure out how this can be done.","title":"Loop Control Statements"},{"location":"chapter-3/lesson-3.2/","text":"Lesson-3.2 Loops for loop Let us look at a simple problem of printing numbers. We would like to print the first 5 non-negative integers. We could do this using a while loop but let's try a different kind of a loop now, the for loop: 1 2 3 for i in range ( 5 ): print ( i ) # A dummy line The output is: 1 2 3 4 5 0 1 2 3 4 for and in are keywords in Python. range is an object that represents a sequence of numbers. Line-2 is the body of the loop. An intuitive understanding of the code given above is as follows: In each iteration of the loop, an element in the sequence is picked up and is printed to the console. Assuming that the sequence is ordered from left to right, the leftmost element is the first to be picked up. The sequence is processed from left to right. Once the rightmost element has been printed to the console, control returns to line 1 for one last time. Since there are no more elements to be read in the sequence, the control exits the loop and moves to line 3. A visual representation is given below: Similar to while loops and if - else blocks, the body of a for loop should be indented. range() Now let's dive a bit deeper into this range () function that we have been using. This function predictably returns a sequence, or a range if you will, of numbers. range ( 5 ) results in the following sequence: \\(0, 1, 2, 3, 4\\) . In general, range ( n ) creates the sequence: \\(0, 1, ..., n - 1\\) . range is quite versatile. The following code prints all two digit numbers greater than zero: 1 2 for i in range ( 10 , 100 ): print ( i ) range ( 10 , 100 ) represents the sequence \\(10, 11, ..., 99\\) . In general, range ( start , stop ) represents the sequence start, start + 1, ..., stop - 1 . Let us add another level of complexity. The following code prints all even two digit natural numbers: 1 2 for i in range ( 10 , 100 , 2 ): print ( i ) range(10, 100, 2) represents the sequence 10, 12, ..., 98 . In general, range(start, stop, step) represents the sequence start, start + step, start + 2 * step, ..., last , where last is the largest element in this sequence that is less than stop . This is true when the step parameter is positive. The following are equivalent: range ( n ) range ( 0 , n ) range ( 0 , n , 1 ) So far we have seen only increasing sequences. With the help of a negative step size, we can also come up with decreasing sequences. The following code prints all two-digit even numbers greater than zero in descending order: 1 2 for i in range ( 98 , 9 , - 2 ): print ( i ) For a negative step value, range ( start , stop , step ) represents the sequence start, start + step, start + 2 * step, ..., last , where last is the smallest element in the sequence greater than stop . Now, consider the following code: 1 2 for i in range ( 5 , 5 ): print ( i ) range ( 5 , 5 ) is an empty sequence. So, the above code will not print anything. Another instance of an empty sequence: 1 2 for i in range ( 10 , 5 ): print ( i ) The point to note is that neither of these code snippets produces any error. Finally, try executing the following snippet and observe the output. ##### Alarm! Wrong code snippet! ##### for i in range ( 0.0 , 10.0 ): print ( i ) ##### Alarm! Wrong code snippet! ##### Iterating through Strings Since a string is a sequence of characters, we can use the for loop to iterate through strings. The following code will print each character of the string x in one line: 1 2 3 word = 'good' for char in word : print ( char ) The output is: 1 2 3 4 g o o d We can add some more code to enrich the output: 1 2 3 4 5 word = 'good' count = 1 for char in word : print ( char , 'occurs at position' , count , 'in the string' , word ) count = count + 1 The output is: 1 2 3 4 g occurs at position 1 in the string good o occurs at position 2 in the string good o occurs at position 3 in the string good d occurs at position 4 in the string good","title":"Lesson-3.2"},{"location":"chapter-3/lesson-3.2/#lesson-32","text":"","title":"Lesson-3.2"},{"location":"chapter-3/lesson-3.2/#loops","text":"","title":"Loops"},{"location":"chapter-3/lesson-3.2/#for-loop","text":"Let us look at a simple problem of printing numbers. We would like to print the first 5 non-negative integers. We could do this using a while loop but let's try a different kind of a loop now, the for loop: 1 2 3 for i in range ( 5 ): print ( i ) # A dummy line The output is: 1 2 3 4 5 0 1 2 3 4 for and in are keywords in Python. range is an object that represents a sequence of numbers. Line-2 is the body of the loop. An intuitive understanding of the code given above is as follows: In each iteration of the loop, an element in the sequence is picked up and is printed to the console. Assuming that the sequence is ordered from left to right, the leftmost element is the first to be picked up. The sequence is processed from left to right. Once the rightmost element has been printed to the console, control returns to line 1 for one last time. Since there are no more elements to be read in the sequence, the control exits the loop and moves to line 3. A visual representation is given below: Similar to while loops and if - else blocks, the body of a for loop should be indented.","title":"for loop"},{"location":"chapter-3/lesson-3.2/#range","text":"Now let's dive a bit deeper into this range () function that we have been using. This function predictably returns a sequence, or a range if you will, of numbers. range ( 5 ) results in the following sequence: \\(0, 1, 2, 3, 4\\) . In general, range ( n ) creates the sequence: \\(0, 1, ..., n - 1\\) . range is quite versatile. The following code prints all two digit numbers greater than zero: 1 2 for i in range ( 10 , 100 ): print ( i ) range ( 10 , 100 ) represents the sequence \\(10, 11, ..., 99\\) . In general, range ( start , stop ) represents the sequence start, start + 1, ..., stop - 1 . Let us add another level of complexity. The following code prints all even two digit natural numbers: 1 2 for i in range ( 10 , 100 , 2 ): print ( i ) range(10, 100, 2) represents the sequence 10, 12, ..., 98 . In general, range(start, stop, step) represents the sequence start, start + step, start + 2 * step, ..., last , where last is the largest element in this sequence that is less than stop . This is true when the step parameter is positive. The following are equivalent: range ( n ) range ( 0 , n ) range ( 0 , n , 1 ) So far we have seen only increasing sequences. With the help of a negative step size, we can also come up with decreasing sequences. The following code prints all two-digit even numbers greater than zero in descending order: 1 2 for i in range ( 98 , 9 , - 2 ): print ( i ) For a negative step value, range ( start , stop , step ) represents the sequence start, start + step, start + 2 * step, ..., last , where last is the smallest element in the sequence greater than stop . Now, consider the following code: 1 2 for i in range ( 5 , 5 ): print ( i ) range ( 5 , 5 ) is an empty sequence. So, the above code will not print anything. Another instance of an empty sequence: 1 2 for i in range ( 10 , 5 ): print ( i ) The point to note is that neither of these code snippets produces any error. Finally, try executing the following snippet and observe the output. ##### Alarm! Wrong code snippet! ##### for i in range ( 0.0 , 10.0 ): print ( i ) ##### Alarm! Wrong code snippet! #####","title":"range()"},{"location":"chapter-3/lesson-3.2/#iterating-through-strings","text":"Since a string is a sequence of characters, we can use the for loop to iterate through strings. The following code will print each character of the string x in one line: 1 2 3 word = 'good' for char in word : print ( char ) The output is: 1 2 3 4 g o o d We can add some more code to enrich the output: 1 2 3 4 5 word = 'good' count = 1 for char in word : print ( char , 'occurs at position' , count , 'in the string' , word ) count = count + 1 The output is: 1 2 3 4 g occurs at position 1 in the string good o occurs at position 2 in the string good o occurs at position 3 in the string good d occurs at position 4 in the string good","title":"Iterating through Strings"},{"location":"chapter-3/lesson-3.3/","text":"Lesson-3.3 Nested loops Consider the following problem: Find the number of ordered pairs of positive integers whose product is 100. Note that order matters: (2, 50) and (50, 2) are two different pairs. Solution 1 2 3 4 5 6 count = 0 for a in range ( 1 , 101 ): for b in range ( 1 , 101 ): if a * b == 100 : count = count + 1 print ( count ) The code given above is an example of a nested loop. Lines 2-5 form the outer loop while lines 3-5 form the inner-loop. There are multiple levels of indentation here. Line-3 is the beginning of a new for loop, so line 4 is indented with respect to line 3. As line 4 is an if statement, line 5 is indented with respect to line 4. This problem could have been solved without using a nested loop. The nested loop is not an efficient solution. It is left as an exercise to the reader to come up with a more efficient solution to this problem. Let us look at one more problem: Find the number of prime numbers less than \\(n\\) , where \\(n\\) is some positive integer. Solution 1 2 3 4 5 6 7 8 9 10 11 n = int ( input ()) count = 0 for i in range ( 2 , n + 1 ): flag = True for j in range ( 2 , i ): if i % j == 0 : flag = False break if flag : count = count + 1 print ( count ) The basic idea behind the solution is as follows: The outer for loop goes through each element in the sequence \\(2, 3, ..., n\\) . i is the loop variable for this sequence. We begin with the guess that i is prime. In code, we do this by setting flag to be True . Now, we go through all potential divisors of i . This is represented by the sequence \\(2, 3, ..., i - 1\\) . Variable j is the loop variable for this sequence. Notice how the sequence for the inner loop is dependent on i , the loop variable for the outer loop. If j divides i , then i cannot be a prime. We correct our initial assumption by updating flag to False whenever this happens. As we know that i is not prime, there is no use of continuing with the inner-loop, so we break out of it. If j doesn't divide i for any j in this sequence, then i is a prime. In such a situation, our initial assumption is right, and flag stays True . Once we are outside the inner-loop, we check if flag is True . if that is the case, then we increment count as we have hit upon a prime number. Some important points regarding nested loops: Nesting is not restricted to for loops. Any one of the following combinations is possible: for inside for for inside while while inside while while inside for Multiple levels of nesting is possible. while versus for for loops are typically used in situations where the number of iterations can be quantified, whereas while loops are used in situations where the number of iterations cannot be quantified exactly. This doesn't mean that the number of iterations in a for loop is always constant. For example: 1 2 3 n = int ( input ()) for i in range ( n ): print ( i ** 2 ) In the code given above, the number of iterations will keep varying every time the code is run with a different input. But given the knowledge of the input, the number of iterations is fixed. On the other hand, consider the following example: 1 2 3 x = int ( input ()) while x > 0 : x = int ( input ()) The number of iterations in the above code can be determined only after it terminates. There is no way of quantifying the number of iterations as an explicit function of user input. print: end , sep end Consider the following problem: Accept a positive integer n as input and print all the numbers from 1 to n in a single line separated by commas. For a given value of n , say n = 9, we want the output to be: 1,2,3,4,5,6,7,8,9 The following solution won't work: 1 2 3 n = int ( input ()) for i in range ( 1 , n + 1 ): print ( i , ',' ) For n = 9, this will give the following output: 1 2 3 4 5 6 7 8 9 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , Thankfully, the print function provides a way to solve this problem: 1 2 3 4 n = int ( input ()) for i in range ( 1 , n ): print ( i , end = ',' ) print ( n ) For n = 9, this will give the required output: 1,2,3,4,5,6,7,8,9 Whenever we use the print () function, it prints the expression passed to it and immediately follows it up by printing a newline. This is the default behaviour of print () . It can be altered by using a special argument called end . The default value of end is set to the newline character. So, whenever the end argument is not explicitly specified in the print function, a newline is appended to the input expression by default. In the code given above, by setting end to be a comma, we are forcing the print () function to insert a comma instead of a newline at the end of the expression passed to it. It is called end because it is added at the end. To get a better picture, consider the following code: 1 2 3 4 5 6 print () print ( end = ',' ) print ( 1 ) print ( 1 , end = ',' ) print ( 2 , end = ',' ) print ( 3 , end = ',' ) This output is: 1 2 ,1 1,2,3, Even though nothing is being passed to the print function in the first line of code, the first line in the output is a newline because the default value of end is a newline character ( '\\n' ). No expression is passed as input to print in the second line of code as well, but end is set to , . So, only a comma is printed. Notice that line 3 of the code is printed in line 2 of the output. This is because end was set to , instead of the newline character in line 2 of the code. sep If multiple expressions are passed to the print () function, it prints all of them in the same line, by adding a space between adjacent expressions. For example: print ( 'this' , 'is' , 'cool' ) The output is: this is cool What if we do not want the space or if want some other separator? This can be done using sep : print ( 'this' , 'is' , 'cool' , sep = ',' ) The output is: this,is,cool We could also have an empty string as the separator: print ( 'this' , 'is' , 'cool' , sep = '' ) The output will then be: thisiscool end and sep Let us look at one final example that makes use of both end and sep : Accept a positive integer n , which is also a multiple of 3, as input and print the following pattern: |1,2,3|4,5,6|7,8,9|...|n - 2,n - 1,n| For n = 9 , we would like to print: |1,2,3|4,5,6|7,8,9| Solution 1 2 3 4 5 n = int ( input ()) print ( '|' , end = '' ) for i in range ( 1 , n + 1 , 3 ): print ( i , i + 1 , i + 2 , sep = ',' , end = '|' ) print () Notice that the for loop iterates in steps of 3 starting from 1. To print the comma separated triplet i,i + 1,i + 2 , sep is set to , . After printing each triplet, the symbol | needs to be printed. This is achieved by setting end to be equal to | . Line 2 makes sure that the symbol | is present at the beginning of the pattern. The last print () statement outside the loop is there so that the prompt can move to the next line on the console once the pattern has been printed. You can try removing the last line and see how that changes the output on the console.","title":"Lesson-3.3"},{"location":"chapter-3/lesson-3.3/#lesson-33","text":"","title":"Lesson-3.3"},{"location":"chapter-3/lesson-3.3/#nested-loops","text":"Consider the following problem: Find the number of ordered pairs of positive integers whose product is 100. Note that order matters: (2, 50) and (50, 2) are two different pairs. Solution 1 2 3 4 5 6 count = 0 for a in range ( 1 , 101 ): for b in range ( 1 , 101 ): if a * b == 100 : count = count + 1 print ( count ) The code given above is an example of a nested loop. Lines 2-5 form the outer loop while lines 3-5 form the inner-loop. There are multiple levels of indentation here. Line-3 is the beginning of a new for loop, so line 4 is indented with respect to line 3. As line 4 is an if statement, line 5 is indented with respect to line 4. This problem could have been solved without using a nested loop. The nested loop is not an efficient solution. It is left as an exercise to the reader to come up with a more efficient solution to this problem. Let us look at one more problem: Find the number of prime numbers less than \\(n\\) , where \\(n\\) is some positive integer. Solution 1 2 3 4 5 6 7 8 9 10 11 n = int ( input ()) count = 0 for i in range ( 2 , n + 1 ): flag = True for j in range ( 2 , i ): if i % j == 0 : flag = False break if flag : count = count + 1 print ( count ) The basic idea behind the solution is as follows: The outer for loop goes through each element in the sequence \\(2, 3, ..., n\\) . i is the loop variable for this sequence. We begin with the guess that i is prime. In code, we do this by setting flag to be True . Now, we go through all potential divisors of i . This is represented by the sequence \\(2, 3, ..., i - 1\\) . Variable j is the loop variable for this sequence. Notice how the sequence for the inner loop is dependent on i , the loop variable for the outer loop. If j divides i , then i cannot be a prime. We correct our initial assumption by updating flag to False whenever this happens. As we know that i is not prime, there is no use of continuing with the inner-loop, so we break out of it. If j doesn't divide i for any j in this sequence, then i is a prime. In such a situation, our initial assumption is right, and flag stays True . Once we are outside the inner-loop, we check if flag is True . if that is the case, then we increment count as we have hit upon a prime number. Some important points regarding nested loops: Nesting is not restricted to for loops. Any one of the following combinations is possible: for inside for for inside while while inside while while inside for Multiple levels of nesting is possible.","title":"Nested loops"},{"location":"chapter-3/lesson-3.3/#while-versus-for","text":"for loops are typically used in situations where the number of iterations can be quantified, whereas while loops are used in situations where the number of iterations cannot be quantified exactly. This doesn't mean that the number of iterations in a for loop is always constant. For example: 1 2 3 n = int ( input ()) for i in range ( n ): print ( i ** 2 ) In the code given above, the number of iterations will keep varying every time the code is run with a different input. But given the knowledge of the input, the number of iterations is fixed. On the other hand, consider the following example: 1 2 3 x = int ( input ()) while x > 0 : x = int ( input ()) The number of iterations in the above code can be determined only after it terminates. There is no way of quantifying the number of iterations as an explicit function of user input.","title":"while versus for"},{"location":"chapter-3/lesson-3.3/#print-end-sep","text":"","title":"print: end, sep"},{"location":"chapter-3/lesson-3.3/#end","text":"Consider the following problem: Accept a positive integer n as input and print all the numbers from 1 to n in a single line separated by commas. For a given value of n , say n = 9, we want the output to be: 1,2,3,4,5,6,7,8,9 The following solution won't work: 1 2 3 n = int ( input ()) for i in range ( 1 , n + 1 ): print ( i , ',' ) For n = 9, this will give the following output: 1 2 3 4 5 6 7 8 9 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , Thankfully, the print function provides a way to solve this problem: 1 2 3 4 n = int ( input ()) for i in range ( 1 , n ): print ( i , end = ',' ) print ( n ) For n = 9, this will give the required output: 1,2,3,4,5,6,7,8,9 Whenever we use the print () function, it prints the expression passed to it and immediately follows it up by printing a newline. This is the default behaviour of print () . It can be altered by using a special argument called end . The default value of end is set to the newline character. So, whenever the end argument is not explicitly specified in the print function, a newline is appended to the input expression by default. In the code given above, by setting end to be a comma, we are forcing the print () function to insert a comma instead of a newline at the end of the expression passed to it. It is called end because it is added at the end. To get a better picture, consider the following code: 1 2 3 4 5 6 print () print ( end = ',' ) print ( 1 ) print ( 1 , end = ',' ) print ( 2 , end = ',' ) print ( 3 , end = ',' ) This output is: 1 2 ,1 1,2,3, Even though nothing is being passed to the print function in the first line of code, the first line in the output is a newline because the default value of end is a newline character ( '\\n' ). No expression is passed as input to print in the second line of code as well, but end is set to , . So, only a comma is printed. Notice that line 3 of the code is printed in line 2 of the output. This is because end was set to , instead of the newline character in line 2 of the code.","title":"end"},{"location":"chapter-3/lesson-3.3/#sep","text":"If multiple expressions are passed to the print () function, it prints all of them in the same line, by adding a space between adjacent expressions. For example: print ( 'this' , 'is' , 'cool' ) The output is: this is cool What if we do not want the space or if want some other separator? This can be done using sep : print ( 'this' , 'is' , 'cool' , sep = ',' ) The output is: this,is,cool We could also have an empty string as the separator: print ( 'this' , 'is' , 'cool' , sep = '' ) The output will then be: thisiscool","title":"sep"},{"location":"chapter-3/lesson-3.3/#end-and-sep","text":"Let us look at one final example that makes use of both end and sep : Accept a positive integer n , which is also a multiple of 3, as input and print the following pattern: |1,2,3|4,5,6|7,8,9|...|n - 2,n - 1,n| For n = 9 , we would like to print: |1,2,3|4,5,6|7,8,9| Solution 1 2 3 4 5 n = int ( input ()) print ( '|' , end = '' ) for i in range ( 1 , n + 1 , 3 ): print ( i , i + 1 , i + 2 , sep = ',' , end = '|' ) print () Notice that the for loop iterates in steps of 3 starting from 1. To print the comma separated triplet i,i + 1,i + 2 , sep is set to , . After printing each triplet, the symbol | needs to be printed. This is achieved by setting end to be equal to | . Line 2 makes sure that the symbol | is present at the beginning of the pattern. The last print () statement outside the loop is there so that the prompt can move to the next line on the console once the pattern has been printed. You can try removing the last line and see how that changes the output on the console.","title":"end and sep"},{"location":"chapter-3/lesson-3.4/","text":"Lesson-3.4 Formatted printing Consider the following program: 1 2 name = input () print ( 'Hi,' , name , '!' ) When this code is executed with Sachin as the input, we get the following output: Hi, Sachin ! This looks messy as there is an unwanted space after the name. This is a formatting issue. Python provides some useful tools to format text in the way we want. f-strings The first method that we will look at is called formatted string literals or f-strings for short. Let us jump into the syntax: 1 2 name = input () print ( f 'Hi, { name } !' ) When this code is executed with Sachin as the input, we get the following output: Hi, Sachin! The messy formatting has been corrected. Let us take a closer look at the string that was passed to print () : f 'Hi, { name } ' This is called a formatted string literal or f-string. The f in front of the string differentiates f-strings from normal strings. f-string is an object which when evaluated results in a string. The value of the variable name is inserted in place of {name} in the f-string. Two things are important for f-strings to do our bidding: The f in front of the string. The curly braces enclosing the variable. Let us see what happens if we miss one of these two: 1 2 3 name = 'Sachin' print ( 'Hi, {name} !' ) print ( f 'Hi, name!' ) This will give the output: Hi, {name}! Hi, name! Let us now look at few other examples: 1 2 3 4 l , b = int ( input ()), int ( input ()) print ( f 'The length of the rectangle is { l } units' ) print ( f 'The breadth of the rectangle is { b } units' ) print ( f 'The area of the rectangle is { l * b } square units' ) For l = 4, b = 5 , the output is: The length of the rectangle is 4 units The breadth of the rectangle is 5 units The area of the rectangle is 20 square units Going back to the code, lines 2 and 3 are quite clear. Notice that line-4 has an expression \u2014 l * b \u2014 inside the curly braces and not just a variable. f-strings allow any valid Python expression inside the curly braces. If the f-string has some {expression} in it, the interpreter will substitute the value of expression in the place of {expression} . Another example: 1 2 3 4 x = int ( input ()) print ( f 'Multiplication table for { x } ' ) for i in range ( 1 , 11 ): print ( f ' { x } X { i } \\t = \\t { x * i } ' ) For an input of 3, this will give the following result: 1 2 3 4 5 6 7 8 9 10 11 Multiplication table for 3 3 X 1 = 3 3 X 2 = 6 3 X 3 = 9 3 X 4 = 12 3 X 5 = 15 3 X 6 = 18 3 X 7 = 21 3 X 8 = 24 3 X 9 = 27 3 X 10 = 30 The \\t is a tab character. It has been added before and after the = . Remove both the tabs and run the code. Do you see any change in the output? Till now we have passed f-strings to the print () function. Nothing stops us from using it to define other string variables: name = input () qual = input () gender = input () if qual == 'phd' : name_respect = f 'Dr. { name } ' elif gender == 'male' : name_respect = f 'Mr. { name } ' elif gender == 'female' : name_respect = f 'Ms. { name } ' print ( f 'Hello, { name_respect } ' ) Try to guess what this code is doing. format () Another way to format strings is using a string method called format () . name = input () print ( 'Hi, {} !' . format ( name )) In the above string, the curly braces will be replaced by the value of the variable name . Another example: l , b = int ( input ()), int ( input ()) print ( 'The length of the rectangle is {} units' . format ( l )) print ( 'The breadth of the rectangle is {} units' . format ( b )) print ( 'The area of the rectangle is {} square units' . format ( l * b )) Let us now print the multiplication table using format () : 1 2 3 x = int ( input ()) for i in range ( 1 , 11 ): print ( ' {} X {} \\t = \\t {} ' . format ( x , i , x * i )) The output will be identical to the one we saw when we used f-strings. Some points to note in line 3 of this code-block. There are three pairs of curly braces. The values that go into these three positions are given as three arguments in the format () function. Starting from the left, the first pair of curly braces in the string is replaced by the first argument in format , the second pair by the second argument and so on. Few more examples: First, consider the following code: 1 2 3 fruit1 = 'apple' fruit2 = 'banana' print ( ' {} and {} are fruits' . format ( fruit1 , fruit2 )) In this code, the mapping is implicit. The first pair of curly braces is mapped to the first argument and so on. This can be made explicit by specifying which argument a particular curly braces will be mapped to: 1 2 3 fruit1 = 'apple' fruit2 = 'banana' print ( ' {0} and {1} are fruits' . format ( fruit1 , fruit2 )) The integer inside the curly braces gives the index of the argument in the format () function. The arguments of the format () function are indexed from 0 and start from the left. Changing the order of arguments will change the output. A third way of writing this as follows: 1 2 3 fruit1 = 'apple' fruit2 = 'banana' print ( ' {string1} and {string2} are fruits' . format ( string1 = fruit1 , string2 = fruit2 )) This method uses the concept of keyword arguments which we will explore in the lessons on functions in the next chapter. Until then, let us put this last method on the back-burner. Format specifiers Consider the following code: 1 2 pi_approx = 22 / 7 print ( f 'The value of pi is approximately { pi_approx } ' ) This gives the following output: The value of pi is approximately 3.142857142857143 There are too many numbers after the decimal point. In many real world applications, having two or at most three places after the decimal point is sufficient. In fact, having as many as fifteen numbers after the decimal point only confuses readers. Format specifiers are a way to solve this problem: 1 2 pi_approx = 22 / 7 print ( f 'The value of pi is approximately { pi_approx : .2f } ' ) This gives the following output: The value of pi is approximately 3.14 Let us look at the content inside the curly braces: {pi_approx:.2f} . The first part before the : is the variable. Nothing new here. The part after : is called a format specifier. .2f means the following: . - this signifies the decimal point. 2 - since this comes after the decimal point, it stipulates that there should be exactly two numbers after the decimal point. In other words, the value ( pi_approx ) should be rounded off to two decimal places. f - this signifies that we are dealing with a float value. Let us consider a variant of this code: pi_approx = 22 / 7 print ( f 'The value of pi is approximately { pi_approx : .3f } ' ) This gives the following output: The value of pi is approximately 3.143 Let us now take another example. Let us say we want to print the marks of three students in a class: 1 2 3 4 5 6 roll_1 , marks_1 = 'BSC1001' , 90.5 roll_2 , marks_2 = 'BSC1002' , 100 roll_3 , marks_3 = 'BSC1003' , 90.15 print ( f ' { roll_1 } : { marks_1 } ' ) print ( f ' { roll_2 } : { marks_2 } ' ) print ( f ' { roll_3 } : { marks_3 } ' ) This gives the following output: 1 2 3 BSC1001: 90.5 BSC1002: 100 BSC1003: 90.15 While this is not bad, we would like the marks to be right aligned and have a uniform representation for the marks. The following code helps us achieve this:This is what we wish to see: 1 2 3 4 5 6 roll_1 , marks_1 = 'BSC1001' , 90.5 roll_2 , marks_2 = 'BSC1002' , 100 roll_3 , marks_3 = 'BSC1003' , 90.15 print ( f ' { roll_1 } : { marks_1 : 10.2f } ' ) print ( f ' { roll_2 } : { marks_2 : 10.2f } ' ) print ( f ' { roll_3 } : { marks_3 : 10.2f } ' ) The output of the above code will be: 1 2 3 BSC1001: 90.50 BSC1002: 100.00 BSC1003: 90.15 This is much more neater. The part that might be confusing is the second curly braces in each of the print statements. Let us take a closer look: {marks_1:10.2f} . The part before the : is the variable. The part after the : is 10.2f . Here again, .2f signifies that the float value should be rounded off to two decimal places. The 10 before the decimal point is the minimum width of the column used for printing this value. If the number has fewer than 10 characters (including the decimal point), this will be compensated by adding spaces before the number. For a better understanding of this concept, let us turn to printing integers with a specific formatting. This time, we will use the format () function: 1 2 3 4 5 6 print ( ' {0:5d} ' . format ( 1 )) print ( ' {0:5d} ' . format ( 11 )) print ( ' {0:5d} ' . format ( 111 )) print ( ' {:5d} ' . format ( 1111 )) print ( ' {:5d} ' . format ( 11111 )) print ( ' {:5d} ' . format ( 111111 )) This gives the following output: 1 2 3 4 5 6 1 11 111 1111 11111 111111 Points to note in the code: The d stands for integer. First three print statements have the index of the argument \u2014 0 in this case \u2014 before the : . Last three statements do not have the index of the argument. In fact there is nothing before the : . Both representations are valid. The 5d after the : means that the width of the column used for printing must be at least 5. Lines 1 to 4 have spaces before them as the integer being printed has fewer than five characters.","title":"Lesson-3.4"},{"location":"chapter-3/lesson-3.4/#lesson-34","text":"","title":"Lesson-3.4"},{"location":"chapter-3/lesson-3.4/#formatted-printing","text":"Consider the following program: 1 2 name = input () print ( 'Hi,' , name , '!' ) When this code is executed with Sachin as the input, we get the following output: Hi, Sachin ! This looks messy as there is an unwanted space after the name. This is a formatting issue. Python provides some useful tools to format text in the way we want.","title":"Formatted printing"},{"location":"chapter-3/lesson-3.4/#f-strings","text":"The first method that we will look at is called formatted string literals or f-strings for short. Let us jump into the syntax: 1 2 name = input () print ( f 'Hi, { name } !' ) When this code is executed with Sachin as the input, we get the following output: Hi, Sachin! The messy formatting has been corrected. Let us take a closer look at the string that was passed to print () : f 'Hi, { name } ' This is called a formatted string literal or f-string. The f in front of the string differentiates f-strings from normal strings. f-string is an object which when evaluated results in a string. The value of the variable name is inserted in place of {name} in the f-string. Two things are important for f-strings to do our bidding: The f in front of the string. The curly braces enclosing the variable. Let us see what happens if we miss one of these two: 1 2 3 name = 'Sachin' print ( 'Hi, {name} !' ) print ( f 'Hi, name!' ) This will give the output: Hi, {name}! Hi, name! Let us now look at few other examples: 1 2 3 4 l , b = int ( input ()), int ( input ()) print ( f 'The length of the rectangle is { l } units' ) print ( f 'The breadth of the rectangle is { b } units' ) print ( f 'The area of the rectangle is { l * b } square units' ) For l = 4, b = 5 , the output is: The length of the rectangle is 4 units The breadth of the rectangle is 5 units The area of the rectangle is 20 square units Going back to the code, lines 2 and 3 are quite clear. Notice that line-4 has an expression \u2014 l * b \u2014 inside the curly braces and not just a variable. f-strings allow any valid Python expression inside the curly braces. If the f-string has some {expression} in it, the interpreter will substitute the value of expression in the place of {expression} . Another example: 1 2 3 4 x = int ( input ()) print ( f 'Multiplication table for { x } ' ) for i in range ( 1 , 11 ): print ( f ' { x } X { i } \\t = \\t { x * i } ' ) For an input of 3, this will give the following result: 1 2 3 4 5 6 7 8 9 10 11 Multiplication table for 3 3 X 1 = 3 3 X 2 = 6 3 X 3 = 9 3 X 4 = 12 3 X 5 = 15 3 X 6 = 18 3 X 7 = 21 3 X 8 = 24 3 X 9 = 27 3 X 10 = 30 The \\t is a tab character. It has been added before and after the = . Remove both the tabs and run the code. Do you see any change in the output? Till now we have passed f-strings to the print () function. Nothing stops us from using it to define other string variables: name = input () qual = input () gender = input () if qual == 'phd' : name_respect = f 'Dr. { name } ' elif gender == 'male' : name_respect = f 'Mr. { name } ' elif gender == 'female' : name_respect = f 'Ms. { name } ' print ( f 'Hello, { name_respect } ' ) Try to guess what this code is doing.","title":"f-strings"},{"location":"chapter-3/lesson-3.4/#format","text":"Another way to format strings is using a string method called format () . name = input () print ( 'Hi, {} !' . format ( name )) In the above string, the curly braces will be replaced by the value of the variable name . Another example: l , b = int ( input ()), int ( input ()) print ( 'The length of the rectangle is {} units' . format ( l )) print ( 'The breadth of the rectangle is {} units' . format ( b )) print ( 'The area of the rectangle is {} square units' . format ( l * b )) Let us now print the multiplication table using format () : 1 2 3 x = int ( input ()) for i in range ( 1 , 11 ): print ( ' {} X {} \\t = \\t {} ' . format ( x , i , x * i )) The output will be identical to the one we saw when we used f-strings. Some points to note in line 3 of this code-block. There are three pairs of curly braces. The values that go into these three positions are given as three arguments in the format () function. Starting from the left, the first pair of curly braces in the string is replaced by the first argument in format , the second pair by the second argument and so on. Few more examples: First, consider the following code: 1 2 3 fruit1 = 'apple' fruit2 = 'banana' print ( ' {} and {} are fruits' . format ( fruit1 , fruit2 )) In this code, the mapping is implicit. The first pair of curly braces is mapped to the first argument and so on. This can be made explicit by specifying which argument a particular curly braces will be mapped to: 1 2 3 fruit1 = 'apple' fruit2 = 'banana' print ( ' {0} and {1} are fruits' . format ( fruit1 , fruit2 )) The integer inside the curly braces gives the index of the argument in the format () function. The arguments of the format () function are indexed from 0 and start from the left. Changing the order of arguments will change the output. A third way of writing this as follows: 1 2 3 fruit1 = 'apple' fruit2 = 'banana' print ( ' {string1} and {string2} are fruits' . format ( string1 = fruit1 , string2 = fruit2 )) This method uses the concept of keyword arguments which we will explore in the lessons on functions in the next chapter. Until then, let us put this last method on the back-burner.","title":"format()"},{"location":"chapter-3/lesson-3.4/#format-specifiers","text":"Consider the following code: 1 2 pi_approx = 22 / 7 print ( f 'The value of pi is approximately { pi_approx } ' ) This gives the following output: The value of pi is approximately 3.142857142857143 There are too many numbers after the decimal point. In many real world applications, having two or at most three places after the decimal point is sufficient. In fact, having as many as fifteen numbers after the decimal point only confuses readers. Format specifiers are a way to solve this problem: 1 2 pi_approx = 22 / 7 print ( f 'The value of pi is approximately { pi_approx : .2f } ' ) This gives the following output: The value of pi is approximately 3.14 Let us look at the content inside the curly braces: {pi_approx:.2f} . The first part before the : is the variable. Nothing new here. The part after : is called a format specifier. .2f means the following: . - this signifies the decimal point. 2 - since this comes after the decimal point, it stipulates that there should be exactly two numbers after the decimal point. In other words, the value ( pi_approx ) should be rounded off to two decimal places. f - this signifies that we are dealing with a float value. Let us consider a variant of this code: pi_approx = 22 / 7 print ( f 'The value of pi is approximately { pi_approx : .3f } ' ) This gives the following output: The value of pi is approximately 3.143 Let us now take another example. Let us say we want to print the marks of three students in a class: 1 2 3 4 5 6 roll_1 , marks_1 = 'BSC1001' , 90.5 roll_2 , marks_2 = 'BSC1002' , 100 roll_3 , marks_3 = 'BSC1003' , 90.15 print ( f ' { roll_1 } : { marks_1 } ' ) print ( f ' { roll_2 } : { marks_2 } ' ) print ( f ' { roll_3 } : { marks_3 } ' ) This gives the following output: 1 2 3 BSC1001: 90.5 BSC1002: 100 BSC1003: 90.15 While this is not bad, we would like the marks to be right aligned and have a uniform representation for the marks. The following code helps us achieve this:This is what we wish to see: 1 2 3 4 5 6 roll_1 , marks_1 = 'BSC1001' , 90.5 roll_2 , marks_2 = 'BSC1002' , 100 roll_3 , marks_3 = 'BSC1003' , 90.15 print ( f ' { roll_1 } : { marks_1 : 10.2f } ' ) print ( f ' { roll_2 } : { marks_2 : 10.2f } ' ) print ( f ' { roll_3 } : { marks_3 : 10.2f } ' ) The output of the above code will be: 1 2 3 BSC1001: 90.50 BSC1002: 100.00 BSC1003: 90.15 This is much more neater. The part that might be confusing is the second curly braces in each of the print statements. Let us take a closer look: {marks_1:10.2f} . The part before the : is the variable. The part after the : is 10.2f . Here again, .2f signifies that the float value should be rounded off to two decimal places. The 10 before the decimal point is the minimum width of the column used for printing this value. If the number has fewer than 10 characters (including the decimal point), this will be compensated by adding spaces before the number. For a better understanding of this concept, let us turn to printing integers with a specific formatting. This time, we will use the format () function: 1 2 3 4 5 6 print ( ' {0:5d} ' . format ( 1 )) print ( ' {0:5d} ' . format ( 11 )) print ( ' {0:5d} ' . format ( 111 )) print ( ' {:5d} ' . format ( 1111 )) print ( ' {:5d} ' . format ( 11111 )) print ( ' {:5d} ' . format ( 111111 )) This gives the following output: 1 2 3 4 5 6 1 11 111 1111 11111 111111 Points to note in the code: The d stands for integer. First three print statements have the index of the argument \u2014 0 in this case \u2014 before the : . Last three statements do not have the index of the argument. In fact there is nothing before the : . Both representations are valid. The 5d after the : means that the width of the column used for printing must be at least 5. Lines 1 to 4 have spaces before them as the integer being printed has fewer than five characters.","title":"Format specifiers"},{"location":"chapter-3/lesson-3.5/","text":"Lesson-3.5 Library We will look at two more libraries \u2014 math and random \u2014 and use them to solve some fascinating problems in mathematics. math Consider the following sequence: $$ \\sqrt{2}, \\sqrt{2 + \\sqrt{2}}, \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}},\\ \\dots $$ Mathematically, it is known that this sequence converges or approaches a specific value. In other words, this sequence gets closer and closer to a well defined number as more terms are added. This number is called the limit of the sequence. What is the limit for the above sequence? Can we use whatever we have learned so far to estimate this value? 1 2 3 4 5 import math x = 0 for n in range ( 1 , 6 ): x = math . sqrt ( 2 + x ) print ( f 'n = { n } , x_n = { x : .3f } ' ) If we execute the above code, we get the following output: 1 2 3 4 5 n = 1, x_n = 1.414 n = 2, x_n = 1.848 n = 3, x_n = 1.962 n = 4, x_n = 1.990 n = 5, x_n = 1.998 sqrt () is a function in the math library that returns the square root of the number that is entered as argument. Representing the output shown above as a table: \\(n\\) \\(x_n\\) Approximate value 1 \\(\\sqrt{2}\\) 1.414 2 \\(\\sqrt{2 + \\sqrt{2}}\\) 1.848 3 \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}\\) 1.962 4 \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}}\\) 1.990 5 \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}}}\\) 1.998 Isn't that beautiful? It looks like this sequence \u2014 the train of square roots \u2014 is approaching the value 2. Let us run the loop for more number of iterations this time: 1 2 3 4 5 import math x = 0 for n in range ( 1 , 20 ): x = math . sqrt ( 2 + x ) print ( x ) After just 20 iterations, the value is so close to two: 1.9999999999910236 . But we have used trial and error to decide when to terminate the iteration. A better way to do this is to define a tolerance: if the difference between the previous value and the current value in the sequence is less than some predefined value (tolerance), then we terminate the iteration. 1 2 3 4 5 6 7 8 9 import math x_prev , x_curr = 0 , math . sqrt ( 2 ) tol , count = 0.00001 , 0 while abs ( x_curr - x_prev ) >= tol : x_prev = x_curr x_curr = math . sqrt ( 2 + x_prev ) count += 1 print ( f 'Value of x at { tol } tolerance is { x_curr } ' ) print ( f 'It took { count } iterations' ) random How do we toss a coin using Python? 1 2 import random print ( random . choice ( 'HT' )) That is all there is to it! random is a library and choice () is a function defined in it. It accepts any sequence as input and returns an element chosen at random from this sequence. In this case, the input is a string, which is nothing but a sequence of characters. We know that the probability of obtaining a head on a coin toss is 0.5. This is the theory. Is there a way to see this rule in action? Can we computationally verify if this is indeed the case? For that, we have to set up the following experiment. Toss a coin \\(n\\) times and count the number of heads. Dividing the total number of heads by \\(n\\) will give the empirical probability. As \\(n\\) becomes large, this probability must approach 0.5. import random n = int ( input ()) heads = 0 for i in range ( n ): toss = random . choice ( 'HT' ) if toss == 'H' : heads += 1 print ( f 'P(H) = { heads / n } ' ) Let us run the above code for different values of \\(n\\) and tabulate our results: \\(n\\) \\(P(H)\\) 10 0.2 100 0.52 1,000 0.517 10,000 0.5033 100,000 0.49926 1,000,000 0.499983 The value is approaching 0.5 as expected! random is quite versatile. Exercise Let us now roll a dice! randint(a, b) returns a random integer \\(N\\) such that \\(a \\leq N \\leq b\\) . import random print ( random . randint ( 1 , 6 )) Now find the empirical probability for the numbers on each face of a die using this function.","title":"Lesson-3.5"},{"location":"chapter-3/lesson-3.5/#lesson-35","text":"","title":"Lesson-3.5"},{"location":"chapter-3/lesson-3.5/#library","text":"We will look at two more libraries \u2014 math and random \u2014 and use them to solve some fascinating problems in mathematics.","title":"Library"},{"location":"chapter-3/lesson-3.5/#math","text":"Consider the following sequence: $$ \\sqrt{2}, \\sqrt{2 + \\sqrt{2}}, \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}},\\ \\dots $$ Mathematically, it is known that this sequence converges or approaches a specific value. In other words, this sequence gets closer and closer to a well defined number as more terms are added. This number is called the limit of the sequence. What is the limit for the above sequence? Can we use whatever we have learned so far to estimate this value? 1 2 3 4 5 import math x = 0 for n in range ( 1 , 6 ): x = math . sqrt ( 2 + x ) print ( f 'n = { n } , x_n = { x : .3f } ' ) If we execute the above code, we get the following output: 1 2 3 4 5 n = 1, x_n = 1.414 n = 2, x_n = 1.848 n = 3, x_n = 1.962 n = 4, x_n = 1.990 n = 5, x_n = 1.998 sqrt () is a function in the math library that returns the square root of the number that is entered as argument. Representing the output shown above as a table: \\(n\\) \\(x_n\\) Approximate value 1 \\(\\sqrt{2}\\) 1.414 2 \\(\\sqrt{2 + \\sqrt{2}}\\) 1.848 3 \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}\\) 1.962 4 \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}}\\) 1.990 5 \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}}}\\) 1.998 Isn't that beautiful? It looks like this sequence \u2014 the train of square roots \u2014 is approaching the value 2. Let us run the loop for more number of iterations this time: 1 2 3 4 5 import math x = 0 for n in range ( 1 , 20 ): x = math . sqrt ( 2 + x ) print ( x ) After just 20 iterations, the value is so close to two: 1.9999999999910236 . But we have used trial and error to decide when to terminate the iteration. A better way to do this is to define a tolerance: if the difference between the previous value and the current value in the sequence is less than some predefined value (tolerance), then we terminate the iteration. 1 2 3 4 5 6 7 8 9 import math x_prev , x_curr = 0 , math . sqrt ( 2 ) tol , count = 0.00001 , 0 while abs ( x_curr - x_prev ) >= tol : x_prev = x_curr x_curr = math . sqrt ( 2 + x_prev ) count += 1 print ( f 'Value of x at { tol } tolerance is { x_curr } ' ) print ( f 'It took { count } iterations' )","title":"math"},{"location":"chapter-3/lesson-3.5/#random","text":"How do we toss a coin using Python? 1 2 import random print ( random . choice ( 'HT' )) That is all there is to it! random is a library and choice () is a function defined in it. It accepts any sequence as input and returns an element chosen at random from this sequence. In this case, the input is a string, which is nothing but a sequence of characters. We know that the probability of obtaining a head on a coin toss is 0.5. This is the theory. Is there a way to see this rule in action? Can we computationally verify if this is indeed the case? For that, we have to set up the following experiment. Toss a coin \\(n\\) times and count the number of heads. Dividing the total number of heads by \\(n\\) will give the empirical probability. As \\(n\\) becomes large, this probability must approach 0.5. import random n = int ( input ()) heads = 0 for i in range ( n ): toss = random . choice ( 'HT' ) if toss == 'H' : heads += 1 print ( f 'P(H) = { heads / n } ' ) Let us run the above code for different values of \\(n\\) and tabulate our results: \\(n\\) \\(P(H)\\) 10 0.2 100 0.52 1,000 0.517 10,000 0.5033 100,000 0.49926 1,000,000 0.499983 The value is approaching 0.5 as expected! random is quite versatile. Exercise Let us now roll a dice! randint(a, b) returns a random integer \\(N\\) such that \\(a \\leq N \\leq b\\) . import random print ( random . randint ( 1 , 6 )) Now find the empirical probability for the numbers on each face of a die using this function.","title":"random"},{"location":"chapter-3/lesson-3.6/","text":"Lesson 3.6 Math and Programming Before closing this chapter, let us spend some time at the intersection of mathematics and programming. Limits Consider the following number: \\[ \\sqrt{2} - 1 \\] It is known that \\(1 < \\sqrt{2} < 2\\) . From this, it follows that \\(0 < \\sqrt{2} - 1 < 1\\) . Now, consider the following sequence: \\[ a_n = \\left( \\sqrt{2} - 1 \\right)^n \\] As \\(n\\) becomes very large, the values in this sequence will become smaller and smaller. This is because, if you keep multiplying a fraction with itself, it becomes smaller and smaller. In mathematical terms, the limit of this sequence as \\(n\\) tends to infinity is zero. Let us verify this programmatically: 1 2 3 4 5 6 7 import math n = int ( input ()) # sequence length CONST = math . pow ( 2 , 0.5 ) - 1 # basic term in the sequence a_n = 1 # zeroth term for i in range ( n ): a_n = a_n * CONST # computing the nth term print ( a_n ) Try this out for a few values of \\(n\\) . For \\(n = 100\\) , the value is \\(5.27 \\times 10^{-39}\\) , which is so small that for all practical purposes, it is as good as zero. Recurrence relation Now, here is another fact. For every number \\(n\\) , there are unique integers \\(x\\) and \\(y\\) such that: $$ (\\sqrt{2} - 1)^n = x + y \\cdot \\sqrt{2} $$ For \\(n = 1\\) , this is obvious: \\(x = -1, y = 1\\) . What about higher values of \\(n\\) ? . We can prove this using mathematical induction. The following is a sketch of the inductive proof. If \\((\\sqrt{2} - 1)^n = x_n + y_n \\cdot \\sqrt{2}\\) , then: $$ (\\sqrt{2} - 1)^{n + 1} = (x_n + y_n \\cdot \\sqrt{2}) \\cdot (\\sqrt{2} - 1)\\ = (2y_n - x_n) + (x_n - y_n) \\cdot \\sqrt{2}\\ = x_{n + 1} + y_{n + 1} \\cdot \\sqrt{2} $$ The equation given above defines what is called a recurrence relation: each new term in the sequence is a function of the preceding terms. In this sequence we have \\(x_1 = -1, y_1 = 1\\) . For \\(n > 0\\) , the pair of equations given below forms the recurrence relation: $$ \\begin{align} x_{n + 1} &= 2 y_n - x_n\\ y_{n + 1} &= x_n - y_n \\end{align} $$ Loops are useful tools when it comes to computing terms in such sequences: n = int ( input ()) # sequence length x_n , y_n = - 1 , 1 # x_1 and y_1 for i in range ( n - 1 ): x_n , y_n = 2 * y_n - x_n , x_n - y_n Rational Approximation This in turn provides a way to approximate \\(\\sqrt{2}\\) using rational numbers: $$ \\sqrt{2} \\approx \\frac{-x_n}{y_n} $$ As \\(n\\) becomes large, this approximation will become increasingly accurate. For example, here is an approximation after 100 iterations. It is accurate up to several decimal places! $$ \\frac{228725309250740208744750893347264645481}{161733217200188571081311986634082331709} $$ Is any of this useful? I don't know. But honestly, who cares? We don't do things because they are useful. We do them because they are interesting. And all interesting things will find their use at some point of time in the future.","title":"Lesson 3.6"},{"location":"chapter-3/lesson-3.6/#lesson-36","text":"","title":"Lesson 3.6"},{"location":"chapter-3/lesson-3.6/#math-and-programming","text":"Before closing this chapter, let us spend some time at the intersection of mathematics and programming.","title":"Math and Programming"},{"location":"chapter-3/lesson-3.6/#limits","text":"Consider the following number: \\[ \\sqrt{2} - 1 \\] It is known that \\(1 < \\sqrt{2} < 2\\) . From this, it follows that \\(0 < \\sqrt{2} - 1 < 1\\) . Now, consider the following sequence: \\[ a_n = \\left( \\sqrt{2} - 1 \\right)^n \\] As \\(n\\) becomes very large, the values in this sequence will become smaller and smaller. This is because, if you keep multiplying a fraction with itself, it becomes smaller and smaller. In mathematical terms, the limit of this sequence as \\(n\\) tends to infinity is zero. Let us verify this programmatically: 1 2 3 4 5 6 7 import math n = int ( input ()) # sequence length CONST = math . pow ( 2 , 0.5 ) - 1 # basic term in the sequence a_n = 1 # zeroth term for i in range ( n ): a_n = a_n * CONST # computing the nth term print ( a_n ) Try this out for a few values of \\(n\\) . For \\(n = 100\\) , the value is \\(5.27 \\times 10^{-39}\\) , which is so small that for all practical purposes, it is as good as zero.","title":"Limits"},{"location":"chapter-3/lesson-3.6/#recurrence-relation","text":"Now, here is another fact. For every number \\(n\\) , there are unique integers \\(x\\) and \\(y\\) such that: $$ (\\sqrt{2} - 1)^n = x + y \\cdot \\sqrt{2} $$ For \\(n = 1\\) , this is obvious: \\(x = -1, y = 1\\) . What about higher values of \\(n\\) ? . We can prove this using mathematical induction. The following is a sketch of the inductive proof. If \\((\\sqrt{2} - 1)^n = x_n + y_n \\cdot \\sqrt{2}\\) , then: $$ (\\sqrt{2} - 1)^{n + 1} = (x_n + y_n \\cdot \\sqrt{2}) \\cdot (\\sqrt{2} - 1)\\ = (2y_n - x_n) + (x_n - y_n) \\cdot \\sqrt{2}\\ = x_{n + 1} + y_{n + 1} \\cdot \\sqrt{2} $$ The equation given above defines what is called a recurrence relation: each new term in the sequence is a function of the preceding terms. In this sequence we have \\(x_1 = -1, y_1 = 1\\) . For \\(n > 0\\) , the pair of equations given below forms the recurrence relation: $$ \\begin{align} x_{n + 1} &= 2 y_n - x_n\\ y_{n + 1} &= x_n - y_n \\end{align} $$ Loops are useful tools when it comes to computing terms in such sequences: n = int ( input ()) # sequence length x_n , y_n = - 1 , 1 # x_1 and y_1 for i in range ( n - 1 ): x_n , y_n = 2 * y_n - x_n , x_n - y_n","title":"Recurrence relation"},{"location":"chapter-3/lesson-3.6/#rational-approximation","text":"This in turn provides a way to approximate \\(\\sqrt{2}\\) using rational numbers: $$ \\sqrt{2} \\approx \\frac{-x_n}{y_n} $$ As \\(n\\) becomes large, this approximation will become increasingly accurate. For example, here is an approximation after 100 iterations. It is accurate up to several decimal places! $$ \\frac{228725309250740208744750893347264645481}{161733217200188571081311986634082331709} $$ Is any of this useful? I don't know. But honestly, who cares? We don't do things because they are useful. We do them because they are interesting. And all interesting things will find their use at some point of time in the future.","title":"Rational Approximation"},{"location":"chapter-4/lesson-4.1/","text":"Lesson-4.1 Functions Introduction In mathematics, a function is an object that accepts one or more inputs and produces one or more outputs. For example, \\(f(x) = x^2\\) , is a function that accepts a number and returns the square of that number. Functions in Python play a similar role, but are much more richer than their mathematical counterparts. Let us quickly convert the mathematical function, \\(f(x) = x^2\\) , into a Python function: 1 2 3 def f ( x ): y = x ** 2 return y The code given above is called the definition of function f . def is the keyword used to define functions. f is the name of the function. x is a parameter of the function. Lines 2 and 3 make up the body of the function and are indented. The body of a function is a collection of statements that describe what the function does. At line 3, the value stored in variable y is returned. return is the keyword used for this purpose. If we run the above code, we will not get any output. Functions are not executed unless they are called. The following code demonstrates what a function call looks like: 1 2 3 4 5 def square ( x ): y = x ** 2 return y print ( square ( 2 )) The output is: 4 square ( 2 ) is a function call. We use the name of the function, square , and pass the number 2 as an argument to it. The x in the function definition is called the parameter . The value that is passed to the function in the call is called the argument . This is a convention that we will follow throughout this lesson. A visual representation of the terms we have defined so far is given below: A mental model to understand functions: Parameters can be thought of as the function's inputs. The body of the function can be pictured as the sequence of steps that transform the input into the output. The return statement can be thought of as a means of communicating the output to the rest of the code. Examples We will look at a wide variety of function definitions. The focus will be on the syntactical aspects of function definitions. Functions could have multiple parameters: 1 2 3 4 # This function computes the area of a rectangle. # Length and breadth are the parameters def area ( l , b ): return l * b Functions could have no parameters: 1 2 def foo (): return \"I don't like arguments visiting me!\" Functions could have no return value: 1 2 3 4 def foo (): print ( \"I don't like talking to the outside world!\" ) foo () When the code given above is executed, we get the following output: I don't like talking to the outside world! Note that we didn't have to type print ( foo ()) . We just had to call the function \u2014 foo() \u2014 since it already has the print statement inside it. But what happens if we type print ( foo ()) ? We get the following output: 1 2 I don't like talking to the outside world! None If no explicit return statement is present in a function, None is the default value returned by it. When the interpreter comes across the print ( foo ()) statement, first the function foo() is evaluated. This results in the first line of the output. Since foo() has no explicit return statement, it returns None by default. That is why the second line in the output is None . A minimal Python function looks like the one given below: 1 2 def foo (): pass pass is a keyword in Python. When the interpreter comes across a pass statement, it doesn't perform any computation and moves on to the next line. The reason this is minimal is because it has only those features that are absolutely essential for a function definition to be syntactically valid: function name and at least one statement in the body. Such functions might seem useless at first sight, but they do have their place in programming. While writing a complex piece of code, a coder may realize that they need to define a function to perform a specific task. But they might not know the exact details of the implementation or it may not be an urgent requirement. In such a scenario, they will add a minimal function like the one given above in their code and name it appropriately. Implementing this function will become a task on their to-do list and will be taken up as and when the need arises. Functions could have multiple return statements, but the moment the first return is executed, control exits from the function: 1 2 3 def foo (): return 1 return 2 foo() will always return 1. Line 3 is redundant. An example of a function having multiple returns that are not redundant: 1 2 3 4 5 6 7 8 def evenOrOdd ( n ): if n % 2 == 0 : return 'even' else : return 'odd' print ( evenOrOdd ( 10 )) print ( evenOrOdd ( 11 )) The output is: 1 2 even odd When evenOrOdd is called with an even number as argument, the return statement in line 3 is executed. When the same function is called with an odd number as argument, the return statement in line 5 is executed. Functions could return multiple values: 1 2 3 4 5 6 7 8 9 # Accept only positive floating point numbers def bound ( x ): lower = int ( x ) upper = lower + 1 return lower , upper y = 7.3 l , u = bound ( y ) print ( f ' { l } < { y } < { u } ' ) The exact mechanism of what happens here will become clear when we come to the lesson on tuples. In line 8, the first value returned by bound is stored in l and the second value returned by bound is stored in u . Functions have to be defined before they can be called. The function call cannot come before the definition. For example: 1 2 3 4 5 6 ##### Alarm! Wrong code snippet! ##### print ( f ( 5 )) def f ( x ): return x ** 2 ##### Alarm! Wrong code snippet! ##### When the above code is executed, it throws a NameError . Why does this happen? The Python interpreter executes the code from top to bottom. At line 2, f is a name that the interpreter has never seen before and therefore it throws a NameError . Recall that NameError occurs when we try to reference a name that the interpreter has not seen before. Function calls could be used in expressions: 1 2 3 4 5 6 def square ( a ): return a ** 2 x , y , z = int ( input ()), int ( input ()), int ( input ()) if square ( x ) + square ( y ) == square ( z ): print ( f ' { x } , { y } and { z } form the sides of a right triangle with { z } as the hypotenuse' ) Function calls cannot be assigned values: 1 2 3 4 5 6 ##### Alarm! Wrong code snippet! ##### def foo (): return True foo () = 1 ##### Alarm! Wrong code snippet! ##### The above code throws a SyntaxError . Functions can be called from within other functions: 1 2 3 4 5 6 7 8 9 10 11 def foo (): print ( 'I am inside foo' ) def bar (): print ( 'I am inside bar' ) print ( 'I am going to call foo' ) foo () print ( 'I am outside both foo and bar' ) bar () print ( 'I am outside both foo and bar' ) Functions can be defined inside other functions: 1 2 3 4 5 6 def foo (): def bar (): print ( 'bar is inside foo' ) bar () foo () Try calling bar() outside foo() . What do you observe? Docstrings Consider the following function: 1 2 3 def square ( x ): \"\"\"Return the square of x.\"\"\" return x ** 2 The string immediately below the function definition is called a docstring. From the Python docs : A docstring is a string literal that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the __doc__ special attribute of that object. Ignore unfamiliar terms such as \"module\" and \"class\". For now, it is sufficient to focus on functions. Adding the docstring to functions is a good practice. It may not be needed for simple and obvious functions like the one defined above. As the complexity of the functions you write increases, docstrings can be a life safer for other programmers reading your code. The docstring associated with a given function can be accessed using the __doc__ attribute: print ( square . __doc__ ) This gives Return the square of x. as output.","title":"Lesson-4.1"},{"location":"chapter-4/lesson-4.1/#lesson-41","text":"","title":"Lesson-4.1"},{"location":"chapter-4/lesson-4.1/#functions","text":"","title":"Functions"},{"location":"chapter-4/lesson-4.1/#introduction","text":"In mathematics, a function is an object that accepts one or more inputs and produces one or more outputs. For example, \\(f(x) = x^2\\) , is a function that accepts a number and returns the square of that number. Functions in Python play a similar role, but are much more richer than their mathematical counterparts. Let us quickly convert the mathematical function, \\(f(x) = x^2\\) , into a Python function: 1 2 3 def f ( x ): y = x ** 2 return y The code given above is called the definition of function f . def is the keyword used to define functions. f is the name of the function. x is a parameter of the function. Lines 2 and 3 make up the body of the function and are indented. The body of a function is a collection of statements that describe what the function does. At line 3, the value stored in variable y is returned. return is the keyword used for this purpose. If we run the above code, we will not get any output. Functions are not executed unless they are called. The following code demonstrates what a function call looks like: 1 2 3 4 5 def square ( x ): y = x ** 2 return y print ( square ( 2 )) The output is: 4 square ( 2 ) is a function call. We use the name of the function, square , and pass the number 2 as an argument to it. The x in the function definition is called the parameter . The value that is passed to the function in the call is called the argument . This is a convention that we will follow throughout this lesson. A visual representation of the terms we have defined so far is given below: A mental model to understand functions: Parameters can be thought of as the function's inputs. The body of the function can be pictured as the sequence of steps that transform the input into the output. The return statement can be thought of as a means of communicating the output to the rest of the code.","title":"Introduction"},{"location":"chapter-4/lesson-4.1/#examples","text":"We will look at a wide variety of function definitions. The focus will be on the syntactical aspects of function definitions. Functions could have multiple parameters: 1 2 3 4 # This function computes the area of a rectangle. # Length and breadth are the parameters def area ( l , b ): return l * b Functions could have no parameters: 1 2 def foo (): return \"I don't like arguments visiting me!\" Functions could have no return value: 1 2 3 4 def foo (): print ( \"I don't like talking to the outside world!\" ) foo () When the code given above is executed, we get the following output: I don't like talking to the outside world! Note that we didn't have to type print ( foo ()) . We just had to call the function \u2014 foo() \u2014 since it already has the print statement inside it. But what happens if we type print ( foo ()) ? We get the following output: 1 2 I don't like talking to the outside world! None If no explicit return statement is present in a function, None is the default value returned by it. When the interpreter comes across the print ( foo ()) statement, first the function foo() is evaluated. This results in the first line of the output. Since foo() has no explicit return statement, it returns None by default. That is why the second line in the output is None . A minimal Python function looks like the one given below: 1 2 def foo (): pass pass is a keyword in Python. When the interpreter comes across a pass statement, it doesn't perform any computation and moves on to the next line. The reason this is minimal is because it has only those features that are absolutely essential for a function definition to be syntactically valid: function name and at least one statement in the body. Such functions might seem useless at first sight, but they do have their place in programming. While writing a complex piece of code, a coder may realize that they need to define a function to perform a specific task. But they might not know the exact details of the implementation or it may not be an urgent requirement. In such a scenario, they will add a minimal function like the one given above in their code and name it appropriately. Implementing this function will become a task on their to-do list and will be taken up as and when the need arises. Functions could have multiple return statements, but the moment the first return is executed, control exits from the function: 1 2 3 def foo (): return 1 return 2 foo() will always return 1. Line 3 is redundant. An example of a function having multiple returns that are not redundant: 1 2 3 4 5 6 7 8 def evenOrOdd ( n ): if n % 2 == 0 : return 'even' else : return 'odd' print ( evenOrOdd ( 10 )) print ( evenOrOdd ( 11 )) The output is: 1 2 even odd When evenOrOdd is called with an even number as argument, the return statement in line 3 is executed. When the same function is called with an odd number as argument, the return statement in line 5 is executed. Functions could return multiple values: 1 2 3 4 5 6 7 8 9 # Accept only positive floating point numbers def bound ( x ): lower = int ( x ) upper = lower + 1 return lower , upper y = 7.3 l , u = bound ( y ) print ( f ' { l } < { y } < { u } ' ) The exact mechanism of what happens here will become clear when we come to the lesson on tuples. In line 8, the first value returned by bound is stored in l and the second value returned by bound is stored in u . Functions have to be defined before they can be called. The function call cannot come before the definition. For example: 1 2 3 4 5 6 ##### Alarm! Wrong code snippet! ##### print ( f ( 5 )) def f ( x ): return x ** 2 ##### Alarm! Wrong code snippet! ##### When the above code is executed, it throws a NameError . Why does this happen? The Python interpreter executes the code from top to bottom. At line 2, f is a name that the interpreter has never seen before and therefore it throws a NameError . Recall that NameError occurs when we try to reference a name that the interpreter has not seen before. Function calls could be used in expressions: 1 2 3 4 5 6 def square ( a ): return a ** 2 x , y , z = int ( input ()), int ( input ()), int ( input ()) if square ( x ) + square ( y ) == square ( z ): print ( f ' { x } , { y } and { z } form the sides of a right triangle with { z } as the hypotenuse' ) Function calls cannot be assigned values: 1 2 3 4 5 6 ##### Alarm! Wrong code snippet! ##### def foo (): return True foo () = 1 ##### Alarm! Wrong code snippet! ##### The above code throws a SyntaxError . Functions can be called from within other functions: 1 2 3 4 5 6 7 8 9 10 11 def foo (): print ( 'I am inside foo' ) def bar (): print ( 'I am inside bar' ) print ( 'I am going to call foo' ) foo () print ( 'I am outside both foo and bar' ) bar () print ( 'I am outside both foo and bar' ) Functions can be defined inside other functions: 1 2 3 4 5 6 def foo (): def bar (): print ( 'bar is inside foo' ) bar () foo () Try calling bar() outside foo() . What do you observe?","title":"Examples"},{"location":"chapter-4/lesson-4.1/#docstrings","text":"Consider the following function: 1 2 3 def square ( x ): \"\"\"Return the square of x.\"\"\" return x ** 2 The string immediately below the function definition is called a docstring. From the Python docs : A docstring is a string literal that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the __doc__ special attribute of that object. Ignore unfamiliar terms such as \"module\" and \"class\". For now, it is sufficient to focus on functions. Adding the docstring to functions is a good practice. It may not be needed for simple and obvious functions like the one defined above. As the complexity of the functions you write increases, docstrings can be a life safer for other programmers reading your code. The docstring associated with a given function can be accessed using the __doc__ attribute: print ( square . __doc__ ) This gives Return the square of x. as output.","title":"Docstrings"},{"location":"chapter-4/lesson-4.2/","text":"Lesson-4.2 Arguments Python offers a number of options in terms of the way arguments can be passed to functions. Positional arguments All functions that we have seen so far have used positional arguments. Here, the position of an argument in the function call determines the parameter to which it is passed. Let us take the following problem: Write a function that accepts three positive integers x , y and z . Return True if the three integers form the sides of a right triangle with x and y as its legs and z as the hypotenuse, and False otherwise. Solution 1 2 3 4 5 6 7 def isRight ( x , y , z ): if x ** 2 + y ** 2 == z ** 2 : return True return False print ( isRight ( 3 , 4 , 5 )) # 3 is passed to x, 4 is passed to y, 5 is passed to z print ( isRight ( 5 , 4 , 3 )) # 5 is passed to x, 4 is passed to y, 3 is passed to z The output is: 1 2 True False Arguments are passed to the parameters of the function based on the position they occupy in the function call. Look at the comments in the above code to get a clear picture. Positional arguments are also called required arguments, i.e., they cannot be left out. Likewise, adding more arguments than there are parameters will throw an error. When positional arguments are involved, there should be exactly as many arguments in the function call as there are parameters in the function definition. Try to execute the following code and study the error message: 1 2 3 4 ##### Alarm! Wrong code snippet! isRight ( 3 , 4 ) isRight ( 3 , 4 , 5 , 6 ) ##### Alarm! Wrong code snippet! Keyword arguments Keyword arguments introduce more flexibility while passing arguments. Let us take up the same problem that we saw in the previous section and just modify the function calls: 1 2 3 # The following is just a function call. # We are not printing anything here. isRight ( x = 3 , y = 4 , z = 5 ) The function call in line 3 uses what are known as keyword arguments. In this method, the names of the parameters are explicitly specified and the arguments are assigned to it using the = operator. This is different from positional arguments where the position of the argument in the function call determines the parameter to which it is bound. One advantage of using keyword arguments is that it reduces the possibility of entering the arguments in an incorrect order. For example: 1 2 3 4 isRight ( 3 , 4 , 5 ) # intended call isRight ( 5 , 4 , 3 ) # actuall call isRight ( x = 3 , y = 4 , z = 5 ) # same as intended call isRight ( z = 5 , y = 4 , x = 3 ) # same as intended call Keyword arguments and positional arguments can be combined in a single call: isRight ( 3 , y = 4 , z = 5 ) Now try this out: 1 2 3 #### Alarm! Wrong code snippet! #### isRight ( x = 3 , 4 , 5 ) #### Alarm! Wrong code snippet! #### The interpreter throws a TypeError with the following message: positional argument follows keyword arguments . That is, in our function call, the positional arguments \u2014 4 and 5 \u2014 come after the keyword argument x = 3 . Why does the interpreter objects to this? Whenever both positional and keyword arguments are present in a function call, the keyword arguments must always come at the end. This is quite reasonable: positional arguments are extremely sensitive to position, so it is best to have them at the beginning. How about the following call? 1 2 3 #### Alarm! Wrong code snippet! #### isRight ( 3 , x = 3 , y = 4 , z = 5 ) #### Alarm! Wrong code snippet! #### The interpreter objects by throwing a TypeError with the following message: isRight() got multiple values for argument x . Objection granted! Another reasonable requirement from the Python interpreter: there must be exactly one argument in the function call for each parameter in the function definition, nothing more, nothing less. This could be a positional argument or a default argument, but not both. Default arguments Consider the following scenario. The image that you see here is a map of your neighborhood. The grid lines are roads that can be used by cars. You wish to reach the point \\(P\\) from \\(O\\) . There are no restrictions if you are on foot. The easiest way is to move along the line \\(OP\\) . This is called the Euclidean distance between points \\(O\\) and \\(P\\) . If you are in a car, then you are forced to move along the grid lines. The distance you would have to cover in a car is \\(OM + MP\\) . This distance is called the Manhattan distance between points \\(O\\) and \\(P\\) . Let us say that a self-driving car startup operating in your neighborhood uses both these metrics while computing distances. Assume that its code base invokes the Euclidean distance 10 times and the Manhattan distance 1000 times. Since these metrics are used repeatedly, it is a good idea to represent them as functions in the code base: # Assume that O is the origin # All distances are computed from the origin def euclidean ( x , y ): return pow ( x ** 2 + y ** 2 , 0.5 ) def manhattan ( x , y ): return abs ( x ) + abs ( y ) While the above code is fine, it ignores the fact that the Manhattan distance is being used hundred times more frequently compared to the Euclidean distance. Default arguments can come in handy in such situations: def distance ( x , y , metric = 'manhattan' ): if metric == 'manhattan' : return abs ( x ) + abs ( y ) elif metric == 'euclidean' : return pow ( x ** 2 + y ** 2 , 0.5 ) The parameter metric has 'manhattan' as the default value. Let us try calling the function without passing any argument to the metric parameter: print ( distance ( 3 , 4 )) This gives 7 as the output. Since no value was provided in the function call, the default value of 'manhattan' was assigned to the metric parameter. In the code base, wherever the Manhattan distance is invoked, we can just replace it with the function call distance(x, y) . The following points are important to keep in mind: Parameters that are assigned a value in the function definition are called default parameters. Default parameters always come at the end of the parameter list in a function definition. The argument corresponding to a default parameter is optional in a function call. An argument corresponding to a default parameter can be passed as a positional argument or as a keyword argument. Let us illustrate some of these points: 1 2 3 4 5 6 7 #### Alarm! Wrong code snippet! #### def distance ( metric = 'manhattan' , x , y ): if metric == 'manhattan' : return abs ( x ) + abs ( y ) elif metric == 'euclidean' : return pow ( x ** 2 + y ** 2 , 0.5 ) #### Alarm! Wrong code snippet! #### The above code throws a SyntaxError with the following message: non-default argument follows default argument . In the function definition, the default parameter must always come at the end of the list of parameters. Now, for different ways of passing arguments in the presence of default parameters: distance ( 3 , 4 ) distance ( 3 , 4 , 'manhattan' ) distance ( 3 , 4 , metric = 'manhattan' ) All three function calls are equivalent. The first one uses default value of metric . The second call explicitly passes 'manhattan' as the metric using a positional argument. The last call explicitly passes 'manhattan' as a keyword argument. Call by value Consider the following code: 1 2 3 4 5 6 7 8 def double ( x ): x = x * 2 return x a = 4 print ( f 'before function call, a = { a } ' ) double ( a ) print ( f 'after function call, a = { a } ' ) The output is: before function call, a = 4 after function call, a = 4 We see that the value of a is not disturbed by the function in any way. When the function call double(a) is invoked, the value in a is assigned to the parameter x in the function. Arguments are passed by assignment in Python, which means that something like x = a happens when double(a) is invoked. This kind of a function call where the value in a variable is passed as argument to the function is called call by value . Consider the following code: 1 2 3 4 5 def square ( x ): return x * x x = 10 x_squared = square ( x ) We are using the same name for both the parameter of the function square and the argument passed to it. This is a bad practice. It is always preferable to differentiate the names of the parameters from the names of the arguments that are passed in the function call. This avoids confusion and makes code more readable. At this stage, you might be wondering how the variable x inside the function is related to the variable x outside it. This issue will be taken up in the next lesson on scopes. The above code could be rewritten as follows: 1 2 3 4 5 def square ( num ): return num * num x = 10 x_squared = square ( x )","title":"Lesson-4.2"},{"location":"chapter-4/lesson-4.2/#lesson-42","text":"","title":"Lesson-4.2"},{"location":"chapter-4/lesson-4.2/#arguments","text":"Python offers a number of options in terms of the way arguments can be passed to functions.","title":"Arguments"},{"location":"chapter-4/lesson-4.2/#positional-arguments","text":"All functions that we have seen so far have used positional arguments. Here, the position of an argument in the function call determines the parameter to which it is passed. Let us take the following problem: Write a function that accepts three positive integers x , y and z . Return True if the three integers form the sides of a right triangle with x and y as its legs and z as the hypotenuse, and False otherwise. Solution 1 2 3 4 5 6 7 def isRight ( x , y , z ): if x ** 2 + y ** 2 == z ** 2 : return True return False print ( isRight ( 3 , 4 , 5 )) # 3 is passed to x, 4 is passed to y, 5 is passed to z print ( isRight ( 5 , 4 , 3 )) # 5 is passed to x, 4 is passed to y, 3 is passed to z The output is: 1 2 True False Arguments are passed to the parameters of the function based on the position they occupy in the function call. Look at the comments in the above code to get a clear picture. Positional arguments are also called required arguments, i.e., they cannot be left out. Likewise, adding more arguments than there are parameters will throw an error. When positional arguments are involved, there should be exactly as many arguments in the function call as there are parameters in the function definition. Try to execute the following code and study the error message: 1 2 3 4 ##### Alarm! Wrong code snippet! isRight ( 3 , 4 ) isRight ( 3 , 4 , 5 , 6 ) ##### Alarm! Wrong code snippet!","title":"Positional arguments"},{"location":"chapter-4/lesson-4.2/#keyword-arguments","text":"Keyword arguments introduce more flexibility while passing arguments. Let us take up the same problem that we saw in the previous section and just modify the function calls: 1 2 3 # The following is just a function call. # We are not printing anything here. isRight ( x = 3 , y = 4 , z = 5 ) The function call in line 3 uses what are known as keyword arguments. In this method, the names of the parameters are explicitly specified and the arguments are assigned to it using the = operator. This is different from positional arguments where the position of the argument in the function call determines the parameter to which it is bound. One advantage of using keyword arguments is that it reduces the possibility of entering the arguments in an incorrect order. For example: 1 2 3 4 isRight ( 3 , 4 , 5 ) # intended call isRight ( 5 , 4 , 3 ) # actuall call isRight ( x = 3 , y = 4 , z = 5 ) # same as intended call isRight ( z = 5 , y = 4 , x = 3 ) # same as intended call Keyword arguments and positional arguments can be combined in a single call: isRight ( 3 , y = 4 , z = 5 ) Now try this out: 1 2 3 #### Alarm! Wrong code snippet! #### isRight ( x = 3 , 4 , 5 ) #### Alarm! Wrong code snippet! #### The interpreter throws a TypeError with the following message: positional argument follows keyword arguments . That is, in our function call, the positional arguments \u2014 4 and 5 \u2014 come after the keyword argument x = 3 . Why does the interpreter objects to this? Whenever both positional and keyword arguments are present in a function call, the keyword arguments must always come at the end. This is quite reasonable: positional arguments are extremely sensitive to position, so it is best to have them at the beginning. How about the following call? 1 2 3 #### Alarm! Wrong code snippet! #### isRight ( 3 , x = 3 , y = 4 , z = 5 ) #### Alarm! Wrong code snippet! #### The interpreter objects by throwing a TypeError with the following message: isRight() got multiple values for argument x . Objection granted! Another reasonable requirement from the Python interpreter: there must be exactly one argument in the function call for each parameter in the function definition, nothing more, nothing less. This could be a positional argument or a default argument, but not both.","title":"Keyword arguments"},{"location":"chapter-4/lesson-4.2/#default-arguments","text":"Consider the following scenario. The image that you see here is a map of your neighborhood. The grid lines are roads that can be used by cars. You wish to reach the point \\(P\\) from \\(O\\) . There are no restrictions if you are on foot. The easiest way is to move along the line \\(OP\\) . This is called the Euclidean distance between points \\(O\\) and \\(P\\) . If you are in a car, then you are forced to move along the grid lines. The distance you would have to cover in a car is \\(OM + MP\\) . This distance is called the Manhattan distance between points \\(O\\) and \\(P\\) . Let us say that a self-driving car startup operating in your neighborhood uses both these metrics while computing distances. Assume that its code base invokes the Euclidean distance 10 times and the Manhattan distance 1000 times. Since these metrics are used repeatedly, it is a good idea to represent them as functions in the code base: # Assume that O is the origin # All distances are computed from the origin def euclidean ( x , y ): return pow ( x ** 2 + y ** 2 , 0.5 ) def manhattan ( x , y ): return abs ( x ) + abs ( y ) While the above code is fine, it ignores the fact that the Manhattan distance is being used hundred times more frequently compared to the Euclidean distance. Default arguments can come in handy in such situations: def distance ( x , y , metric = 'manhattan' ): if metric == 'manhattan' : return abs ( x ) + abs ( y ) elif metric == 'euclidean' : return pow ( x ** 2 + y ** 2 , 0.5 ) The parameter metric has 'manhattan' as the default value. Let us try calling the function without passing any argument to the metric parameter: print ( distance ( 3 , 4 )) This gives 7 as the output. Since no value was provided in the function call, the default value of 'manhattan' was assigned to the metric parameter. In the code base, wherever the Manhattan distance is invoked, we can just replace it with the function call distance(x, y) . The following points are important to keep in mind: Parameters that are assigned a value in the function definition are called default parameters. Default parameters always come at the end of the parameter list in a function definition. The argument corresponding to a default parameter is optional in a function call. An argument corresponding to a default parameter can be passed as a positional argument or as a keyword argument. Let us illustrate some of these points: 1 2 3 4 5 6 7 #### Alarm! Wrong code snippet! #### def distance ( metric = 'manhattan' , x , y ): if metric == 'manhattan' : return abs ( x ) + abs ( y ) elif metric == 'euclidean' : return pow ( x ** 2 + y ** 2 , 0.5 ) #### Alarm! Wrong code snippet! #### The above code throws a SyntaxError with the following message: non-default argument follows default argument . In the function definition, the default parameter must always come at the end of the list of parameters. Now, for different ways of passing arguments in the presence of default parameters: distance ( 3 , 4 ) distance ( 3 , 4 , 'manhattan' ) distance ( 3 , 4 , metric = 'manhattan' ) All three function calls are equivalent. The first one uses default value of metric . The second call explicitly passes 'manhattan' as the metric using a positional argument. The last call explicitly passes 'manhattan' as a keyword argument.","title":"Default arguments"},{"location":"chapter-4/lesson-4.2/#call-by-value","text":"Consider the following code: 1 2 3 4 5 6 7 8 def double ( x ): x = x * 2 return x a = 4 print ( f 'before function call, a = { a } ' ) double ( a ) print ( f 'after function call, a = { a } ' ) The output is: before function call, a = 4 after function call, a = 4 We see that the value of a is not disturbed by the function in any way. When the function call double(a) is invoked, the value in a is assigned to the parameter x in the function. Arguments are passed by assignment in Python, which means that something like x = a happens when double(a) is invoked. This kind of a function call where the value in a variable is passed as argument to the function is called call by value . Consider the following code: 1 2 3 4 5 def square ( x ): return x * x x = 10 x_squared = square ( x ) We are using the same name for both the parameter of the function square and the argument passed to it. This is a bad practice. It is always preferable to differentiate the names of the parameters from the names of the arguments that are passed in the function call. This avoids confusion and makes code more readable. At this stage, you might be wondering how the variable x inside the function is related to the variable x outside it. This issue will be taken up in the next lesson on scopes. The above code could be rewritten as follows: 1 2 3 4 5 def square ( num ): return num * num x = 10 x_squared = square ( x )","title":"Call by value"},{"location":"chapter-4/lesson-4.3/","text":"Lesson-4.3 Scope Consider the following code: def foo (): x = 1 print ( 'This is a veritable fortress. None can enter here.' ) print ( ' \\N{smirking face} ' ) foo () print ( x ) This will give the following output: This is a veritable fortress. None can enter here. \ud83d\ude0f Traceback (most recent call last): File \"main.py\", line 7, in <module> print(x) NameError: name 'x' is not defined Why did the interpreter throw an an error in line-7? It tried to look for the name x and was unable to find it. But isn't x present in the function foo ? Is the interpreter careless or are we missing something? The interpreter is never wrong! The region in the code where a name can be referenced is called its scope. If we try to reference a variable outside its scope, the interpreter will throw a NameError . Local vs Global In the above example, the scope of the name x is local to the function; x has a meaningful existence only inside the function and any attempt to access it from outside the function is going to result in an error. Think about functions as black holes: they don't let variables (light) escape the function's definition (event-horizon)! Let us take another example: y = 10 def foo (): x = 1 print ( 'I can access both x and y' ) print ( f 'x = { x } , y = { y } ' ) foo () The name y is accessible from within the function as well. We say that the scope of y is global . That is, it can be referenced from anywhere within the program \u2014 even inside a function \u2014 after it has been defined for the first time. There is a slight catch here: if another variable with the same name is defined within the function, then things change. We will take up this case later. At this stage, we are ready to formulate the rules for local and global variables [ refer ]: Local : Whenever a variable is assigned a value anywhere within a function, its scope becomes local to that function. In other words, whenever a variable appears on the left side of an assignment statement anywhere within a function, it becomes a local variable. Global : If a variable is only referenced inside a function and is never assigned a value inside it, it is implicitly treated as a global variable. The scope of the parameters in the function definition are local. The following code will throw a NameError when executed: def double ( x ): x = x * 2 return x double ( 2 ) print ( x ) Examples Let us now look at few more examples that bring out some fine points regarding local and global scope: ### Variant-1 def foo (): x = 1 print ( 'I can access both x and y' ) print ( f 'x = { x } , y = { y } ' ) y = 10 foo () Notice the difference between this code and the one at the beginning of the earlier section. Here, the variable y is defined after the function definition, while in the earlier version y was defined before the function definition. But both versions give the same output. All that matters is for y to be defined before the function call. What happens if y is defined after foo is called? ### Variant-2 def foo (): x = 1 print ( 'I can access both x and y' ) print ( f 'x = { x } , y = { y } ' ) foo () y = 10 This throws a NameError at line-5, which is reasonable as y is not defined in the main program before foo is called. The scope of y is still global; it can be referenced anywhere in the program once it has been defined. Now, let us crank up the difficulty level: def foo (): x = 10 print ( f 'x inside foo = { x } ' ) x = 100 foo () print ( f 'x outside foo = { x } ' ) We have the same name \u2014 x \u2014 appearing inside the function and outside the function. Are they the same or different? Let us check the output: x inside foo = 10 x outside foo = 100 They are different! The x inside foo is different from the x outside foo . The scope of the name x inside foo is local; it is a local variable. This is because of the first rule: a variable that is assigned a value inside the function becomes a local variable. Since x is assigned a value in line-2, it becomes a local variable. The scope of the x outside foo is global. Though there is another x inside the function foo , that cannot be accessed outside the function. This may start to get a little confusing. How does Python internally manage local and global variables? For this, we will briefly turn to the concept of namespaces. This will give a different perspective to the problem of name resolution. Namespaces Consider the following snippet of code: x = 1.0 avar = 'cool' def foo (): pass We have used three different names here: x , avar and foo . The first two names represent variables that store literals. The last name represents a function. How does the Python interpreter internally process these names? It uses a concept called namespaces. A namespace can be thought of as a lookup table \u2014 dictionary to be precise \u2014 that maps names to objects. globals() There are different types of namespaces. The variables that we define in the main program are represented in the globals namespace. For example: x = 1.0 avar = 'cool' def foo (): y = 2.0 foo () print ( globals ()) This returns the following output: Ignore all the other details and just focus on the region highlighted in yellow. Notice that the names x , avar and foo are present in the namespace. x and avar are mapped to the objects 1 and cool respectively, while foo is mapped to some complex looking object: <function foo at 0x7f8ecd2aa1f0> . The number 0x7f8ecd2aa1f0 is the location in the memory where the function's definition is stored [ refer ]. There is another way to check whether a given name is in a namespace: print ( 'x' in globals ()) print ( 'avar' in globals ()) print ( 'foo' in globals ()) All three lines result in True . locals() Notice something interesting in the previous code, the name y is not found in the globals namespace! We can verify this as follows: print ( 'y' in globals ()) This results in False . Variables that are assigned a value inside a function are local to the function and cannot be accessed outside it. How does the Python interpreter handle names inside functions? It creates a separate namespace every time a function is called. This is called a local namespace. Now, consider the following code: def foo (): y = 2.0 print ( 'Is y in locals?' , 'y' in locals ()) foo () print ( 'Is y in globals?' , 'y' in globals ()) It returns the following output: Is y in locals? True Is y in globals? False Scope and Namespaces For every function call, the interpreter creates a local namespace that contains all names and their corresponding objects that are defined in the function. Let us take an example: def foo (): print ( y ) print ( locals ()) x = 1 print ( locals ()) y = 10 foo () This gives the output: 10 {} {'x': 1} Since y is only being referenced inside foo , it doesn't become a part of the local namespace. It remains a global variable. Since x is being assigned a value inside foo , it is a local variable and therefore enters the local namespace. The moment control exits the function, the namespace corresponding to it is deleted. Whenever the interpreter comes across a name in a function it sticks to the following protocol: First peep into the local namespace created for that function call to see if the name is present in it. If it is present, then go ahead and use the value that this variable points to in the local namespace. If it is not present, then look at the global namespace. If it is present in the global namespace, then use the value corresponding to this name. If it is not present in the global namespace, then look into the built-in namespace. We will come back to the built-in namespace right at the end. If it is not present in any of these namespaces, then raise a NameError . The following image captures this idea. The built-in namespace has been ignored for now. Refer to the last section to get the complete image. With this context, let us revisit the problem that we looked at the end of the first section: def foo (): x = 10 print ( f 'x inside foo = { x } ' ) x = 100 foo () print ( f 'x outside foo = { x } ' ) When the function is called at line-6, the interpreter creates a local namespace for foo . At line-2, x becomes a part of this namespace. When x is referenced at line-3, the interpreter first looks at the local namespace for foo . Since x is present there, it is going to use the value corresponding to it - in this case 10 . Once control exits the function, the local namespace corresponding to it is deleted. At line-7, the interpreter will replace the name x with the value 100 which is present in the global namespace. global keyword Let us revisit the scope rules: Local : Whenever a variable is assigned a value anywhere within a function, its scope becomes local to that function. In other words, whenever a variable appears on the left side of an assignment statement anywhere within a function, it becomes a local variable. Global : If a variable is only referenced inside a function and is never assigned a value inside it, it is implicitly treated as a global variable. Consider the following code: def foo (): print ( x ) x = x + 1 x = 10 foo () When the above code is executed, we get the following error: UnboundLocalError: local variable 'x' referenced before assignment [ refer ]. This code violates the first rule. x is being assigned a value in line-3 of the function; hence it becomes a local variable. At line-2 we are trying to reference a value that is yet to be defined. Note that the assignment statement in line-5 doesn't count as the x there is not local to foo , but is a global variable. But what if we want to reuse the global variable x inside the function foo ? Python provides a keyword called global for this purpose: def foo (): global x print ( f 'x inside foo = { x } ' ) x = x + 1 print ( f 'x inside foo = { x } ' ) x = 10 print ( f 'x outside foo = { x } ' ) foo () The output is: x outside foo = 10 x inside foo = 10 x inside foo = 11 By declaring x to be global inside foo , a new local variable x is not created even though it appears to the left of an assignment statement in line-4. Built-ins So far we have been freely using built-in functions like print , int , input and so on. At some level, these are also names in Python and these also get resolved during run-time. There is a separate namespace called builtins where these functions are defined. Consider the following code: ##### Never do something like this! ##### print = 1 ##### Never do something like this! ##### If the above code is executed, we don't get an error! This is somewhat surprising. But syntactically, there is nothing wrong here. But we will get into serious problems when we try to do the following: ##### Alarm! Wrong code snippet! ##### print = 1 print ( 1 ) ##### Alarm! Wrong code snippet! ##### This will throw a TypeError . The name print has been hijacked and is being used as an int variable. How does Python allow this to happen? When resolving names, the built-in namespace is the last stage in the interpreter's journey. Syntactically, nothing prevents us from using the name of a built-in function, such as print , as the name of a variable. But this is a very bad practice that should be avoided at any cost!","title":"Lesson-4.3"},{"location":"chapter-4/lesson-4.3/#lesson-43","text":"","title":"Lesson-4.3"},{"location":"chapter-4/lesson-4.3/#scope","text":"Consider the following code: def foo (): x = 1 print ( 'This is a veritable fortress. None can enter here.' ) print ( ' \\N{smirking face} ' ) foo () print ( x ) This will give the following output: This is a veritable fortress. None can enter here. \ud83d\ude0f Traceback (most recent call last): File \"main.py\", line 7, in <module> print(x) NameError: name 'x' is not defined Why did the interpreter throw an an error in line-7? It tried to look for the name x and was unable to find it. But isn't x present in the function foo ? Is the interpreter careless or are we missing something? The interpreter is never wrong! The region in the code where a name can be referenced is called its scope. If we try to reference a variable outside its scope, the interpreter will throw a NameError .","title":"Scope"},{"location":"chapter-4/lesson-4.3/#local-vs-global","text":"In the above example, the scope of the name x is local to the function; x has a meaningful existence only inside the function and any attempt to access it from outside the function is going to result in an error. Think about functions as black holes: they don't let variables (light) escape the function's definition (event-horizon)! Let us take another example: y = 10 def foo (): x = 1 print ( 'I can access both x and y' ) print ( f 'x = { x } , y = { y } ' ) foo () The name y is accessible from within the function as well. We say that the scope of y is global . That is, it can be referenced from anywhere within the program \u2014 even inside a function \u2014 after it has been defined for the first time. There is a slight catch here: if another variable with the same name is defined within the function, then things change. We will take up this case later. At this stage, we are ready to formulate the rules for local and global variables [ refer ]: Local : Whenever a variable is assigned a value anywhere within a function, its scope becomes local to that function. In other words, whenever a variable appears on the left side of an assignment statement anywhere within a function, it becomes a local variable. Global : If a variable is only referenced inside a function and is never assigned a value inside it, it is implicitly treated as a global variable. The scope of the parameters in the function definition are local. The following code will throw a NameError when executed: def double ( x ): x = x * 2 return x double ( 2 ) print ( x )","title":"Local vs Global"},{"location":"chapter-4/lesson-4.3/#examples","text":"Let us now look at few more examples that bring out some fine points regarding local and global scope: ### Variant-1 def foo (): x = 1 print ( 'I can access both x and y' ) print ( f 'x = { x } , y = { y } ' ) y = 10 foo () Notice the difference between this code and the one at the beginning of the earlier section. Here, the variable y is defined after the function definition, while in the earlier version y was defined before the function definition. But both versions give the same output. All that matters is for y to be defined before the function call. What happens if y is defined after foo is called? ### Variant-2 def foo (): x = 1 print ( 'I can access both x and y' ) print ( f 'x = { x } , y = { y } ' ) foo () y = 10 This throws a NameError at line-5, which is reasonable as y is not defined in the main program before foo is called. The scope of y is still global; it can be referenced anywhere in the program once it has been defined. Now, let us crank up the difficulty level: def foo (): x = 10 print ( f 'x inside foo = { x } ' ) x = 100 foo () print ( f 'x outside foo = { x } ' ) We have the same name \u2014 x \u2014 appearing inside the function and outside the function. Are they the same or different? Let us check the output: x inside foo = 10 x outside foo = 100 They are different! The x inside foo is different from the x outside foo . The scope of the name x inside foo is local; it is a local variable. This is because of the first rule: a variable that is assigned a value inside the function becomes a local variable. Since x is assigned a value in line-2, it becomes a local variable. The scope of the x outside foo is global. Though there is another x inside the function foo , that cannot be accessed outside the function. This may start to get a little confusing. How does Python internally manage local and global variables? For this, we will briefly turn to the concept of namespaces. This will give a different perspective to the problem of name resolution.","title":"Examples"},{"location":"chapter-4/lesson-4.3/#namespaces","text":"Consider the following snippet of code: x = 1.0 avar = 'cool' def foo (): pass We have used three different names here: x , avar and foo . The first two names represent variables that store literals. The last name represents a function. How does the Python interpreter internally process these names? It uses a concept called namespaces. A namespace can be thought of as a lookup table \u2014 dictionary to be precise \u2014 that maps names to objects.","title":"Namespaces"},{"location":"chapter-4/lesson-4.3/#globals","text":"There are different types of namespaces. The variables that we define in the main program are represented in the globals namespace. For example: x = 1.0 avar = 'cool' def foo (): y = 2.0 foo () print ( globals ()) This returns the following output: Ignore all the other details and just focus on the region highlighted in yellow. Notice that the names x , avar and foo are present in the namespace. x and avar are mapped to the objects 1 and cool respectively, while foo is mapped to some complex looking object: <function foo at 0x7f8ecd2aa1f0> . The number 0x7f8ecd2aa1f0 is the location in the memory where the function's definition is stored [ refer ]. There is another way to check whether a given name is in a namespace: print ( 'x' in globals ()) print ( 'avar' in globals ()) print ( 'foo' in globals ()) All three lines result in True .","title":"globals()"},{"location":"chapter-4/lesson-4.3/#locals","text":"Notice something interesting in the previous code, the name y is not found in the globals namespace! We can verify this as follows: print ( 'y' in globals ()) This results in False . Variables that are assigned a value inside a function are local to the function and cannot be accessed outside it. How does the Python interpreter handle names inside functions? It creates a separate namespace every time a function is called. This is called a local namespace. Now, consider the following code: def foo (): y = 2.0 print ( 'Is y in locals?' , 'y' in locals ()) foo () print ( 'Is y in globals?' , 'y' in globals ()) It returns the following output: Is y in locals? True Is y in globals? False","title":"locals()"},{"location":"chapter-4/lesson-4.3/#scope-and-namespaces","text":"For every function call, the interpreter creates a local namespace that contains all names and their corresponding objects that are defined in the function. Let us take an example: def foo (): print ( y ) print ( locals ()) x = 1 print ( locals ()) y = 10 foo () This gives the output: 10 {} {'x': 1} Since y is only being referenced inside foo , it doesn't become a part of the local namespace. It remains a global variable. Since x is being assigned a value inside foo , it is a local variable and therefore enters the local namespace. The moment control exits the function, the namespace corresponding to it is deleted. Whenever the interpreter comes across a name in a function it sticks to the following protocol: First peep into the local namespace created for that function call to see if the name is present in it. If it is present, then go ahead and use the value that this variable points to in the local namespace. If it is not present, then look at the global namespace. If it is present in the global namespace, then use the value corresponding to this name. If it is not present in the global namespace, then look into the built-in namespace. We will come back to the built-in namespace right at the end. If it is not present in any of these namespaces, then raise a NameError . The following image captures this idea. The built-in namespace has been ignored for now. Refer to the last section to get the complete image. With this context, let us revisit the problem that we looked at the end of the first section: def foo (): x = 10 print ( f 'x inside foo = { x } ' ) x = 100 foo () print ( f 'x outside foo = { x } ' ) When the function is called at line-6, the interpreter creates a local namespace for foo . At line-2, x becomes a part of this namespace. When x is referenced at line-3, the interpreter first looks at the local namespace for foo . Since x is present there, it is going to use the value corresponding to it - in this case 10 . Once control exits the function, the local namespace corresponding to it is deleted. At line-7, the interpreter will replace the name x with the value 100 which is present in the global namespace.","title":"Scope and Namespaces"},{"location":"chapter-4/lesson-4.3/#global-keyword","text":"Let us revisit the scope rules: Local : Whenever a variable is assigned a value anywhere within a function, its scope becomes local to that function. In other words, whenever a variable appears on the left side of an assignment statement anywhere within a function, it becomes a local variable. Global : If a variable is only referenced inside a function and is never assigned a value inside it, it is implicitly treated as a global variable. Consider the following code: def foo (): print ( x ) x = x + 1 x = 10 foo () When the above code is executed, we get the following error: UnboundLocalError: local variable 'x' referenced before assignment [ refer ]. This code violates the first rule. x is being assigned a value in line-3 of the function; hence it becomes a local variable. At line-2 we are trying to reference a value that is yet to be defined. Note that the assignment statement in line-5 doesn't count as the x there is not local to foo , but is a global variable. But what if we want to reuse the global variable x inside the function foo ? Python provides a keyword called global for this purpose: def foo (): global x print ( f 'x inside foo = { x } ' ) x = x + 1 print ( f 'x inside foo = { x } ' ) x = 10 print ( f 'x outside foo = { x } ' ) foo () The output is: x outside foo = 10 x inside foo = 10 x inside foo = 11 By declaring x to be global inside foo , a new local variable x is not created even though it appears to the left of an assignment statement in line-4.","title":"global keyword"},{"location":"chapter-4/lesson-4.3/#built-ins","text":"So far we have been freely using built-in functions like print , int , input and so on. At some level, these are also names in Python and these also get resolved during run-time. There is a separate namespace called builtins where these functions are defined. Consider the following code: ##### Never do something like this! ##### print = 1 ##### Never do something like this! ##### If the above code is executed, we don't get an error! This is somewhat surprising. But syntactically, there is nothing wrong here. But we will get into serious problems when we try to do the following: ##### Alarm! Wrong code snippet! ##### print = 1 print ( 1 ) ##### Alarm! Wrong code snippet! ##### This will throw a TypeError . The name print has been hijacked and is being used as an int variable. How does Python allow this to happen? When resolving names, the built-in namespace is the last stage in the interpreter's journey. Syntactically, nothing prevents us from using the name of a built-in function, such as print , as the name of a variable. But this is a very bad practice that should be avoided at any cost!","title":"Built-ins"},{"location":"chapter-4/lesson-4.4/","text":"Lesson-4.4 Function calling Function Consider the following program: def first (): second () print ( 'first' ) def second (): third () print ( 'second' ) def third (): print ( 'third' ) first () When the code given above is executed, the output is as follows: third second first We have already seen that a function can be called from inside another function. In the code snippet given above, we have a slightly complex version. Let us try to understand this visually. This method of visualization is novel and is called the traffic-signal method. You will see why it has been christened this way. Consider a simple function which doesn't call any other function within its body. Most of the functions we have seen so far are like this. The call corresponding to this function could be in one of these two states: ongoing or completed. Ongoing if the control is inside the body of the function, executing one of its lines. Completed if all the lines in the body of the function have been executed and control has exited out of the function, either because a return statement was encountered or because the control reached the last line in the function, in which case None is returned by default. A function which calls another function inside it could find itself in one of the three states: ongoing, suspended or completed. They are color coded as follows. Now you see why it is called the traffic-signal theory: Ongoing and completed have the same meaning. To understand the suspended state, consider the following diagrams that correspond to the code given above: Each column here is called a stack. They all represent the same stack at different instants of time, i.e., the columns here show the state of the stack at three different time instants. The horizontal arrow shows the passage of time. The vertical arrow indicates that each new function call gets added onto the top of the stack. Re-introducing the code for reference: def first (): second () print ( 'first' ) def second (): third () print ( 'second' ) def third (): print ( 'third' ) first () As third() doesn't call any other function, it never enters the suspended state. Line-10 is the first print statement to be executed; this is why we see third as the first entry in the output. The job of the function third is done and it turns red. Now, the call transfers to the most recent suspended function - second . The execution of second resumes from the point where it got suspended; the print statement at line-7 is executed following which second turns red. Finally, control transfers to first , the print statement at line-3 is executed and first turns red. Recursion A recursive function is one which calls itself inside the body of the function. A typical example of recursion is the factorial function: def fact ( n ): if n == 0 : return 1 return n * fact ( n - 1 ) In the fact function given above, when the interpreter comes to line-4, it sees a recursive call to fact . In such a case, it suspends or temporarily halts the execution of fact(n) and starts executing fact(n - 1) . Let us take a concrete example. This is what happens when fact(4) is called: When fact(0) is called, there are no more recursive calls. This is because, the condition in line-2 evaluates to True and the value 1 is returned. This condition is called the base-case of the recursion. In the absence of a base-case, the recursion continues indefinitely and never terminates. Once the base-case kicks in, fact(0) is done with its duty. So, the call transfers to the most recent suspended function. On the stack, we see that this is fact(1) . fact(1) now becomes active. When it returns the value 1 , its life comes to an end, so the control transfers to the most recent suspended function, which is fact(2) . This goes on until we reach fact(4) . When fact(4) returns the value 24 , all calls have been completed and we are done! Caution in Recursion This section discusses some finer aspects of recursion. Fibonacci series Let us take another popular example, the Fibonacci series: $$ 1, 1, 2, 3, 5, 8, ... $$ Each term in this series is obtained by summing the two terms immediately to its left. We can mathematically express this as follows. If \\(x_1 = x_2 = 1\\) , then for all \\(n > 2, n \\in \\mathbb{N}\\) , we have the following recurrence relation: $$ x_n = x_{n - 1} + x_{n - 2} $$ We can now compute the \\(n^{th}\\) term of the Fibonacci series using a recursive function: def fibo ( n ): if n == 1 or n == 2 : return 1 return fibo ( n - 1 ) + fibo ( n - 2 ) Now, try calling fibo(40) . You will notice that it takes a very long time to compute the value. Why does this happen? This is because a lot of wasteful computation happens. Let us see why: This is a different representation of the recursive computation and is called a recursion tree. Notice how some function calls appear multiple times. fibo(3) and fibo(1) are being computed twice, fibo(2) is being computed thrice. For a larger value of n such as 50 , there would be even more wasteful computation. Practically, how can we estimate the time that it takes for this program to run? One way would be to sit in front of the computer with a stopwatch in hand. But that is so un-Pythonic. Thankfully, the time library provides a good solution to this problem: import time def fibo ( n ): if n == 1 or n == 2 : return 1 return fibo ( n - 1 ) + fibo ( n - 2 ) start = time . time () fibo ( 40 ) end = time . time () print ( f 'It took approximately { round ( end - start ) } seconds.' ) In a standard Python repl, it takes almost a minute! Coming back to the problem of Fibonacci series, we see that naive recursion doesn't give us an efficient solution. We can instead look at the following iterative solution: import time def fibo ( n ): if n == 1 or n == 2 : return 1 x_prev , x_curr = 1 , 1 while n > 2 : x_prev , x_curr = x_curr , x_prev + x_curr n -= 1 return x_curr start = time . time () fibo ( 40 ) end = time . time () print ( f 'It took approximately { round ( end - start ) } seconds.' ) Line-8 in the above code may be a little confusing. This is nothing but multiple assignment in the same line done simultaneously. The RHS of the assignment statement will be evaluated first, these two values will then be simultaneously assigned to their respective containers on the LHS. A better and more accurate explanation will be given in the next chapter when we discuss tuples. Counting Function Calls How do we compute the number of times a function is called? We can do this using a global variable: def fact ( n ): global count count = count + 1 if n == 0 : return 1 return n * fact ( n - 1 ) count = 0 fact ( 4 ) print ( count ) This is one of the potential uses of global variables. Turtles all the way down What happens if we have a recursive function without a base case? The simplest example of such a pathological function is: ##### Alarm! Bad code snippet! ##### def foo (): foo () ##### Alarm! Bad code snippet! ##### When the above function is called with foo() , we get a RecursionError with the following message: maximum recursion depth exceeded . The limit is usually set to 1000 in most systems, i.e., If there are more than 1000 recursive calls, then that is going to result in this error. To verify what the limit is, you can run the following code: import sys print ( sys . getrecursionlimit ())","title":"Lesson-4.4"},{"location":"chapter-4/lesson-4.4/#lesson-44","text":"","title":"Lesson-4.4"},{"location":"chapter-4/lesson-4.4/#function-calling-function","text":"Consider the following program: def first (): second () print ( 'first' ) def second (): third () print ( 'second' ) def third (): print ( 'third' ) first () When the code given above is executed, the output is as follows: third second first We have already seen that a function can be called from inside another function. In the code snippet given above, we have a slightly complex version. Let us try to understand this visually. This method of visualization is novel and is called the traffic-signal method. You will see why it has been christened this way. Consider a simple function which doesn't call any other function within its body. Most of the functions we have seen so far are like this. The call corresponding to this function could be in one of these two states: ongoing or completed. Ongoing if the control is inside the body of the function, executing one of its lines. Completed if all the lines in the body of the function have been executed and control has exited out of the function, either because a return statement was encountered or because the control reached the last line in the function, in which case None is returned by default. A function which calls another function inside it could find itself in one of the three states: ongoing, suspended or completed. They are color coded as follows. Now you see why it is called the traffic-signal theory: Ongoing and completed have the same meaning. To understand the suspended state, consider the following diagrams that correspond to the code given above: Each column here is called a stack. They all represent the same stack at different instants of time, i.e., the columns here show the state of the stack at three different time instants. The horizontal arrow shows the passage of time. The vertical arrow indicates that each new function call gets added onto the top of the stack. Re-introducing the code for reference: def first (): second () print ( 'first' ) def second (): third () print ( 'second' ) def third (): print ( 'third' ) first () As third() doesn't call any other function, it never enters the suspended state. Line-10 is the first print statement to be executed; this is why we see third as the first entry in the output. The job of the function third is done and it turns red. Now, the call transfers to the most recent suspended function - second . The execution of second resumes from the point where it got suspended; the print statement at line-7 is executed following which second turns red. Finally, control transfers to first , the print statement at line-3 is executed and first turns red.","title":"Function calling Function"},{"location":"chapter-4/lesson-4.4/#recursion","text":"A recursive function is one which calls itself inside the body of the function. A typical example of recursion is the factorial function: def fact ( n ): if n == 0 : return 1 return n * fact ( n - 1 ) In the fact function given above, when the interpreter comes to line-4, it sees a recursive call to fact . In such a case, it suspends or temporarily halts the execution of fact(n) and starts executing fact(n - 1) . Let us take a concrete example. This is what happens when fact(4) is called: When fact(0) is called, there are no more recursive calls. This is because, the condition in line-2 evaluates to True and the value 1 is returned. This condition is called the base-case of the recursion. In the absence of a base-case, the recursion continues indefinitely and never terminates. Once the base-case kicks in, fact(0) is done with its duty. So, the call transfers to the most recent suspended function. On the stack, we see that this is fact(1) . fact(1) now becomes active. When it returns the value 1 , its life comes to an end, so the control transfers to the most recent suspended function, which is fact(2) . This goes on until we reach fact(4) . When fact(4) returns the value 24 , all calls have been completed and we are done!","title":"Recursion"},{"location":"chapter-4/lesson-4.4/#caution-in-recursion","text":"This section discusses some finer aspects of recursion.","title":"Caution in Recursion"},{"location":"chapter-4/lesson-4.4/#fibonacci-series","text":"Let us take another popular example, the Fibonacci series: $$ 1, 1, 2, 3, 5, 8, ... $$ Each term in this series is obtained by summing the two terms immediately to its left. We can mathematically express this as follows. If \\(x_1 = x_2 = 1\\) , then for all \\(n > 2, n \\in \\mathbb{N}\\) , we have the following recurrence relation: $$ x_n = x_{n - 1} + x_{n - 2} $$ We can now compute the \\(n^{th}\\) term of the Fibonacci series using a recursive function: def fibo ( n ): if n == 1 or n == 2 : return 1 return fibo ( n - 1 ) + fibo ( n - 2 ) Now, try calling fibo(40) . You will notice that it takes a very long time to compute the value. Why does this happen? This is because a lot of wasteful computation happens. Let us see why: This is a different representation of the recursive computation and is called a recursion tree. Notice how some function calls appear multiple times. fibo(3) and fibo(1) are being computed twice, fibo(2) is being computed thrice. For a larger value of n such as 50 , there would be even more wasteful computation. Practically, how can we estimate the time that it takes for this program to run? One way would be to sit in front of the computer with a stopwatch in hand. But that is so un-Pythonic. Thankfully, the time library provides a good solution to this problem: import time def fibo ( n ): if n == 1 or n == 2 : return 1 return fibo ( n - 1 ) + fibo ( n - 2 ) start = time . time () fibo ( 40 ) end = time . time () print ( f 'It took approximately { round ( end - start ) } seconds.' ) In a standard Python repl, it takes almost a minute! Coming back to the problem of Fibonacci series, we see that naive recursion doesn't give us an efficient solution. We can instead look at the following iterative solution: import time def fibo ( n ): if n == 1 or n == 2 : return 1 x_prev , x_curr = 1 , 1 while n > 2 : x_prev , x_curr = x_curr , x_prev + x_curr n -= 1 return x_curr start = time . time () fibo ( 40 ) end = time . time () print ( f 'It took approximately { round ( end - start ) } seconds.' ) Line-8 in the above code may be a little confusing. This is nothing but multiple assignment in the same line done simultaneously. The RHS of the assignment statement will be evaluated first, these two values will then be simultaneously assigned to their respective containers on the LHS. A better and more accurate explanation will be given in the next chapter when we discuss tuples.","title":"Fibonacci series"},{"location":"chapter-4/lesson-4.4/#counting-function-calls","text":"How do we compute the number of times a function is called? We can do this using a global variable: def fact ( n ): global count count = count + 1 if n == 0 : return 1 return n * fact ( n - 1 ) count = 0 fact ( 4 ) print ( count ) This is one of the potential uses of global variables.","title":"Counting Function Calls"},{"location":"chapter-4/lesson-4.4/#turtles-all-the-way-down","text":"What happens if we have a recursive function without a base case? The simplest example of such a pathological function is: ##### Alarm! Bad code snippet! ##### def foo (): foo () ##### Alarm! Bad code snippet! ##### When the above function is called with foo() , we get a RecursionError with the following message: maximum recursion depth exceeded . The limit is usually set to 1000 in most systems, i.e., If there are more than 1000 recursive calls, then that is going to result in this error. To verify what the limit is, you can run the following code: import sys print ( sys . getrecursionlimit ())","title":"Turtles all the way down"},{"location":"chapter-5/lesson-5.1/","text":"Lesson-5.1 Lists Introduction A list in Python is a data structure that is used to store a sequence of objects. Some examples are given below: numbers = [ 1 , 2 , 3 , 4 , 5 ] letters = [ 'a' , 'b' , 'c' , 'd' ] words = [ 'this' , 'is' , 'a' , 'list' ] Lists can be printed, just like the other types we have seen so far. print(numbers) will give the following output: [1, 2, 3, 4, 5] Lists could contain objects of different data types. Python permits lists such as this: mixture = [ 1 , 1.0 , '1' , True ] Lists have a separate data type - list . We can also check if a given variable holds an object of type list : numbers = [ 1 , 2 , 3 ] print ( type ( numbers )) print ( isinstance ( numbers , list )) The len function can be used to find the number of elements in a list: numbers = [ 1 , 2 , 3 ] print ( f 'This list has { len ( numbers ) } elements in it' ) Lists support indexing and slicing. These two operations work exactly the same way as they did for strings: numbers = [ 1 , 2 , 3 , 4 ] print ( numbers [ 0 ], numbers [ 1 ], numbers [ 2 ], numbers [ 3 ]) print ( numbers [ 1 : 3 ]) print ( numbers [ - 2 ]) Iterating through lists As a list is a sequence, we can iterate through it using for . This is one of the primary uses of the for loop: # Method-1 numbers = [ 1 , 2 , 3 , 4 ] for num in numbers : print ( num ) The loop variable \u2014 num \u2014 picks one item at a time from the sequence. In the body of the loop, we are just printing this item. We can rewrite the code given above using a while loop: # Method-2 numbers = [ 1 , 2 , 3 , 4 ] index = 0 while index < len ( numbers ): print ( numbers [ index ]) index += 1 Finally, we can also use the for loop to iterate through the indices of the list. For this, we take the help of the range function. # Method-3 numbers = [ 1 , 2 , 3 , 4 ] for index in range ( len ( numbers )): print ( numbers [ index ]) In the example given above, len(numbers) is equal to 4 . So, the range sequence will be 0, 1, 2, 3 . index is the loop variable that iterates through this sequence. Methods 2 and 3 are very similar. Both iterate through the sequence of indices, and use list indexing to access the corresponding element in the list. The only difference is that method-2 uses while , while method-3 uses for . Method-1 stands out from the other two as it directly pulls elements from the sequence. Growing a list Lists are typically used in problems where we wish to store a collection of items. Usually, we start with an empty list. Python provides two ways to create an empty list: list1 = [] list2 = list () Both list1 and list2 are empty lists. The interpreter doesn't mind spaces between the opening and closing braces, so list1 = [ ] also works. Given an empty list, how do we add items to it? Python provides two ways to do this: list1 = list1 + [ 1 ] print ( list1 ) list2 = list2 . append ( 1 ) print ( list2 ) Both lists end up having just the one element. The first method is called list concatenation , i.e., two lists are being concatenated or combined together. Treat concatenation like joining two compartments of a train together. It is very similar to string concatenation. The second way uses a method called append that is essentially a function defined for the list type. Append adds elements at the end of the list. Consider the following problem: Generate the list of positive integers less than 100 that are divisible by 3. There are at least two ways of doing this. The first one uses while : # Method-1 num = 3 nums_div = [] while num < 100 : nums_div . append ( num ) num += 3 The next method uses for : # Method-2 nums_div = [] for num in range ( 3 , 100 , 3 ): nums_div . append ( num ) Operations on Lists We have already seen how the + operator works with lists: list1 = [ 1 , 2 , 3 ] list2 = [ 4 , 5 , 6 ] list12 = list1 + list2 print ( list12 ) list21 = list2 + list1 print ( list21 ) This gives the concatenated output: [1, 2, 3, 4, 5, 6] [4, 5, 6, 1, 2, 3] The order matters when two lists are being concatenated! The next is the * operator: list1 = [ 0 ] * 5 print ( list1 ) list2 = [ 1 , 2 , 3 ] * 3 print ( list2 ) This replicates the list. The following is the output: [ 0 , 0 , 0 , 0 , 0 ] [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] Two lists are equal if they have the same sequence of elements: l1 = [ 1 , 2 , 3 ] l2 = [ 1 , 2 , 3 ] l3 = [ 3 , 2 , 1 ] print ( l1 == l2 ) print ( l2 == l3 ) This results in: True False Finally, two lists can be compared with the > or the < operator. List comparison works very similar to string comparison, in that it uses lexicographic ordering. We looked at this in the first chapter: Lexicographic ordering First element from both lists are compared. If they differ this determines the outcome of the comparison. If they are equal, then the second element of both the lists are compared. This process continues until either list is exhausted. Some example comparisons: print ([ 1 , 2 ] < [ 2 , 1 ]) print ([ 1 ] < [ 1 , 2 , 3 ]) print ([ 2 , 3 , 4 ] < [ 3 ]) print ([] < [ 1 ]) All four of them result in True . Useful Functions Let us look at some built-in functions that operate on lists: sum : this is used to find the sum of the elements in a list of numbers: a = [ 1 , 2 , 3 ] print ( sum ( a )) max and min : these two functions find the maximum and minimum value in a list respectively. a = [ 1 , 2 , 3 ] print ( min ( a ), max ( a )) What happens if a is a list of strings? What would max(a) and min(a) produce? sorted : this function returns a sorted list a = [ 2 , 1 , 3 ] print ( sorted ( a )) We have come across the range object and seen how useful it was in iterating through a sequence. So far range has been associated with the for loop. Its time has come to break out of the loopy prison: numbers = range ( 10 ) print ( numbers ) This gives range(0, 10) as an output. This is a sequence that we can iterate over. Python provides a way of turning this object into a list: numbers = list ( range ( 10 )) print ( numbers ) This gives [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] as the output.","title":"Lesson-5.1"},{"location":"chapter-5/lesson-5.1/#lesson-51","text":"","title":"Lesson-5.1"},{"location":"chapter-5/lesson-5.1/#lists","text":"","title":"Lists"},{"location":"chapter-5/lesson-5.1/#introduction","text":"A list in Python is a data structure that is used to store a sequence of objects. Some examples are given below: numbers = [ 1 , 2 , 3 , 4 , 5 ] letters = [ 'a' , 'b' , 'c' , 'd' ] words = [ 'this' , 'is' , 'a' , 'list' ] Lists can be printed, just like the other types we have seen so far. print(numbers) will give the following output: [1, 2, 3, 4, 5] Lists could contain objects of different data types. Python permits lists such as this: mixture = [ 1 , 1.0 , '1' , True ] Lists have a separate data type - list . We can also check if a given variable holds an object of type list : numbers = [ 1 , 2 , 3 ] print ( type ( numbers )) print ( isinstance ( numbers , list )) The len function can be used to find the number of elements in a list: numbers = [ 1 , 2 , 3 ] print ( f 'This list has { len ( numbers ) } elements in it' ) Lists support indexing and slicing. These two operations work exactly the same way as they did for strings: numbers = [ 1 , 2 , 3 , 4 ] print ( numbers [ 0 ], numbers [ 1 ], numbers [ 2 ], numbers [ 3 ]) print ( numbers [ 1 : 3 ]) print ( numbers [ - 2 ])","title":"Introduction"},{"location":"chapter-5/lesson-5.1/#iterating-through-lists","text":"As a list is a sequence, we can iterate through it using for . This is one of the primary uses of the for loop: # Method-1 numbers = [ 1 , 2 , 3 , 4 ] for num in numbers : print ( num ) The loop variable \u2014 num \u2014 picks one item at a time from the sequence. In the body of the loop, we are just printing this item. We can rewrite the code given above using a while loop: # Method-2 numbers = [ 1 , 2 , 3 , 4 ] index = 0 while index < len ( numbers ): print ( numbers [ index ]) index += 1 Finally, we can also use the for loop to iterate through the indices of the list. For this, we take the help of the range function. # Method-3 numbers = [ 1 , 2 , 3 , 4 ] for index in range ( len ( numbers )): print ( numbers [ index ]) In the example given above, len(numbers) is equal to 4 . So, the range sequence will be 0, 1, 2, 3 . index is the loop variable that iterates through this sequence. Methods 2 and 3 are very similar. Both iterate through the sequence of indices, and use list indexing to access the corresponding element in the list. The only difference is that method-2 uses while , while method-3 uses for . Method-1 stands out from the other two as it directly pulls elements from the sequence.","title":"Iterating through lists"},{"location":"chapter-5/lesson-5.1/#growing-a-list","text":"Lists are typically used in problems where we wish to store a collection of items. Usually, we start with an empty list. Python provides two ways to create an empty list: list1 = [] list2 = list () Both list1 and list2 are empty lists. The interpreter doesn't mind spaces between the opening and closing braces, so list1 = [ ] also works. Given an empty list, how do we add items to it? Python provides two ways to do this: list1 = list1 + [ 1 ] print ( list1 ) list2 = list2 . append ( 1 ) print ( list2 ) Both lists end up having just the one element. The first method is called list concatenation , i.e., two lists are being concatenated or combined together. Treat concatenation like joining two compartments of a train together. It is very similar to string concatenation. The second way uses a method called append that is essentially a function defined for the list type. Append adds elements at the end of the list. Consider the following problem: Generate the list of positive integers less than 100 that are divisible by 3. There are at least two ways of doing this. The first one uses while : # Method-1 num = 3 nums_div = [] while num < 100 : nums_div . append ( num ) num += 3 The next method uses for : # Method-2 nums_div = [] for num in range ( 3 , 100 , 3 ): nums_div . append ( num )","title":"Growing a list"},{"location":"chapter-5/lesson-5.1/#operations-on-lists","text":"We have already seen how the + operator works with lists: list1 = [ 1 , 2 , 3 ] list2 = [ 4 , 5 , 6 ] list12 = list1 + list2 print ( list12 ) list21 = list2 + list1 print ( list21 ) This gives the concatenated output: [1, 2, 3, 4, 5, 6] [4, 5, 6, 1, 2, 3] The order matters when two lists are being concatenated! The next is the * operator: list1 = [ 0 ] * 5 print ( list1 ) list2 = [ 1 , 2 , 3 ] * 3 print ( list2 ) This replicates the list. The following is the output: [ 0 , 0 , 0 , 0 , 0 ] [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] Two lists are equal if they have the same sequence of elements: l1 = [ 1 , 2 , 3 ] l2 = [ 1 , 2 , 3 ] l3 = [ 3 , 2 , 1 ] print ( l1 == l2 ) print ( l2 == l3 ) This results in: True False Finally, two lists can be compared with the > or the < operator. List comparison works very similar to string comparison, in that it uses lexicographic ordering. We looked at this in the first chapter: Lexicographic ordering First element from both lists are compared. If they differ this determines the outcome of the comparison. If they are equal, then the second element of both the lists are compared. This process continues until either list is exhausted. Some example comparisons: print ([ 1 , 2 ] < [ 2 , 1 ]) print ([ 1 ] < [ 1 , 2 , 3 ]) print ([ 2 , 3 , 4 ] < [ 3 ]) print ([] < [ 1 ]) All four of them result in True .","title":"Operations on Lists"},{"location":"chapter-5/lesson-5.1/#useful-functions","text":"Let us look at some built-in functions that operate on lists: sum : this is used to find the sum of the elements in a list of numbers: a = [ 1 , 2 , 3 ] print ( sum ( a )) max and min : these two functions find the maximum and minimum value in a list respectively. a = [ 1 , 2 , 3 ] print ( min ( a ), max ( a )) What happens if a is a list of strings? What would max(a) and min(a) produce? sorted : this function returns a sorted list a = [ 2 , 1 , 3 ] print ( sorted ( a )) We have come across the range object and seen how useful it was in iterating through a sequence. So far range has been associated with the for loop. Its time has come to break out of the loopy prison: numbers = range ( 10 ) print ( numbers ) This gives range(0, 10) as an output. This is a sequence that we can iterate over. Python provides a way of turning this object into a list: numbers = list ( range ( 10 )) print ( numbers ) This gives [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] as the output.","title":"Useful Functions"},{"location":"chapter-5/lesson-5.2/","text":"Lesson-5.2 Lists Mutability Consider the following problem: Assume that you work at a company that analyzes cricket matches. As a part of the data collection process in the IPL, the data-processing team is tasked with recording the runs scored in every ball in every match. It is your colleague's turn to do the bookkeeping for the final match between CSK and MI. Just before the start, the \"0\" key on his keyboard stops functioning. As a workaround, you cleverly suggest that he use the letter \"O\" instead of 0. Once the match is over, you collect the list of runs scored. Write a program that replaces all appearances of the letter \"O\" with the number 0. I leave it to your imagination to decide who won the finals! Solution runs = [ 1 , 4 , 2 , 'O' , 4 , 'O' ] # the data for one over is given here print ( runs ) for i in range ( len ( runs )): if runs [ i ] == 'O' : runs [ i ] = 0 print ( runs ) The most interesting line is the fifth one: runs[i] = 0 . We are updating a list in-place . Python permits this operation because lists are mutable . Contrast this with strings that are immutable, which means that they cannot be updated in-place. Mutability makes lists powerful; but reckless exercise of power always results in instability as is demonstrated by this notorious example: list1 = [ 1 , 2 , 3 ] list2 = list1 list2 [ 0 ] = 100 print ( list1 ) print ( list2 ) Both give the same output even though we are only modifying list2 in-place! [100, 2, 3] [100, 2, 3] What is happening here? To understand this, we will take the help of a built-in function called id . Every object in Python has a unique identity: if x is an object, then id(x) returns this object's identity. From the Python documentation, \"this is guaranteed to be unique among simultaneously existing objects\". In the implementation of the Python that we use, this unique id is nothing but the object's memory address. In line-2, we are not creating a new object. We are merely creating another name, also called an alias, for the same object. Think of this like having a nickname. Your name and nickname are two different words, but both of them refer to you. To see if two Python names point to the same object, we can use the is keyword: list1 = [ 1 , 2 , 3 ] list2 = list1 list2 [ 0 ] = 100 print ( list1 is list2 ) This prints True . Now consider another scenario: list1 = [ 1 , 2 , 3 ] list2 = [ 1 , 2 , 3 ] print ( list1 == list2 ) print ( list1 is list2 ) This gives the following output: True False This because equality and identity are two different things. In the code, line-3 checks for equality of two lists, line-4 checks if the two lists point to the same object. list1 and list2 point to two different objects and consequently have different identities. But, they store the same sequence of items and are hence equal. How do we create a copy of a list so that updating one doesn't end up changing both? Python provides three ways to do this: list1 = [ 1 , 2 , 3 ] list2 = list ( list1 ) list3 = list1 [:] list4 = list1 . copy () list2 [ 0 ] = 100 list3 [ 0 ] = 200 list4 [ 0 ] = 300 print ( list1 , list2 , list3 , list4 ) print ( list1 is not list2 , list1 is not list3 , list1 is not list4 ) This results in the following output: [1, 2, 3] [100, 2, 3] [200, 2, 3] [300, 2, 3] True True True In line-2, we pass list1 as an argument to the list function which returns a new list object with the same sequence of elements as list1 . In line-3, we are slicing the list. Slicing a list results in a new list object. As no start or stop values are mentioned, they are going to default to 0 and len(list1) respectively. So, the entire list is returned. However, it is a brand new object. In line-4, we use a method call copy that is defined for the list object. Lines 10 and 11 verify that the methods used to copy lists in lines 2, 3 and 4 actually work. Call by reference Mutability impacts the way lists are handled in functions. Consider these two snippets: # Snippet-1 def foo (): L . append ( 1 ) L = [ 0 ] print ( f 'L before: { L } ' ) foo () print ( f 'L after: { L } ' ) Snippet-1 doesn't have any parameters. Since L is not being assigned a new value inside foo , the scope of L remains global. # Snippet-2 def foo ( L_foo ): L_foo . append ( 1 ) print ( L is L_foo ) L = [ 0 ] print ( f 'L before: { L } ' ) foo ( L ) print ( f 'L after: { L } ' ) Snippet-2 has L_foo as a parameter whose scope is local to foo . But note that modifying L_foo within the function changes L outside the function. This is because, L_foo and L point to the same object. How did this aliasing happen? The function call at line-8 works something like an assignment statement: L_foo = L , so L_foo is just another name that refers to the object that L is bound to. This type of function call where a reference to an object is passed is termed call by reference. Whenever a mutable variable is passed as an argument to a function, the references to the corresponding object are passed. If all this seems too complicated, just remember that modifying mutable objects within a function produces side effects outside the function. What if we don't want these side effects? We have to create a new list object like we did before: def foo ( L_foo ): L_foo . append ( 1 ) print ( L is L_foo ) L = [ 0 ] print ( f 'L before: { L } ' ) foo ( list ( L )) print ( f 'L after: { L } ' ) foo doesn't produce any side effects. Line-7 could be replaced with foo(L[:]) or foo(L.copy()) .","title":"Lesson-5.2"},{"location":"chapter-5/lesson-5.2/#lesson-52","text":"","title":"Lesson-5.2"},{"location":"chapter-5/lesson-5.2/#lists","text":"","title":"Lists"},{"location":"chapter-5/lesson-5.2/#mutability","text":"Consider the following problem: Assume that you work at a company that analyzes cricket matches. As a part of the data collection process in the IPL, the data-processing team is tasked with recording the runs scored in every ball in every match. It is your colleague's turn to do the bookkeeping for the final match between CSK and MI. Just before the start, the \"0\" key on his keyboard stops functioning. As a workaround, you cleverly suggest that he use the letter \"O\" instead of 0. Once the match is over, you collect the list of runs scored. Write a program that replaces all appearances of the letter \"O\" with the number 0. I leave it to your imagination to decide who won the finals! Solution runs = [ 1 , 4 , 2 , 'O' , 4 , 'O' ] # the data for one over is given here print ( runs ) for i in range ( len ( runs )): if runs [ i ] == 'O' : runs [ i ] = 0 print ( runs ) The most interesting line is the fifth one: runs[i] = 0 . We are updating a list in-place . Python permits this operation because lists are mutable . Contrast this with strings that are immutable, which means that they cannot be updated in-place. Mutability makes lists powerful; but reckless exercise of power always results in instability as is demonstrated by this notorious example: list1 = [ 1 , 2 , 3 ] list2 = list1 list2 [ 0 ] = 100 print ( list1 ) print ( list2 ) Both give the same output even though we are only modifying list2 in-place! [100, 2, 3] [100, 2, 3] What is happening here? To understand this, we will take the help of a built-in function called id . Every object in Python has a unique identity: if x is an object, then id(x) returns this object's identity. From the Python documentation, \"this is guaranteed to be unique among simultaneously existing objects\". In the implementation of the Python that we use, this unique id is nothing but the object's memory address. In line-2, we are not creating a new object. We are merely creating another name, also called an alias, for the same object. Think of this like having a nickname. Your name and nickname are two different words, but both of them refer to you. To see if two Python names point to the same object, we can use the is keyword: list1 = [ 1 , 2 , 3 ] list2 = list1 list2 [ 0 ] = 100 print ( list1 is list2 ) This prints True . Now consider another scenario: list1 = [ 1 , 2 , 3 ] list2 = [ 1 , 2 , 3 ] print ( list1 == list2 ) print ( list1 is list2 ) This gives the following output: True False This because equality and identity are two different things. In the code, line-3 checks for equality of two lists, line-4 checks if the two lists point to the same object. list1 and list2 point to two different objects and consequently have different identities. But, they store the same sequence of items and are hence equal. How do we create a copy of a list so that updating one doesn't end up changing both? Python provides three ways to do this: list1 = [ 1 , 2 , 3 ] list2 = list ( list1 ) list3 = list1 [:] list4 = list1 . copy () list2 [ 0 ] = 100 list3 [ 0 ] = 200 list4 [ 0 ] = 300 print ( list1 , list2 , list3 , list4 ) print ( list1 is not list2 , list1 is not list3 , list1 is not list4 ) This results in the following output: [1, 2, 3] [100, 2, 3] [200, 2, 3] [300, 2, 3] True True True In line-2, we pass list1 as an argument to the list function which returns a new list object with the same sequence of elements as list1 . In line-3, we are slicing the list. Slicing a list results in a new list object. As no start or stop values are mentioned, they are going to default to 0 and len(list1) respectively. So, the entire list is returned. However, it is a brand new object. In line-4, we use a method call copy that is defined for the list object. Lines 10 and 11 verify that the methods used to copy lists in lines 2, 3 and 4 actually work.","title":"Mutability"},{"location":"chapter-5/lesson-5.2/#call-by-reference","text":"Mutability impacts the way lists are handled in functions. Consider these two snippets: # Snippet-1 def foo (): L . append ( 1 ) L = [ 0 ] print ( f 'L before: { L } ' ) foo () print ( f 'L after: { L } ' ) Snippet-1 doesn't have any parameters. Since L is not being assigned a new value inside foo , the scope of L remains global. # Snippet-2 def foo ( L_foo ): L_foo . append ( 1 ) print ( L is L_foo ) L = [ 0 ] print ( f 'L before: { L } ' ) foo ( L ) print ( f 'L after: { L } ' ) Snippet-2 has L_foo as a parameter whose scope is local to foo . But note that modifying L_foo within the function changes L outside the function. This is because, L_foo and L point to the same object. How did this aliasing happen? The function call at line-8 works something like an assignment statement: L_foo = L , so L_foo is just another name that refers to the object that L is bound to. This type of function call where a reference to an object is passed is termed call by reference. Whenever a mutable variable is passed as an argument to a function, the references to the corresponding object are passed. If all this seems too complicated, just remember that modifying mutable objects within a function produces side effects outside the function. What if we don't want these side effects? We have to create a new list object like we did before: def foo ( L_foo ): L_foo . append ( 1 ) print ( L is L_foo ) L = [ 0 ] print ( f 'L before: { L } ' ) foo ( list ( L )) print ( f 'L after: { L } ' ) foo doesn't produce any side effects. Line-7 could be replaced with foo(L[:]) or foo(L.copy()) .","title":"Call by reference"},{"location":"chapter-5/lesson-5.3/","text":"Lesson-5.3 Lists Simulating an IPL Innings Let us return to the problem of recording the number of runs scored in every ball of an IPL match. A typical innings of a T20 match has 20 overs, each over having 6 balls. Let us assume that all balls bowled are fair deliveries that do not concede any extras, a rather liberal assumption. This leaves us with exactly 120 numbers that we need to record, all lying between 0 and 6. How can this information be stored in a Python program that makes it suitable for further processing? A list is a good candidate. Let us now simulate an innings. For this, we take the help of the random library: import random runs = random . choices ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 ], k = 120 ) print ( type ( runs )) print ( len ( runs )) choices is a function in the random library. It uniformly samples from the seven numbers (0 to 6) given in the input list with replacement. If that sounded too cryptic, this is what it does: Pick a number from the list [0, 1, 2, 3, 4, 5, 6] at random. Each of the seven numbers is equally likely to be picked. Add this to the output list. The original list remains undisturbed, i.e., we are not moving an element from the input list to the output list, we are only copying it. Repeat this process 120 times. Let us verify if the counts are approximately the same: for run in [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ]: print ( ' {} appears {} times' . format ( run , runs . count ( run ))) runs.count(run) returns the number of times the element run appears in the list runs . count is a method defined for the list type. This gives the following output: 0 appears 19 times 1 appears 20 times 2 appears 19 times 3 appears 16 times 4 appears 18 times 5 appears 11 times 6 appears 17 times The counts are quite close. But this is not very practical: 5 runs are seldom observed in cricket matches. 0 , 1 and 2 are much more common than 3 , 4 and 6 . We can give our preferences using a weights keyword-argument: import random # choices is distributed over multiple lines # this is done to improve readability runs = random . choices ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 ], weights = [ 30 , 30 , 20 , 5 , 10 , 0 , 5 ], k = 120 ) for run in [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ]: print ( ' {} appears {} times' . format ( run , runs . count ( run ))) print ( f 'Total number of runs scored = { sum ( runs ) } ' ) This gives the following output: 0 appears 32 times 1 appears 34 times 2 appears 32 times 3 appears 7 times 4 appears 12 times 5 appears 0 times 6 appears 3 times Total number of runs scored = 185 We have used sum(runs) to get the sum of the elements in the list. sum is a built-in function. The way to understand the weights keyword-argument is using the following table: Run Weight 0 30 1 30 2 20 3 5 4 10 5 0 6 5 Total 100 The weight is the importance given to a run. From the table given above, we see that 0 and 1 occur 30% of the times, 6 occurs 5% of the times and so on. choices function will keep this distribution in mind while picking up items from the input-list. Let us now start analyzing this innings. We have already seen how to count the number of occurrences of singles, doubles, fours and sixes. What about the first occurrence of a six? In which ball was the first six scored? first_six_ball = runs . index ( 6 ) + 1 print ( first_six_ball ) index is a method that accepts an element as input and returns the first occurrence of this element in the list. For example, runs.index(6) returns the first index where a six occurs in the list runs . Since the number of balls is one more than the index, 1 has been added. What happens if we pass an input that is not present in the list: first_five_ball = runs . index ( 5 ) print ( first_five_ball ) In this case, 5 never occurs in the list. So this throws a ValueError with the following message: 5 is not in list . One must be careful while using the index method. We could have done this using another method: for ball , run in enumerate ( runs ): if run == 6 : print ( f 'The first six was hit at ball number { ball + 1 } ' ) break The enumerate object can be very handy when we want to access both the element and its index while iterating through a list. The enumerate object yields pairs: (index, list[index]) . In some sense, we have two loop variables: the first is the index of the element in the list while the second is the element itself. Coming back to cricket, what if we want to find the number of balls it took to score the last 50 runs in the innings? It would be easier to reverse the list and then iterate through it: balls = 0 last_runs = 0 for run in reversed ( runs ): last_runs += run balls += 1 if last_runs >= 50 : print ( f 'It took { balls } balls to score the last 50 runs.' ) break The reversed object helps us iterate through the list in the reversed order. Note that it doesn't make any changes to the original list. One final question: we wish to find if the batsmen have run three runs at any point in the match. We don't want to know at which point in the innings this has happened. three_existence = 3 in runs print ( three_existence ) Recall that we used the in keyword to check for the presence of one string in another. Something similar is happening here. The code given above prints True if 3 is an element in runs and False otherwise.","title":"Lesson-5.3"},{"location":"chapter-5/lesson-5.3/#lesson-53","text":"","title":"Lesson-5.3"},{"location":"chapter-5/lesson-5.3/#lists","text":"","title":"Lists"},{"location":"chapter-5/lesson-5.3/#simulating-an-ipl-innings","text":"Let us return to the problem of recording the number of runs scored in every ball of an IPL match. A typical innings of a T20 match has 20 overs, each over having 6 balls. Let us assume that all balls bowled are fair deliveries that do not concede any extras, a rather liberal assumption. This leaves us with exactly 120 numbers that we need to record, all lying between 0 and 6. How can this information be stored in a Python program that makes it suitable for further processing? A list is a good candidate. Let us now simulate an innings. For this, we take the help of the random library: import random runs = random . choices ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 ], k = 120 ) print ( type ( runs )) print ( len ( runs )) choices is a function in the random library. It uniformly samples from the seven numbers (0 to 6) given in the input list with replacement. If that sounded too cryptic, this is what it does: Pick a number from the list [0, 1, 2, 3, 4, 5, 6] at random. Each of the seven numbers is equally likely to be picked. Add this to the output list. The original list remains undisturbed, i.e., we are not moving an element from the input list to the output list, we are only copying it. Repeat this process 120 times. Let us verify if the counts are approximately the same: for run in [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ]: print ( ' {} appears {} times' . format ( run , runs . count ( run ))) runs.count(run) returns the number of times the element run appears in the list runs . count is a method defined for the list type. This gives the following output: 0 appears 19 times 1 appears 20 times 2 appears 19 times 3 appears 16 times 4 appears 18 times 5 appears 11 times 6 appears 17 times The counts are quite close. But this is not very practical: 5 runs are seldom observed in cricket matches. 0 , 1 and 2 are much more common than 3 , 4 and 6 . We can give our preferences using a weights keyword-argument: import random # choices is distributed over multiple lines # this is done to improve readability runs = random . choices ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 ], weights = [ 30 , 30 , 20 , 5 , 10 , 0 , 5 ], k = 120 ) for run in [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ]: print ( ' {} appears {} times' . format ( run , runs . count ( run ))) print ( f 'Total number of runs scored = { sum ( runs ) } ' ) This gives the following output: 0 appears 32 times 1 appears 34 times 2 appears 32 times 3 appears 7 times 4 appears 12 times 5 appears 0 times 6 appears 3 times Total number of runs scored = 185 We have used sum(runs) to get the sum of the elements in the list. sum is a built-in function. The way to understand the weights keyword-argument is using the following table: Run Weight 0 30 1 30 2 20 3 5 4 10 5 0 6 5 Total 100 The weight is the importance given to a run. From the table given above, we see that 0 and 1 occur 30% of the times, 6 occurs 5% of the times and so on. choices function will keep this distribution in mind while picking up items from the input-list. Let us now start analyzing this innings. We have already seen how to count the number of occurrences of singles, doubles, fours and sixes. What about the first occurrence of a six? In which ball was the first six scored? first_six_ball = runs . index ( 6 ) + 1 print ( first_six_ball ) index is a method that accepts an element as input and returns the first occurrence of this element in the list. For example, runs.index(6) returns the first index where a six occurs in the list runs . Since the number of balls is one more than the index, 1 has been added. What happens if we pass an input that is not present in the list: first_five_ball = runs . index ( 5 ) print ( first_five_ball ) In this case, 5 never occurs in the list. So this throws a ValueError with the following message: 5 is not in list . One must be careful while using the index method. We could have done this using another method: for ball , run in enumerate ( runs ): if run == 6 : print ( f 'The first six was hit at ball number { ball + 1 } ' ) break The enumerate object can be very handy when we want to access both the element and its index while iterating through a list. The enumerate object yields pairs: (index, list[index]) . In some sense, we have two loop variables: the first is the index of the element in the list while the second is the element itself. Coming back to cricket, what if we want to find the number of balls it took to score the last 50 runs in the innings? It would be easier to reverse the list and then iterate through it: balls = 0 last_runs = 0 for run in reversed ( runs ): last_runs += run balls += 1 if last_runs >= 50 : print ( f 'It took { balls } balls to score the last 50 runs.' ) break The reversed object helps us iterate through the list in the reversed order. Note that it doesn't make any changes to the original list. One final question: we wish to find if the batsmen have run three runs at any point in the match. We don't want to know at which point in the innings this has happened. three_existence = 3 in runs print ( three_existence ) Recall that we used the in keyword to check for the presence of one string in another. Something similar is happening here. The code given above prints True if 3 is an element in runs and False otherwise.","title":"Simulating an IPL Innings"},{"location":"chapter-5/lesson-5.4/","text":"Lesson-5.4 Lists List Methods insert We have looked at list methods like append , count and index so far. There are some more interesting methods that will come in handy. insert can be used to insert an element in a list at a given position: L = [ 1 , 1 , 2 , 3 , 8 ] L . insert ( 4 , 5 ) print ( L ) list.insert(index, object) inserts the object before index in the list . In the code given above, the element 5 is inserted before the index 4 in the list L . Let us try a few more inserts: L = [ 10 , 20 , 30 ] L . insert ( 0 , 5 ) # L becomes [5, 10, 20, 30] L . insert ( 2 , 15 ) # L becomes [5, 10, 15, 20, 30] L . insert ( 4 , 25 ) # L becomes [5, 10, 15, 20, 25, 30] L . insert ( len ( L ), 35 ) # L becomes [5, 10, 15, 20, 25, 30, 35] L . insert ( 20 , 40 ) # L becomes [5, 10, 15, 20, 25, 30, 35, 40] If the index is greater than the length of the current list, then the element gets added to the end. insert is most useful when an element needs to be inserted at the beginning of a list. Inserting an element at the end can be done using append . pop Consider the following code: L = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] index = 1 x = L . pop ( index ) print ( f 'The element { x } at index { index } was removed from the list' ) print ( f 'The current list is { L } ' ) L.pop(index) removes the element at index in L and returns it. If no argument is provided to pop , index defaults to -1. index is thus a default argument for the method pop . A default value of -1 means that the last element in the list is removed. To see this an action, execute the following code: L = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] x = L . pop () print ( f 'The current list is { L } ' ) What happens if you enter an index that is out of range? reverse A list can be reversed in-place using the following method: L = [ 1 , 2 , 3 , 4 , 5 ] print ( 'Before:' , L , id ( L )) L . reverse () print ( 'After:' , L , id ( L )) It is called in-place because the list before and after have the same id , i.e., they correspond to the same object. One must be careful while using methods that perform operations in-place. A common error is to do something like this: L = [ 1 , 2 , 3 , 4 , 5 ] L = L . reverse () print ( L ) This prints None , which is expected as reverse doesn't return a list. But sometimes, one may want to hold on to the original copy as well as its reverse. In such cases, we could do the following: L = [ 1 , 2 , 3 , 4 , 5 ] L_reversed = L . copy () L_reversed . reverse () print ( 'Original list:' , L ) print ( 'Reversed list:' , L_reversed ) Why did we have to make a copy in line-2? sort Another useful method is sort which is used to sort lists in-place: L = [ 2 , 1 , 5 , 6 , 4 , 3 ] print ( 'Before' , L ) L . sort () print ( 'After' , L ) Though this appears to be such a simple function to call, sorting is a non-trivial algorithm. We will be studying various algorithms to sort a sequence of items in the next course on data structures and algorithms. remove Now for some destructive functions: L = [ 1 , 2 , 3 , 4 , 5 ] * 2 print ( 'Before' , L ) L . remove ( 1 ) print ( 'After' , L ) L.remove(x) removes the first (leftmost) occurrence of the element x in the list L . Trying to remove an element that is not there in the list will raise a ValueError with the message list.remove(x): x not in list . A safe way to remove items is as follows: # x is the item to be removed; L is the list if x in L : L . remove ( x ) How is remove different from pop ? Stack A list along with the methods append and pop simulate a data structure called stack . A stack is a storage mechanism where the last item added to it is the first item to be removed. This is analogous to a stack of books. The topmost book in the stack is the most recent addition. When we want to remove books from this stack, the topmost book is the first to be removed. There is a catchy mnemonic for this, LIFO: Last In First Out. # Start with an empty stack stack = [ ] # Append items to end of the stack; also called a push operation stack . append ( 'Harry Potter and the Philosopher \\' s Stone' ) stack . append ( 'Harry Potter and the Chamber of Secrets' ) # State of the stack print ( stack ) # Remove items from the end of the stack; also called a pop operation stack . pop () # State of the stack print ( stack ) Queue A list along with the methods insert and pop simulate a data structure called queue . A queue is a storage mechanism where the first item added to it is the first to be removed. This is analogous to any queue that we encounter in real life, say at a billing counter. The first person to stand in the queue, is the first to be served, and naturally the first to exit the queue. The mnemonic for this is FIFO: First in First Out. # Start with an empty queue queue = [ ] # Insert elements at the beginning of the queue queue . insert ( 0 , 'Customer-1' ) queue . insert ( 0 , 'Customer-2' ) # State of the queue print ( queue ) # Remove items from the queue queue . pop () # State of the queue print ( queue ) Strings and Lists split Lists make a frequent appearance while processing strings. Consider the following problem: Accept a sentence as input and find the number of words in it. Assume that it is a simple sentence with a single space separating consecutive words. There are no other punctuation marks in the sentence. Let us look at a \"list-less\" solution first: Solution-1 sentence = 'this sentence is false' # a simple sentence count = 1 for char in sentence : if char == ' ' : count += 1 print ( count ) We just scanned the sentence character by character and checked the number of spaces. The total number of words is one more than the number of spaces. As an aside, the sentence that we are dealing with is an example of a paradoxical statement. It can't be true or false: if it is true then it is false, if it is false then it is true! Back to Python, we shall look at the solution that uses lists. Solution-2 sentence = 'this sentence is false' # a simple sentence words = sentence . split ( ' ' ) # space is the delimiter used count = len ( words ) print ( count ) split is a string method that splits a string along a delimiter. A delimiter string is one or more characters that specify where to split the string. The output of the split operation is a list of strings that are split along the delimiter. If we print the list words , we get the following list: ['this', 'sentence', 'is', 'false'] . Let us take another example: comma_words = 'one,two,three,four' numbers = comma_words . split ( ',' ) print ( numbers ) We get ['one', 'two', 'three', 'four'] as the output. Note that we have specified ',' as the delimiter. The delimiter is not limited to characters, it can be any string. For example: some_string = 'allISwell' words = some_string . split ( 'IS' ) print ( words ) The output is: ['all', 'well'] . join Just as we went from a string to a list, we can also move from a list of strings to a string. Consider the following problem: Accept a sequence of words as input and construct a sentence out of it. We will first look at a solution that doesn't use lists: Solution-1 words = [ 'this' , 'sentence' , 'is' , 'false' ] sentence = '' for word in words : sentence += word + ' ' print ( sentence ) Though this solution seems correct, it is wrong by one character! Print the last character in the sentence: print ( sentence [ - 1 ]) It is not the letter e but a space. We ended up printing an extra space at the end. This might seem trivial, but programming is all about precision. A better solution is given below: Solution-2 words = [ 'this' , 'sentence' , 'is' , 'false' ] sentence = words [ 0 ] for word in words [ 1 : ]: sentence += ' ' + word print ( sentence ) This is more accurate. But it seems clumsy as we had to iterate from the second word in the list. The final solution uses a simple method and is quite sophisticated. Solution-3 words = [ 'this' , 'sentence' , 'is' , 'false' ] sentence = ' ' . join ( words ) print ( sentence ) Isn't that a thing of beauty! Just as split chops a string along a delimiter, join stitches together the strings in a list, and the thread it uses is a space in this case. We could also stitch them together using any other string, let us use a comma instead: words = [ 'one' , 'two' , 'three' ] sentence = ',' . join ( words ) print ( sentence ) This output is one,two,three . The stitching seems too tight. Let us give it some space: words = [ 'one' , 'two' , 'three' ] sentence = ', ' . join ( words ) print ( sentence ) Notice the space after the comma. The output is one, two, three .","title":"Lesson-5.4"},{"location":"chapter-5/lesson-5.4/#lesson-54","text":"","title":"Lesson-5.4"},{"location":"chapter-5/lesson-5.4/#lists","text":"","title":"Lists"},{"location":"chapter-5/lesson-5.4/#list-methods","text":"","title":"List Methods"},{"location":"chapter-5/lesson-5.4/#insert","text":"We have looked at list methods like append , count and index so far. There are some more interesting methods that will come in handy. insert can be used to insert an element in a list at a given position: L = [ 1 , 1 , 2 , 3 , 8 ] L . insert ( 4 , 5 ) print ( L ) list.insert(index, object) inserts the object before index in the list . In the code given above, the element 5 is inserted before the index 4 in the list L . Let us try a few more inserts: L = [ 10 , 20 , 30 ] L . insert ( 0 , 5 ) # L becomes [5, 10, 20, 30] L . insert ( 2 , 15 ) # L becomes [5, 10, 15, 20, 30] L . insert ( 4 , 25 ) # L becomes [5, 10, 15, 20, 25, 30] L . insert ( len ( L ), 35 ) # L becomes [5, 10, 15, 20, 25, 30, 35] L . insert ( 20 , 40 ) # L becomes [5, 10, 15, 20, 25, 30, 35, 40] If the index is greater than the length of the current list, then the element gets added to the end. insert is most useful when an element needs to be inserted at the beginning of a list. Inserting an element at the end can be done using append .","title":"insert"},{"location":"chapter-5/lesson-5.4/#pop","text":"Consider the following code: L = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] index = 1 x = L . pop ( index ) print ( f 'The element { x } at index { index } was removed from the list' ) print ( f 'The current list is { L } ' ) L.pop(index) removes the element at index in L and returns it. If no argument is provided to pop , index defaults to -1. index is thus a default argument for the method pop . A default value of -1 means that the last element in the list is removed. To see this an action, execute the following code: L = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] x = L . pop () print ( f 'The current list is { L } ' ) What happens if you enter an index that is out of range?","title":"pop"},{"location":"chapter-5/lesson-5.4/#reverse","text":"A list can be reversed in-place using the following method: L = [ 1 , 2 , 3 , 4 , 5 ] print ( 'Before:' , L , id ( L )) L . reverse () print ( 'After:' , L , id ( L )) It is called in-place because the list before and after have the same id , i.e., they correspond to the same object. One must be careful while using methods that perform operations in-place. A common error is to do something like this: L = [ 1 , 2 , 3 , 4 , 5 ] L = L . reverse () print ( L ) This prints None , which is expected as reverse doesn't return a list. But sometimes, one may want to hold on to the original copy as well as its reverse. In such cases, we could do the following: L = [ 1 , 2 , 3 , 4 , 5 ] L_reversed = L . copy () L_reversed . reverse () print ( 'Original list:' , L ) print ( 'Reversed list:' , L_reversed ) Why did we have to make a copy in line-2?","title":"reverse"},{"location":"chapter-5/lesson-5.4/#sort","text":"Another useful method is sort which is used to sort lists in-place: L = [ 2 , 1 , 5 , 6 , 4 , 3 ] print ( 'Before' , L ) L . sort () print ( 'After' , L ) Though this appears to be such a simple function to call, sorting is a non-trivial algorithm. We will be studying various algorithms to sort a sequence of items in the next course on data structures and algorithms.","title":"sort"},{"location":"chapter-5/lesson-5.4/#remove","text":"Now for some destructive functions: L = [ 1 , 2 , 3 , 4 , 5 ] * 2 print ( 'Before' , L ) L . remove ( 1 ) print ( 'After' , L ) L.remove(x) removes the first (leftmost) occurrence of the element x in the list L . Trying to remove an element that is not there in the list will raise a ValueError with the message list.remove(x): x not in list . A safe way to remove items is as follows: # x is the item to be removed; L is the list if x in L : L . remove ( x ) How is remove different from pop ?","title":"remove"},{"location":"chapter-5/lesson-5.4/#stack","text":"A list along with the methods append and pop simulate a data structure called stack . A stack is a storage mechanism where the last item added to it is the first item to be removed. This is analogous to a stack of books. The topmost book in the stack is the most recent addition. When we want to remove books from this stack, the topmost book is the first to be removed. There is a catchy mnemonic for this, LIFO: Last In First Out. # Start with an empty stack stack = [ ] # Append items to end of the stack; also called a push operation stack . append ( 'Harry Potter and the Philosopher \\' s Stone' ) stack . append ( 'Harry Potter and the Chamber of Secrets' ) # State of the stack print ( stack ) # Remove items from the end of the stack; also called a pop operation stack . pop () # State of the stack print ( stack )","title":"Stack"},{"location":"chapter-5/lesson-5.4/#queue","text":"A list along with the methods insert and pop simulate a data structure called queue . A queue is a storage mechanism where the first item added to it is the first to be removed. This is analogous to any queue that we encounter in real life, say at a billing counter. The first person to stand in the queue, is the first to be served, and naturally the first to exit the queue. The mnemonic for this is FIFO: First in First Out. # Start with an empty queue queue = [ ] # Insert elements at the beginning of the queue queue . insert ( 0 , 'Customer-1' ) queue . insert ( 0 , 'Customer-2' ) # State of the queue print ( queue ) # Remove items from the queue queue . pop () # State of the queue print ( queue )","title":"Queue"},{"location":"chapter-5/lesson-5.4/#strings-and-lists","text":"","title":"Strings and Lists"},{"location":"chapter-5/lesson-5.4/#split","text":"Lists make a frequent appearance while processing strings. Consider the following problem: Accept a sentence as input and find the number of words in it. Assume that it is a simple sentence with a single space separating consecutive words. There are no other punctuation marks in the sentence. Let us look at a \"list-less\" solution first: Solution-1 sentence = 'this sentence is false' # a simple sentence count = 1 for char in sentence : if char == ' ' : count += 1 print ( count ) We just scanned the sentence character by character and checked the number of spaces. The total number of words is one more than the number of spaces. As an aside, the sentence that we are dealing with is an example of a paradoxical statement. It can't be true or false: if it is true then it is false, if it is false then it is true! Back to Python, we shall look at the solution that uses lists. Solution-2 sentence = 'this sentence is false' # a simple sentence words = sentence . split ( ' ' ) # space is the delimiter used count = len ( words ) print ( count ) split is a string method that splits a string along a delimiter. A delimiter string is one or more characters that specify where to split the string. The output of the split operation is a list of strings that are split along the delimiter. If we print the list words , we get the following list: ['this', 'sentence', 'is', 'false'] . Let us take another example: comma_words = 'one,two,three,four' numbers = comma_words . split ( ',' ) print ( numbers ) We get ['one', 'two', 'three', 'four'] as the output. Note that we have specified ',' as the delimiter. The delimiter is not limited to characters, it can be any string. For example: some_string = 'allISwell' words = some_string . split ( 'IS' ) print ( words ) The output is: ['all', 'well'] .","title":"split"},{"location":"chapter-5/lesson-5.4/#join","text":"Just as we went from a string to a list, we can also move from a list of strings to a string. Consider the following problem: Accept a sequence of words as input and construct a sentence out of it. We will first look at a solution that doesn't use lists: Solution-1 words = [ 'this' , 'sentence' , 'is' , 'false' ] sentence = '' for word in words : sentence += word + ' ' print ( sentence ) Though this solution seems correct, it is wrong by one character! Print the last character in the sentence: print ( sentence [ - 1 ]) It is not the letter e but a space. We ended up printing an extra space at the end. This might seem trivial, but programming is all about precision. A better solution is given below: Solution-2 words = [ 'this' , 'sentence' , 'is' , 'false' ] sentence = words [ 0 ] for word in words [ 1 : ]: sentence += ' ' + word print ( sentence ) This is more accurate. But it seems clumsy as we had to iterate from the second word in the list. The final solution uses a simple method and is quite sophisticated. Solution-3 words = [ 'this' , 'sentence' , 'is' , 'false' ] sentence = ' ' . join ( words ) print ( sentence ) Isn't that a thing of beauty! Just as split chops a string along a delimiter, join stitches together the strings in a list, and the thread it uses is a space in this case. We could also stitch them together using any other string, let us use a comma instead: words = [ 'one' , 'two' , 'three' ] sentence = ',' . join ( words ) print ( sentence ) This output is one,two,three . The stitching seems too tight. Let us give it some space: words = [ 'one' , 'two' , 'three' ] sentence = ', ' . join ( words ) print ( sentence ) Notice the space after the comma. The output is one, two, three .","title":"join"},{"location":"chapter-5/lesson-5.5/","text":"Lesson-5.5 Lists Nested Lists Recall the runs list that we generated with the help of the random library: import random runs = random . choices ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 ], weights = [ 30 , 30 , 20 , 5 , 10 , 0 , 5 ], k = 120 ) assert len ( runs ) == 120 An assert statement is used whenever we wish to verify if some aspect of our code is working as intended. For example, in line-5 of the code given above, we are making sure that the length of the list is 120 . This is a useful check to have as subsequent computation will depend upon this. If the conditional expression following the assert keyword is True , then control transfers to the next line. If it is False , the interpreter raises an AssertionError . Let us look at a different way of organizing the information contained in runs : overs = list () new_over = list () for ball , run in enumerate ( runs ): new_over . append ( run ) if ( ball + 1 ) % 6 == 0 : overs . append ( new_over ) new_over = list () overs is a nested list, which is nothing but a list of lists. Each element in overs corresponds to an over in the match and is represented by a list that contains the runs scored in that over. The following code does a quick check if the sizes of the outer and inner lists are 20 and 6 respectively. assert len ( overs ) == 20 for over in overs : assert len ( over ) == 6 With this representation in place, how many runs were scored in the fourth ball of the third over? answer = overs [ 2 ][ 3 ] # zero-indexing print ( answer ) The first index corresponds to the outer list while the second index corresponds to the inner list. If this is still confusing, print the following code to convince yourself: third_over = overs [ 2 ] print ( third_over ) fourth_ball = third_over [ 3 ] print ( fourth_ball ) assert fourth_ball == overs [ 2 ][ 3 ] Matrices Matrices are 2D objects. We can represent them as nested lists. Let us first populate a \\(3 \\times 3\\) matrix of zeros: mat = [ ] for i in range ( 3 ): mat . append ([ ]) # we are appending an empty list for _ in range ( 3 ): mat [ i ] . append ( 0 ) print ( mat ) This gives the following output: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] Do you find anything odd in line-4? We have used _ as a loop variable. The inner-loop variable is insignificant and never gets used anywhere. As a convention, we use the _ to represent such variables whose sole purpose is to uphold the syntax of the language. Let us now construct another matrix: mat = [ ] num = 1 for i in range ( 3 ): mat . append ([ ]) for _ in range ( 3 ): mat [ i ] . append ( num ) num += 1 print ( mat ) This gives the following output: [[1, 2, 3], [4, 5, 6], [7, 8, 9]] The code given above to construct this matrix could be written in the following manner as well: mat = [ ] num = 1 for _ in range ( 3 ): row = [ ] for _ in range ( 3 ): row . append ( num ) num += 1 mat . append ( row ) print ( mat ) Shallow and Deep Copy Consider the following code: mat1 = [[ 1 , 2 ], [ 3 , 4 ]] mat2 = mat1 mat2 . append ([ 5 , 6 ]) print ( mat1 ) print ( mat2 ) print ( mat1 is mat2 ) We already know what will happen here. Lists are mutable. mat2 is just an alias for mat1 and both point to the same object. Modifying any one of them will modify both. We also saw three different methods to copy lists so that modifying one doesn't modify the other. Let us try one of them: mat2 = mat1 . copy () mat2 . append ([ 5 , 6 ]) print ( mat1 ) print ( mat2 ) print ( mat1 is mat2 ) No problems so far. But try this: mat1 = [[ 1 , 2 ], [ 3 , 4 ]] mat2 = mat1 . copy () mat2 [ 0 ][ 0 ] = 100 print ( mat1 ) print ( mat2 ) This is the output we get: [[100, 2], [3, 4]] [[100, 2], [3, 4]] What is happening here? mat1 has also changed! Wasn't copy supposed to get rid of this difficulty? We have a mutable object inside another mutable object. In such a case copy just does a shallow copy; only a new outer-list object is produced. This means that the inner lists in mat1 and mat2 are still the same objects: print ( mat1 [ 0 ] is mat2 [ 0 ]) print ( mat1 [ 1 ] is mat2 [ 1 ]) Both lines print True . In order to make a copy where both the inner and outer lists are new objects, we turn to deepcopy: from copy import deepcopy mat1 = [[ 1 , 2 ], [ 3 , 4 ]] mat2 = deepcopy ( mat1 ) mat2 [ 0 ][ 0 ] = 100 print ( mat1 ) print ( mat2 ) This gives the output: [[1, 2], [3, 4]] [[100, 2], [3, 4]] Finally we have two completely different objects: from copy import deepcopy mat1 = [[ 1 , 2 ], [ 3 , 4 ]] mat2 = deepcopy ( mat1 ) print ( mat1 is not mat2 ) print ( mat1 [ 0 ] is not mat2 [ 0 ]) print ( mat1 [ 1 ] is not mat2 [ 1 ]) All three print True ! deepcopy is a function from the library copy . We won't enter into how it works. Suffice to say that when using nested lists or any collection of mutable objects, use deepcopy if you wish to make a clean copy.","title":"Lesson-5.5"},{"location":"chapter-5/lesson-5.5/#lesson-55","text":"","title":"Lesson-5.5"},{"location":"chapter-5/lesson-5.5/#lists","text":"","title":"Lists"},{"location":"chapter-5/lesson-5.5/#nested-lists","text":"Recall the runs list that we generated with the help of the random library: import random runs = random . choices ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 ], weights = [ 30 , 30 , 20 , 5 , 10 , 0 , 5 ], k = 120 ) assert len ( runs ) == 120 An assert statement is used whenever we wish to verify if some aspect of our code is working as intended. For example, in line-5 of the code given above, we are making sure that the length of the list is 120 . This is a useful check to have as subsequent computation will depend upon this. If the conditional expression following the assert keyword is True , then control transfers to the next line. If it is False , the interpreter raises an AssertionError . Let us look at a different way of organizing the information contained in runs : overs = list () new_over = list () for ball , run in enumerate ( runs ): new_over . append ( run ) if ( ball + 1 ) % 6 == 0 : overs . append ( new_over ) new_over = list () overs is a nested list, which is nothing but a list of lists. Each element in overs corresponds to an over in the match and is represented by a list that contains the runs scored in that over. The following code does a quick check if the sizes of the outer and inner lists are 20 and 6 respectively. assert len ( overs ) == 20 for over in overs : assert len ( over ) == 6 With this representation in place, how many runs were scored in the fourth ball of the third over? answer = overs [ 2 ][ 3 ] # zero-indexing print ( answer ) The first index corresponds to the outer list while the second index corresponds to the inner list. If this is still confusing, print the following code to convince yourself: third_over = overs [ 2 ] print ( third_over ) fourth_ball = third_over [ 3 ] print ( fourth_ball ) assert fourth_ball == overs [ 2 ][ 3 ]","title":"Nested Lists"},{"location":"chapter-5/lesson-5.5/#matrices","text":"Matrices are 2D objects. We can represent them as nested lists. Let us first populate a \\(3 \\times 3\\) matrix of zeros: mat = [ ] for i in range ( 3 ): mat . append ([ ]) # we are appending an empty list for _ in range ( 3 ): mat [ i ] . append ( 0 ) print ( mat ) This gives the following output: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] Do you find anything odd in line-4? We have used _ as a loop variable. The inner-loop variable is insignificant and never gets used anywhere. As a convention, we use the _ to represent such variables whose sole purpose is to uphold the syntax of the language. Let us now construct another matrix: mat = [ ] num = 1 for i in range ( 3 ): mat . append ([ ]) for _ in range ( 3 ): mat [ i ] . append ( num ) num += 1 print ( mat ) This gives the following output: [[1, 2, 3], [4, 5, 6], [7, 8, 9]] The code given above to construct this matrix could be written in the following manner as well: mat = [ ] num = 1 for _ in range ( 3 ): row = [ ] for _ in range ( 3 ): row . append ( num ) num += 1 mat . append ( row ) print ( mat )","title":"Matrices"},{"location":"chapter-5/lesson-5.5/#shallow-and-deep-copy","text":"Consider the following code: mat1 = [[ 1 , 2 ], [ 3 , 4 ]] mat2 = mat1 mat2 . append ([ 5 , 6 ]) print ( mat1 ) print ( mat2 ) print ( mat1 is mat2 ) We already know what will happen here. Lists are mutable. mat2 is just an alias for mat1 and both point to the same object. Modifying any one of them will modify both. We also saw three different methods to copy lists so that modifying one doesn't modify the other. Let us try one of them: mat2 = mat1 . copy () mat2 . append ([ 5 , 6 ]) print ( mat1 ) print ( mat2 ) print ( mat1 is mat2 ) No problems so far. But try this: mat1 = [[ 1 , 2 ], [ 3 , 4 ]] mat2 = mat1 . copy () mat2 [ 0 ][ 0 ] = 100 print ( mat1 ) print ( mat2 ) This is the output we get: [[100, 2], [3, 4]] [[100, 2], [3, 4]] What is happening here? mat1 has also changed! Wasn't copy supposed to get rid of this difficulty? We have a mutable object inside another mutable object. In such a case copy just does a shallow copy; only a new outer-list object is produced. This means that the inner lists in mat1 and mat2 are still the same objects: print ( mat1 [ 0 ] is mat2 [ 0 ]) print ( mat1 [ 1 ] is mat2 [ 1 ]) Both lines print True . In order to make a copy where both the inner and outer lists are new objects, we turn to deepcopy: from copy import deepcopy mat1 = [[ 1 , 2 ], [ 3 , 4 ]] mat2 = deepcopy ( mat1 ) mat2 [ 0 ][ 0 ] = 100 print ( mat1 ) print ( mat2 ) This gives the output: [[1, 2], [3, 4]] [[100, 2], [3, 4]] Finally we have two completely different objects: from copy import deepcopy mat1 = [[ 1 , 2 ], [ 3 , 4 ]] mat2 = deepcopy ( mat1 ) print ( mat1 is not mat2 ) print ( mat1 [ 0 ] is not mat2 [ 0 ]) print ( mat1 [ 1 ] is not mat2 [ 1 ]) All three print True ! deepcopy is a function from the library copy . We won't enter into how it works. Suffice to say that when using nested lists or any collection of mutable objects, use deepcopy if you wish to make a clean copy.","title":"Shallow and Deep Copy"},{"location":"chapter-5/lesson-5.6/","text":"Lesson-5.6 Tuples Introduction A tuple is an immutable sequence of values: family = ( 'father' , 'mother' , 'child' ) print ( type ( family )) print ( isinstance ( family , tuple )) Tuples share a close resemblance to lists. They can be indexed and sliced just like lists: print ( family [ 0 ]) print ( family [: 2 ]) The main point of difference between lists and tuples is that tuples cannot be updated in-place since they are immutable. So, the following operation will throw an error: ##### Alarm! Wrong code snippet! ##### numbers = ( 'one' , 'two' , 'four' ) numbers [ 2 ] = 'three' ##### Alarm! Wrong code snippet! ##### The interpreter throws a TypeError with the following message: TypeError: 'tuple' object does not support item assignment . As a consequence, we cannot append or insert elements into a tuple. Likewise, elements in a tuple cannot be deleted. count and index are the only two methods which are defined for tuple and they carry the usual meaning: numbers = ( 1 , 2 , 3 , 1 , 1 ) print ( numbers . count ( 1 )) print ( numbers . index ( 2 )) We can iterate through a tuple using for : for num in ( 1 , 2 , 3 ): print ( num ) Since tuples are immutable, they are passed by value in functions similar to other immutable types such as strings and numbers. As for functions that operate on tuples, sum , max , min are useful ones. More on Tuples A few more points on tuples. A singleton tuple should be defined as follows: i_am_single = ( 1 , ) print ( len ( i_am_single )) print ( isinstance ( i_am_single , tuple )) Note the presence of a comma after the element. Let us see what happens if it is removed: i_am_single = ( 1 ) print ( isinstance ( i_am_single , int )) It is an integer! A list can be converted into a tuple and vice versa: a_list = [ 1 , 2 , 3 ] a_tuple = tuple ( a_list ) b_tuple = ( 1 , 2 , 3 ) b_list = list ( b_tuple ) A tuple can hold a non-homogeneous sequence of items: a_tuple = ( 1 , 'cool' , True ) Membership can be determined using the in keyword: 1 in ( 1 , 2 , 3 ) 'hello' not in ( 'some' , 'random' , 'sequence' ) Tuples can be nested: a = (( 1 , 2 , 3 ), ( 4 , 5 , 6 )) print ( a [ 0 ][ 2 ]) A tuple can hold mutable objects. a_tuple = ([ 0 , 1 , 2 ], [ 4 , 5 , 6 ]) a_tuple [ 0 ][ 0 ] = 100 The code given above runs without any errors. But we are trying to update the tuple in line-2. Aren't tuples immutable? Though a_tuple is immutable, the element inside it is mutable. In any case, we aren't trying to change the sequence of objects inside the tuple, i.e., a_tuple[0] continues to point to the same object. Let us verify this: a_tuple = ([ 0 , 1 , 2 ], [ 4 , 5 , 6 ]) print ( id ( a_tuple [ 0 ])) a_tuple [ 0 ][ 0 ] = 100 print ( id ( a_tuple [ 0 ])) We see that the id of the element inside the tuple remains unchanged. Thus the identities of the sequence of objects that make up a tuple can never change, and the interpreter will never allow that to change. If the objects inside the sequence are mutable \u2014 such as lists \u2014 then the values that they hold might change, but they continue to retain their identities. Lists and Tuples We have seen the close kinship between lists and tuples. Here is a brief summary that highlights the points of agreement and disagreement: List Tuple Mutable Immutable L = [1, 2, 3] T = (1, 2, 3) Supports indexing and slicing Supports indexing and slicing Supports item assignment Doesn't support item assignment Supported methods: count, index, append, insert, remove, pop and others Supported methods: count, index To get a list: list(obj) To get a tuple: tuple(obj) The partnership between lists and tuples is quite interesting and can be explored further with another example. Populate a list that contains all ordered pairs of positive integers whose product is 100. Note that order matters: (2, 50) and (50, 2) are two different pairs. Solution pairs = [ ] for a in range ( 1 , 101 ): for b in range ( 1 , 101 ): if a * b == 100 : pairs . append (( a , b )) print ( pairs ) pairs is a list of tuples. We could have stored each pair as a list. But a tuple is the better choice here since the two elements in the pair have a well defined relationship and we don't want to accidentally modify them. Packing and Unpacking At first sight, tuples might seem redundant members in the Python family, but they do occupy a significant place. For that, we have to look at tuples in more detail. Consider the following code: T = 1 , 2 , 3 print ( T ) print ( isinstance ( T , tuple )) At first sight, line-1 seems to be an error. We have seen multiple assignment on the same line, perhaps we are two variables short on the LHS? But on execution, we see that there is no error. T is in fact the tuple (1, 2, 3) . This is called tuple packing . The values 1 , 2 and 3 are packed into a tuple. The reverse operation is called sequence unpacking : x, y, z = T print(x, y, z) Here, the tuple T is unpacked into the corresponding variables x , y and z . This is the principle behind multiple assignment. From the Python documentation, we have refer Multiple assignment is a combination of tuple packing and sequence unpacking. x , y , z = 1 , 2 , 3 In the line given above, the RHS is first packed into a tuple and the sequence is then unpacked into the variables x , y and z . But why does the unpacking operation have the qualifier sequence before it? This is because any sequence can be unpacked: l1 , l2 , l3 , l4 = 'good' # string num1 , num2 , num3 = [ 1 , 2 , 3 ] # list b1 , b2 = ( True , False ) # tuple x , y , z = range ( 3 ) # range That's fun! The same operations are invoked when multiple values are returned from functions: def max_min ( a , b ): if a > b : return a , b return b , a x = max_min ( 1 , 2 ) print ( x ) print ( isinstance ( x , tuple )) We see that x is a tuple. In the return statements at lines 3 and 4, multiple values are packed into tuples. So, the function is essentially returning a tuple.","title":"Lesson-5.6"},{"location":"chapter-5/lesson-5.6/#lesson-56","text":"","title":"Lesson-5.6"},{"location":"chapter-5/lesson-5.6/#tuples","text":"","title":"Tuples"},{"location":"chapter-5/lesson-5.6/#introduction","text":"A tuple is an immutable sequence of values: family = ( 'father' , 'mother' , 'child' ) print ( type ( family )) print ( isinstance ( family , tuple )) Tuples share a close resemblance to lists. They can be indexed and sliced just like lists: print ( family [ 0 ]) print ( family [: 2 ]) The main point of difference between lists and tuples is that tuples cannot be updated in-place since they are immutable. So, the following operation will throw an error: ##### Alarm! Wrong code snippet! ##### numbers = ( 'one' , 'two' , 'four' ) numbers [ 2 ] = 'three' ##### Alarm! Wrong code snippet! ##### The interpreter throws a TypeError with the following message: TypeError: 'tuple' object does not support item assignment . As a consequence, we cannot append or insert elements into a tuple. Likewise, elements in a tuple cannot be deleted. count and index are the only two methods which are defined for tuple and they carry the usual meaning: numbers = ( 1 , 2 , 3 , 1 , 1 ) print ( numbers . count ( 1 )) print ( numbers . index ( 2 )) We can iterate through a tuple using for : for num in ( 1 , 2 , 3 ): print ( num ) Since tuples are immutable, they are passed by value in functions similar to other immutable types such as strings and numbers. As for functions that operate on tuples, sum , max , min are useful ones.","title":"Introduction"},{"location":"chapter-5/lesson-5.6/#more-on-tuples","text":"A few more points on tuples. A singleton tuple should be defined as follows: i_am_single = ( 1 , ) print ( len ( i_am_single )) print ( isinstance ( i_am_single , tuple )) Note the presence of a comma after the element. Let us see what happens if it is removed: i_am_single = ( 1 ) print ( isinstance ( i_am_single , int )) It is an integer! A list can be converted into a tuple and vice versa: a_list = [ 1 , 2 , 3 ] a_tuple = tuple ( a_list ) b_tuple = ( 1 , 2 , 3 ) b_list = list ( b_tuple ) A tuple can hold a non-homogeneous sequence of items: a_tuple = ( 1 , 'cool' , True ) Membership can be determined using the in keyword: 1 in ( 1 , 2 , 3 ) 'hello' not in ( 'some' , 'random' , 'sequence' ) Tuples can be nested: a = (( 1 , 2 , 3 ), ( 4 , 5 , 6 )) print ( a [ 0 ][ 2 ]) A tuple can hold mutable objects. a_tuple = ([ 0 , 1 , 2 ], [ 4 , 5 , 6 ]) a_tuple [ 0 ][ 0 ] = 100 The code given above runs without any errors. But we are trying to update the tuple in line-2. Aren't tuples immutable? Though a_tuple is immutable, the element inside it is mutable. In any case, we aren't trying to change the sequence of objects inside the tuple, i.e., a_tuple[0] continues to point to the same object. Let us verify this: a_tuple = ([ 0 , 1 , 2 ], [ 4 , 5 , 6 ]) print ( id ( a_tuple [ 0 ])) a_tuple [ 0 ][ 0 ] = 100 print ( id ( a_tuple [ 0 ])) We see that the id of the element inside the tuple remains unchanged. Thus the identities of the sequence of objects that make up a tuple can never change, and the interpreter will never allow that to change. If the objects inside the sequence are mutable \u2014 such as lists \u2014 then the values that they hold might change, but they continue to retain their identities.","title":"More on Tuples"},{"location":"chapter-5/lesson-5.6/#lists-and-tuples","text":"We have seen the close kinship between lists and tuples. Here is a brief summary that highlights the points of agreement and disagreement: List Tuple Mutable Immutable L = [1, 2, 3] T = (1, 2, 3) Supports indexing and slicing Supports indexing and slicing Supports item assignment Doesn't support item assignment Supported methods: count, index, append, insert, remove, pop and others Supported methods: count, index To get a list: list(obj) To get a tuple: tuple(obj) The partnership between lists and tuples is quite interesting and can be explored further with another example. Populate a list that contains all ordered pairs of positive integers whose product is 100. Note that order matters: (2, 50) and (50, 2) are two different pairs. Solution pairs = [ ] for a in range ( 1 , 101 ): for b in range ( 1 , 101 ): if a * b == 100 : pairs . append (( a , b )) print ( pairs ) pairs is a list of tuples. We could have stored each pair as a list. But a tuple is the better choice here since the two elements in the pair have a well defined relationship and we don't want to accidentally modify them.","title":"Lists and Tuples"},{"location":"chapter-5/lesson-5.6/#packing-and-unpacking","text":"At first sight, tuples might seem redundant members in the Python family, but they do occupy a significant place. For that, we have to look at tuples in more detail. Consider the following code: T = 1 , 2 , 3 print ( T ) print ( isinstance ( T , tuple )) At first sight, line-1 seems to be an error. We have seen multiple assignment on the same line, perhaps we are two variables short on the LHS? But on execution, we see that there is no error. T is in fact the tuple (1, 2, 3) . This is called tuple packing . The values 1 , 2 and 3 are packed into a tuple. The reverse operation is called sequence unpacking : x, y, z = T print(x, y, z) Here, the tuple T is unpacked into the corresponding variables x , y and z . This is the principle behind multiple assignment. From the Python documentation, we have refer Multiple assignment is a combination of tuple packing and sequence unpacking. x , y , z = 1 , 2 , 3 In the line given above, the RHS is first packed into a tuple and the sequence is then unpacked into the variables x , y and z . But why does the unpacking operation have the qualifier sequence before it? This is because any sequence can be unpacked: l1 , l2 , l3 , l4 = 'good' # string num1 , num2 , num3 = [ 1 , 2 , 3 ] # list b1 , b2 = ( True , False ) # tuple x , y , z = range ( 3 ) # range That's fun! The same operations are invoked when multiple values are returned from functions: def max_min ( a , b ): if a > b : return a , b return b , a x = max_min ( 1 , 2 ) print ( x ) print ( isinstance ( x , tuple )) We see that x is a tuple. In the return statements at lines 3 and 4, multiple values are packed into tuples. So, the function is essentially returning a tuple.","title":"Packing and Unpacking"},{"location":"chapter-6/lesson-6.1/","text":"Lesson-6.1 Dictionaries Introduction Let us assume that we want to store the following information in Python: Country Capital Brazil Brasilia Russia Moscow India New Delhi China Beijing South Africa Cape Town A minor geographical observation: South Africa has three capitals; we have only mentioned the legislative capital for convenience. A geopolitical point: these five countries form a part of a block called BRICS [ refer ]. Coming back to Python, a dictionary is possibly the most interesting data structure offered by Python. It is basically a look-up table. This is how we would store the details of the BRICS nations and their capitals: brics = { 'Brazil' : 'Brasilia' , 'Russia' : 'Moscow' , 'India' : 'New Delhi' , 'China' : 'Beijing' , 'South Africa' : 'Cape Town' } A dictionary is a collection of key-value pairs. In the code given above, brics is a dictionary. It has countries mapped to their respective capitals. For instance, 'India' is mapped to 'New Delhi' . Here, 'India' is the key and 'New Delhi' is the value. That is, the country is the key and its capital is the value. A dictionary object is of type dict : 1 2 print ( type ( brics )) print ( isinstance ( brics , dict )) To access the value corresponding to a given key, we do the following: 1 2 print ( brics [ 'India' ], 'is the capital of' , 'India' ) print ( brics [ 'China' ], 'is the capital of' , 'China' ) The value corresponding to a given key can be updated: 1 2 3 4 # Moving to a different capital for South Africa brics [ 'South Africa' ] = 'Pretoria' # Or we could also store all three capitals brics [ 'South Africa' ] = ( 'Pretoria' , 'Cape Town' , 'Bloemfontein' ) New key-value pairs can be added to a dictionary. Let us expand the horizons of our dictionary to include countries outside the BRICS nations. It no longer makes sense to call this brics , so let us create a new dictionary called globe which starts off as a copy of brics . Recall the copy () method that we used to copy lists. A similar method is defined for dictionaries: 1 2 3 4 5 6 7 8 9 brics = { 'Brazil' : 'Brasilia' , 'Russia' : 'Moscow' , 'India' : 'New Delhi' , 'China' : 'Beijing' , 'South Africa' : 'Cape Town' } globe = brics . copy () globe [ 'Spain' ] = 'Madrid' Adding a new key-value pair is as simple as the statement given in line 9 of the code given above. Keys of a dictionary are unique. This means that a dictionary cannot have two or more identical keys mapped to different values. On the other hand, two different keys could have the same value. For example: some_dict = { 'key_1' : 0 , 'key_2' : 0 } Trying to access a key that is not present in the dictionary will result in a KeyError : ##### Alarm! Wrong code snippet! ###### some_dict = { '0' : 'zero' , '1' : 'one' } print ( some_dict [ 0 ]) ##### Alarm! Wrong code snippet! ###### More Examples The key of a dictionary can be any immutable object. There is a small catch here. We will return to this constraint in the next section. Let us look at different combinations key-value pairs that are possible beginning with the basic types: int , str , float , bool : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # int <> int squares = { 0 : 0 , 1 : 1 , 2 : 4 , 3 : 9 , 4 : 16 , 5 : 25 } # str <> int months = { 'Jan' : 31 , 'March' : 31 , 'May' : 31 , 'Nov' : 30 } # int <> str roll_numbers = { 1 : 'CS001' , 2 : 'CS002' , 3 : 'CS003' } # str <> str names = { 'Rohit' : 'Sharma' , 'Saina' : 'Nehwal' } # str <> float constants = { 'pi' : 3.14 , 'e' : 2.71 } # float <> str fractions = { 0.5 : 'half' , 0.25 : 'quarter' , 0.3 : 'one-third' } # int <> bool binary = { 0 : True , 1 : False } Next, we have dictionaries that have list and tuple as the type of their values: 1 2 3 4 # str <> list outcomes = { 'IND VS AUS' : [ 'IND' , 'AUS' , 'IND' , 'IND' ], 'IND VS ENG' : [ 'IND' , 'ENG' ]} # float <> tuple bounds = { 1.7 : ( 1 , 2 ), 4.3 : ( 4 , 5 ), - 1.2 : ( - 2 , - 1 )} Tuples can be keys, provided they don't contain any mutable objects within them: 1 2 3 # tuple <> list T1 , T2 = ( 0 , 1 ), ( 1 , 2 ) random_numbers = { T1 : [ 0.1 , 0.4 , 0.9 ], T2 : [ 1.1 , 1.9 ]} Towards the end, we will look at an example where a tuple cannot be a key. Finally, the richness of dictionaries comes out in the following example: # mixed report_card = { 'name' : 'Ramanujan' , 'age' : 18 , 'school' : 'KV' , 'marks' : ( 75 , 80 , 60 , 95 , 100 ) } More on Keys Earlier, we have mentioned that the keys of dictionaries have to be immutable, but this statement is not entirely accurate. In this section, we will explore why. What happens if we use a list as a key? 1 2 3 4 ##### Alarm! Wrong code snippet ##### some_list = [ 0 , 1 ] bad_dict = { some_list : 0 } ##### Alarm! Wrong code snippet ##### It throws a TypeError with the following message: unhashable type: 'list' . A list cannot be a key in a dictionary; but the error message doesn't talk about immutability, instead it says that the list type is unhashable. A more accurate statement about keys in a dictionary is given below: The keys of a dictionary must be hashable. To understand what we mean by the term hashable, we shall briefly look at the way Python implements dictionaries. The following section on hash tables is a bit involved and can be skipped. Hash Tables Python dictionaries are implemented using a data structure called a hash table. It is best to think about a hash table as a book-rack that has a number of rows. Picture the key-value pairs as books that are going to be stored in these racks. To access a book, we need to know the row number in which it is present. This is where the idea of a hash function comes in. The hash function is denoted by \\(h\\) and converts the key to the row number. The hash function accepts a key \\(k\\) as input and returns a value, \\(h(k)\\) , as output. This is called the hash value. In our analogy, the hash value is synonymous with the rack number. Once we know the rack number, the book (key-value) stored in it can be easily retrieved. The description is somewhat naive, but you get the point. Now, an object in Python is hashable if it has a hash value which never changes during its lifetime and can be compared to other objects. Most of the immutable objects that we have seen so far are hashable: int , float , str , bool . Mutable containers such as lists are not hashable. So, can we just go back to the original definition and claim that all immutable objects can be used as keys in dictionaries? No! Consider the following example: 1 2 3 4 ##### Alarm! Wrong code snippet ##### some_tuple = ([ 0 , 1 ], [ 2 , 3 ]) bad_dict = { some_tuple : 0 } ##### Alarm! Wrong code snippet ##### Though some_tuple is immutable, it contains a sequence of lists which are mutable. According to the Python documentation, immutable containers are hashable only if their elements are hashable. So, some_tuple is not hashable, and hence it cannot be used as a key! For a better explanation, check out the docs . Iterating over Dictionaries We can iterate over the keys of a dictionary: 1 2 3 squares = { 0 : 0 , 1 : 1 , 2 : 4 , 3 : 9 , 4 : 16 , 5 : 25 } # key is a number, value is its square for key in squares . keys (): print ( f 'The square of { key } is { squares [ key ] } ' ) squares . keys () returns a sequence of keys over which we can iterate. Python makes things even more simple and lets us drop the keys method. 1 2 3 squares = { 0 : 0 , 1 : 1 , 2 : 4 , 3 : 9 , 4 : 16 , 5 : 25 } # key is a number, value is its square for key in squares : print ( f 'The square of { key } is { squares [ key ] } ' ) We can also iterate over the key-value pairs in a dictionary: 1 2 3 squares = { 0 : 0 , 1 : 1 , 2 : 4 , 3 : 9 , 4 : 16 , 5 : 25 } # key is a number, value is its square for key , value in squares . items (): print ( f 'The square of { key } is { value } ' ) Growing a Dictionary An empty dictionary can be defined in one of the following ways: 1 2 3 4 D1 = dict () D1 [ 0 ] = 1 D2 = { } D2 [ 0 ] = 1 Let us now solve the following problem: Ceate a dictionary from a list of words that maps words to their lengths. Solution words = [ 'interstellar' , 'dunkirk' , 'inception' , 'tenet' ] lengths = dict () for word in words : lengths [ word ] = len ( word ) print ( lengths ) A piece of trivia: what is common among the words in the list words ? Mutability Like lists dictionaries are mutable objects. To see the mutability of dict objects in action, consider the following code: dict_1 = { 'one' : 1 , 'two' : 2 , 'three' : 3 } dict_2 = dict_1 dict_2 [ 'four' ] = 4 print ( dict_1 , dict_2 ) print ( dict_1 is dict_2 ) We see that dict_2 is alias of dict_1 and both point to the same object. If we want a new dict object with the same contents as dict_1 , we could either use the copy () method or the dict built-in function: dict_1 = { 'one' : 1 , 'two' : 2 , 'three' : 3 } dict_2 = dict_1 . copy () # dict(dict_1) also works dict_2 [ 'four' ] = 4 print ( dict_1 , dict_2 ) print ( dict_1 is not dict_2 ) The last line prints True which confirms that we have two different objects. So modifying one doesn't affect the other. But note that copy () only produces a shallow copy. As long as the values are immutable, this doesn't matter. But if we have mutable values, then we have a problem: dict_1 = { 'one' : [ 1 ], 'two' : [ 1 , 1 ], 'three' : [ 1 , 1 , 1 ]} dict_2 = dict_1 . copy () dict_2 [ 'one' ] . append ( 100 ) print ( dict_1 , dict_2 ) print ( dict_1 is not dict_2 ) print ( dict_1 [ 'one' ] is dict_2 [ 'one' ]) Here, we see that the value corresponding to the key 'one' in both dictionaries gets affected. This is because dict_1 [ 'one' ] and dict_2 [ 'one' ] are still the same object. This can be seen from the last statement of the code given above. To set this right, we need to do a deepcopy: from copy import deepcopy dict_1 = { 'one' : [ 1 ], 'two' : [ 1 , 1 ], 'three' : [ 1 , 1 , 1 ]} dict_2 = deepcopy ( dict_1 ) dict_2 [ 'one' ] . append ( 100 ) print ( dict_1 , dict_2 ) print ( dict_1 is not dict_2 ) print ( dict_1 [ 'one' ] is not dict_2 [ 'one' ])","title":"Lesson-6.1"},{"location":"chapter-6/lesson-6.1/#lesson-61","text":"","title":"Lesson-6.1"},{"location":"chapter-6/lesson-6.1/#dictionaries","text":"","title":"Dictionaries"},{"location":"chapter-6/lesson-6.1/#introduction","text":"Let us assume that we want to store the following information in Python: Country Capital Brazil Brasilia Russia Moscow India New Delhi China Beijing South Africa Cape Town A minor geographical observation: South Africa has three capitals; we have only mentioned the legislative capital for convenience. A geopolitical point: these five countries form a part of a block called BRICS [ refer ]. Coming back to Python, a dictionary is possibly the most interesting data structure offered by Python. It is basically a look-up table. This is how we would store the details of the BRICS nations and their capitals: brics = { 'Brazil' : 'Brasilia' , 'Russia' : 'Moscow' , 'India' : 'New Delhi' , 'China' : 'Beijing' , 'South Africa' : 'Cape Town' } A dictionary is a collection of key-value pairs. In the code given above, brics is a dictionary. It has countries mapped to their respective capitals. For instance, 'India' is mapped to 'New Delhi' . Here, 'India' is the key and 'New Delhi' is the value. That is, the country is the key and its capital is the value. A dictionary object is of type dict : 1 2 print ( type ( brics )) print ( isinstance ( brics , dict )) To access the value corresponding to a given key, we do the following: 1 2 print ( brics [ 'India' ], 'is the capital of' , 'India' ) print ( brics [ 'China' ], 'is the capital of' , 'China' ) The value corresponding to a given key can be updated: 1 2 3 4 # Moving to a different capital for South Africa brics [ 'South Africa' ] = 'Pretoria' # Or we could also store all three capitals brics [ 'South Africa' ] = ( 'Pretoria' , 'Cape Town' , 'Bloemfontein' ) New key-value pairs can be added to a dictionary. Let us expand the horizons of our dictionary to include countries outside the BRICS nations. It no longer makes sense to call this brics , so let us create a new dictionary called globe which starts off as a copy of brics . Recall the copy () method that we used to copy lists. A similar method is defined for dictionaries: 1 2 3 4 5 6 7 8 9 brics = { 'Brazil' : 'Brasilia' , 'Russia' : 'Moscow' , 'India' : 'New Delhi' , 'China' : 'Beijing' , 'South Africa' : 'Cape Town' } globe = brics . copy () globe [ 'Spain' ] = 'Madrid' Adding a new key-value pair is as simple as the statement given in line 9 of the code given above. Keys of a dictionary are unique. This means that a dictionary cannot have two or more identical keys mapped to different values. On the other hand, two different keys could have the same value. For example: some_dict = { 'key_1' : 0 , 'key_2' : 0 } Trying to access a key that is not present in the dictionary will result in a KeyError : ##### Alarm! Wrong code snippet! ###### some_dict = { '0' : 'zero' , '1' : 'one' } print ( some_dict [ 0 ]) ##### Alarm! Wrong code snippet! ######","title":"Introduction"},{"location":"chapter-6/lesson-6.1/#more-examples","text":"The key of a dictionary can be any immutable object. There is a small catch here. We will return to this constraint in the next section. Let us look at different combinations key-value pairs that are possible beginning with the basic types: int , str , float , bool : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # int <> int squares = { 0 : 0 , 1 : 1 , 2 : 4 , 3 : 9 , 4 : 16 , 5 : 25 } # str <> int months = { 'Jan' : 31 , 'March' : 31 , 'May' : 31 , 'Nov' : 30 } # int <> str roll_numbers = { 1 : 'CS001' , 2 : 'CS002' , 3 : 'CS003' } # str <> str names = { 'Rohit' : 'Sharma' , 'Saina' : 'Nehwal' } # str <> float constants = { 'pi' : 3.14 , 'e' : 2.71 } # float <> str fractions = { 0.5 : 'half' , 0.25 : 'quarter' , 0.3 : 'one-third' } # int <> bool binary = { 0 : True , 1 : False } Next, we have dictionaries that have list and tuple as the type of their values: 1 2 3 4 # str <> list outcomes = { 'IND VS AUS' : [ 'IND' , 'AUS' , 'IND' , 'IND' ], 'IND VS ENG' : [ 'IND' , 'ENG' ]} # float <> tuple bounds = { 1.7 : ( 1 , 2 ), 4.3 : ( 4 , 5 ), - 1.2 : ( - 2 , - 1 )} Tuples can be keys, provided they don't contain any mutable objects within them: 1 2 3 # tuple <> list T1 , T2 = ( 0 , 1 ), ( 1 , 2 ) random_numbers = { T1 : [ 0.1 , 0.4 , 0.9 ], T2 : [ 1.1 , 1.9 ]} Towards the end, we will look at an example where a tuple cannot be a key. Finally, the richness of dictionaries comes out in the following example: # mixed report_card = { 'name' : 'Ramanujan' , 'age' : 18 , 'school' : 'KV' , 'marks' : ( 75 , 80 , 60 , 95 , 100 ) }","title":"More Examples"},{"location":"chapter-6/lesson-6.1/#more-on-keys","text":"Earlier, we have mentioned that the keys of dictionaries have to be immutable, but this statement is not entirely accurate. In this section, we will explore why. What happens if we use a list as a key? 1 2 3 4 ##### Alarm! Wrong code snippet ##### some_list = [ 0 , 1 ] bad_dict = { some_list : 0 } ##### Alarm! Wrong code snippet ##### It throws a TypeError with the following message: unhashable type: 'list' . A list cannot be a key in a dictionary; but the error message doesn't talk about immutability, instead it says that the list type is unhashable. A more accurate statement about keys in a dictionary is given below: The keys of a dictionary must be hashable. To understand what we mean by the term hashable, we shall briefly look at the way Python implements dictionaries. The following section on hash tables is a bit involved and can be skipped.","title":"More on Keys"},{"location":"chapter-6/lesson-6.1/#hash-tables","text":"Python dictionaries are implemented using a data structure called a hash table. It is best to think about a hash table as a book-rack that has a number of rows. Picture the key-value pairs as books that are going to be stored in these racks. To access a book, we need to know the row number in which it is present. This is where the idea of a hash function comes in. The hash function is denoted by \\(h\\) and converts the key to the row number. The hash function accepts a key \\(k\\) as input and returns a value, \\(h(k)\\) , as output. This is called the hash value. In our analogy, the hash value is synonymous with the rack number. Once we know the rack number, the book (key-value) stored in it can be easily retrieved. The description is somewhat naive, but you get the point. Now, an object in Python is hashable if it has a hash value which never changes during its lifetime and can be compared to other objects. Most of the immutable objects that we have seen so far are hashable: int , float , str , bool . Mutable containers such as lists are not hashable. So, can we just go back to the original definition and claim that all immutable objects can be used as keys in dictionaries? No! Consider the following example: 1 2 3 4 ##### Alarm! Wrong code snippet ##### some_tuple = ([ 0 , 1 ], [ 2 , 3 ]) bad_dict = { some_tuple : 0 } ##### Alarm! Wrong code snippet ##### Though some_tuple is immutable, it contains a sequence of lists which are mutable. According to the Python documentation, immutable containers are hashable only if their elements are hashable. So, some_tuple is not hashable, and hence it cannot be used as a key! For a better explanation, check out the docs .","title":"Hash Tables"},{"location":"chapter-6/lesson-6.1/#iterating-over-dictionaries","text":"We can iterate over the keys of a dictionary: 1 2 3 squares = { 0 : 0 , 1 : 1 , 2 : 4 , 3 : 9 , 4 : 16 , 5 : 25 } # key is a number, value is its square for key in squares . keys (): print ( f 'The square of { key } is { squares [ key ] } ' ) squares . keys () returns a sequence of keys over which we can iterate. Python makes things even more simple and lets us drop the keys method. 1 2 3 squares = { 0 : 0 , 1 : 1 , 2 : 4 , 3 : 9 , 4 : 16 , 5 : 25 } # key is a number, value is its square for key in squares : print ( f 'The square of { key } is { squares [ key ] } ' ) We can also iterate over the key-value pairs in a dictionary: 1 2 3 squares = { 0 : 0 , 1 : 1 , 2 : 4 , 3 : 9 , 4 : 16 , 5 : 25 } # key is a number, value is its square for key , value in squares . items (): print ( f 'The square of { key } is { value } ' )","title":"Iterating over Dictionaries"},{"location":"chapter-6/lesson-6.1/#growing-a-dictionary","text":"An empty dictionary can be defined in one of the following ways: 1 2 3 4 D1 = dict () D1 [ 0 ] = 1 D2 = { } D2 [ 0 ] = 1 Let us now solve the following problem: Ceate a dictionary from a list of words that maps words to their lengths. Solution words = [ 'interstellar' , 'dunkirk' , 'inception' , 'tenet' ] lengths = dict () for word in words : lengths [ word ] = len ( word ) print ( lengths ) A piece of trivia: what is common among the words in the list words ?","title":"Growing a Dictionary"},{"location":"chapter-6/lesson-6.1/#mutability","text":"Like lists dictionaries are mutable objects. To see the mutability of dict objects in action, consider the following code: dict_1 = { 'one' : 1 , 'two' : 2 , 'three' : 3 } dict_2 = dict_1 dict_2 [ 'four' ] = 4 print ( dict_1 , dict_2 ) print ( dict_1 is dict_2 ) We see that dict_2 is alias of dict_1 and both point to the same object. If we want a new dict object with the same contents as dict_1 , we could either use the copy () method or the dict built-in function: dict_1 = { 'one' : 1 , 'two' : 2 , 'three' : 3 } dict_2 = dict_1 . copy () # dict(dict_1) also works dict_2 [ 'four' ] = 4 print ( dict_1 , dict_2 ) print ( dict_1 is not dict_2 ) The last line prints True which confirms that we have two different objects. So modifying one doesn't affect the other. But note that copy () only produces a shallow copy. As long as the values are immutable, this doesn't matter. But if we have mutable values, then we have a problem: dict_1 = { 'one' : [ 1 ], 'two' : [ 1 , 1 ], 'three' : [ 1 , 1 , 1 ]} dict_2 = dict_1 . copy () dict_2 [ 'one' ] . append ( 100 ) print ( dict_1 , dict_2 ) print ( dict_1 is not dict_2 ) print ( dict_1 [ 'one' ] is dict_2 [ 'one' ]) Here, we see that the value corresponding to the key 'one' in both dictionaries gets affected. This is because dict_1 [ 'one' ] and dict_2 [ 'one' ] are still the same object. This can be seen from the last statement of the code given above. To set this right, we need to do a deepcopy: from copy import deepcopy dict_1 = { 'one' : [ 1 ], 'two' : [ 1 , 1 ], 'three' : [ 1 , 1 , 1 ]} dict_2 = deepcopy ( dict_1 ) dict_2 [ 'one' ] . append ( 100 ) print ( dict_1 , dict_2 ) print ( dict_1 is not dict_2 ) print ( dict_1 [ 'one' ] is not dict_2 [ 'one' ])","title":"Mutability"},{"location":"chapter-6/lesson-6.2/","text":"Lesson-6.2 Text processing The following paragraph is an excerpt from a talk given by Guido. The full text can be found here . In reality, programming languages are how programmers express and communicate ideas \u2014 and the audience for those ideas is other programmers, not computers. The reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops. In fact, ideas expressed in a programming language also often reach the end users of the program \u2014 people who will never read or even know about the program, but who nevertheless are affected by it. Text processing plays an important role in analyzing text data. Given a piece of text, the following are some of the basic questions that we can ask: How many sentences are there in the text? How many words are there in the text? How many of them are unique? Which word appears the most number of times? Are these meaningful questions to ask? Do they lead us anywhere? Yes, they do! Consider the task of classifying articles. Some sample categories could be: lifestyle, science and technology, literature, films. If we want to understand what category an article falls under, one way to go about it is to read the entire article. We can do it for one or two articles, but what if we have to do this for hundreds of them? A better solution would be to computationally process each article, find the top five most common words and use that to get an idea of what the text is about. We could program a solution to do exactly this. In the next few sections, we will gradually write, one step at a time, the code that answers all of the above questions. Follow along with an IDE or text editor of your choice and run the code at each step. Let's start off by storing the string in a variable text . 1 text = \"In reality, programming languages are how programmers express and communicate ideas \u2014 and the audience for those ideas is other programmers, not computers. The reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops. In fact, ideas expressed in a programming language also often reach the end users of the program \u2014 people who will never read or even know about the program, but who nevertheless are affected by it.\" Number of sentences Sentences could end with one of the following tokens: full stop, exclamation mark or question mark. For simplicity, let us assume that all sentences in our text ends with a full stop. We can split the string using full stop as a delimiter to get a list of sentences: 2 sentences = text . split ( '.' ) Let's now look into the list using some temporary code. It's very important as a programmer to know what your code is doing and printing out the contents of your variables will give a good look of what's happening. # Prints one sentence in each line for sentence in sentences : print ( sentence ) print ( f 'There are { len ( sentences ) } sentences in this text.' ) Output 1 2 3 4 5 In reality, programming languages are how programmers express and communicate ideas \u2014 and the audience for those ideas is other programmers, not computers The reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops In fact, ideas expressed in a programming language also often reach the end users of the program \u2014 people who will never read or even know about the program, but who nevertheless are affected by it There are 4 sentences in this text. Notice that there are only three sentences, but we get the output to be four in the last line. On closer inspection, we see that sentences [ - 1 ] is not a sentence but an empty string. This is because, when a string is split using a delimiter which is present in the string, two substrings get generated, one to the left of the delimiter and the other to its right. As the full stop is the last character in the text, the substring to its right is an empty string. One way to correct this is to remove all empty strings in sentences : 3 4 5 while '' in sentences : sentences . remove ( '' ) print ( f 'There are { len ( sentences ) } sentences in this text.' ) Output There are 3 sentences in this text. One problem solved! Number of words To get the number of words, we can split each sentence by space: 6 7 8 9 words = [ ] for sentence in sentences : words_ = sentence . split ( ' ' ) # words_ contains words in sentence words . extend ( words_ ) # words is the collection of all words If we print out len ( words ) , we get the number of words to be 86. Is that correct? wordcounter.net claims that there are 82 words in this text. Clearly, something is wrong with our code. Let us print each word along with its index in separate lines and see what we have: for index , word in enumerate ( words ): print ( index , word ) Sifting through the output, we notice the following offenders: 11 \u2014 23 49 67 \u2014 Indices 11 and 67 are em dashes (\u2014) while 23 and 49 correspond to empty strings. Since we have two different characters to remove, let us clean up the list in the following way: 10 11 12 13 14 proc_words = [ ] for word in words : if not ( word == '' or word == '\u2014' ): proc_words . append ( word ) print ( f 'There are { len ( proc_words ) } words in this text' ) And we have 82 words as expected. One more problem solved! Number of Unique Words You might be wondering why this lesson has come under Chapter 6 if there are no dictionaries floating around. This section will assuage that worry, because we will now use a dictionary to keep track of the number of unique words along with their frequency. 15 16 17 18 19 20 uniq_words = dict () for word in proc_words : if word not in uniq_words : uniq_words [ word ] = 0 uniq_words [ word ] += 1 print ( f 'There are { len ( uniq_words ) } unique words in this text' ) Apparently, there are 62 unique words in our text. Upon manual inspection, the word \"programmers\" occurs four times in the text. What does our dict have to say? print ( uniq_words [ 'programmers' ]) We get 2 as the output, another wrong answer! Programming doesn't seem like magic after all. We are making mistakes far too often. Note that this is not the exception, but the norm. The nice part of making mistakes is that they are almost always an opportunity to learn something. An error in the code is hidden knowledge, an insight into a flaw in our logic that we are yet to unmask. Now, back to the drawing board. Let us search for all entries in the list proc_words that have the substring \"programmers\" in them: for word in proc_words : if 'programmers' in word : print ( word ) Output programmers programmers, programmers programmers, So, the problem is with the special character: comma. Another problem is introduced by the capitalization of words, usually at the beginning of sentences. Now that the problems have been identified, let us go ahead and fix them. Of course, this means we have to go back and modify the code we have already written. This is a perfectly normal process in programming - You start writing your solution, you gain a new insight in the process, you go back and change what you had just written (or sometimes even throw away the whole thing and start from scratch!). Let's now generate proc_words the right way: 10 11 12 13 14 15 16 17 proc_words = [ ] for word_ in words : word = word_ . lower () if not ( word == '' or word == '\u2014' ): if not word_ . isalnum (): word = word_ [: - 1 ] proc_words . append ( word ) print ( f 'There are { len ( proc_words ) } words in this text' ) Several things are happening here. In line 12, every word is converted to lower case. In line , em dashes and empty strings are being ignored. Line 14 checks if a word contains a special character. If it does, then it is unburdened of that dangling character in line 15. Here we assume that special characters usually appear at the end of the word. In this text, there are two cases: \"programmers,\" and \"reason:\". All processed words are finally added to proc_words in line 16. Now that we have a cleaned up proc_words , we can go back and generate uniq_words : 18 19 20 21 22 23 uniq_words = dict () for word in proc_words : if word not in uniq_words : uniq_words [ word ] = 0 uniq_words [ word ] += 1 print ( f 'There are { len ( uniq_words ) } unique words in this text' ) Lovely! There are 58 unique words in the text. We can check if this is right by printing all the words and their counts: for word , freq in uniq_words . items (): print ( word , freq ) We can see that there is no erroneous repetition of any word. As a test, we can also see if the sum of the counts gives back the total number of words: total = 0 for word in uniq_words : total += uniq_words [ word ] assert total == len ( proc_words ) As the code doesn't raise any AssertionError , we are correct! Frequent Words Now onto the last problem - let us find the top three most frequently occurring words: 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 first_word = second_word = third_word = '' first_val = second_val = third_val = 0 for word , freq in uniq_words . items (): if freq > first_val : first_val , second_val , third_val = freq , first_val , second_val first_word , second_word , third_word = word , first_word , second_word elif freq > second_val and freq < first_val : second_val , third_val = freq , second_val second_word , third_word = word , second_word elif freq > third_val and freq < second_val : third_val = freq third_word = word print ( first_word , first_val ) print ( second_word , second_val ) print ( third_word , third_val ) output the 6 programmers 4 in 3 We see that \"programmers\" is the second most frequent word. First and third most frequent words are \"the\" and \"in\" respectively. Such common words are called stop-words. If they are removed from the text, \"programmers\" becomes the most frequent non-trivial word. So, without reading this text, one can guess that it should be something about programmers, thanks to Python! Summary The main takeaway from this lesson is the kind of mistakes we made and the way we fixed each one of them. In almost every problem, we started off with a solution, then tested it. We figured out that something was wrong, so we went back and tried to fix the problem.","title":"Lesson-6.2"},{"location":"chapter-6/lesson-6.2/#lesson-62","text":"","title":"Lesson-6.2"},{"location":"chapter-6/lesson-6.2/#text-processing","text":"The following paragraph is an excerpt from a talk given by Guido. The full text can be found here . In reality, programming languages are how programmers express and communicate ideas \u2014 and the audience for those ideas is other programmers, not computers. The reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops. In fact, ideas expressed in a programming language also often reach the end users of the program \u2014 people who will never read or even know about the program, but who nevertheless are affected by it. Text processing plays an important role in analyzing text data. Given a piece of text, the following are some of the basic questions that we can ask: How many sentences are there in the text? How many words are there in the text? How many of them are unique? Which word appears the most number of times? Are these meaningful questions to ask? Do they lead us anywhere? Yes, they do! Consider the task of classifying articles. Some sample categories could be: lifestyle, science and technology, literature, films. If we want to understand what category an article falls under, one way to go about it is to read the entire article. We can do it for one or two articles, but what if we have to do this for hundreds of them? A better solution would be to computationally process each article, find the top five most common words and use that to get an idea of what the text is about. We could program a solution to do exactly this. In the next few sections, we will gradually write, one step at a time, the code that answers all of the above questions. Follow along with an IDE or text editor of your choice and run the code at each step. Let's start off by storing the string in a variable text . 1 text = \"In reality, programming languages are how programmers express and communicate ideas \u2014 and the audience for those ideas is other programmers, not computers. The reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops. In fact, ideas expressed in a programming language also often reach the end users of the program \u2014 people who will never read or even know about the program, but who nevertheless are affected by it.\"","title":"Text processing"},{"location":"chapter-6/lesson-6.2/#number-of-sentences","text":"Sentences could end with one of the following tokens: full stop, exclamation mark or question mark. For simplicity, let us assume that all sentences in our text ends with a full stop. We can split the string using full stop as a delimiter to get a list of sentences: 2 sentences = text . split ( '.' ) Let's now look into the list using some temporary code. It's very important as a programmer to know what your code is doing and printing out the contents of your variables will give a good look of what's happening. # Prints one sentence in each line for sentence in sentences : print ( sentence ) print ( f 'There are { len ( sentences ) } sentences in this text.' )","title":"Number of sentences"},{"location":"chapter-6/lesson-6.2/#output","text":"1 2 3 4 5 In reality, programming languages are how programmers express and communicate ideas \u2014 and the audience for those ideas is other programmers, not computers The reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops In fact, ideas expressed in a programming language also often reach the end users of the program \u2014 people who will never read or even know about the program, but who nevertheless are affected by it There are 4 sentences in this text. Notice that there are only three sentences, but we get the output to be four in the last line. On closer inspection, we see that sentences [ - 1 ] is not a sentence but an empty string. This is because, when a string is split using a delimiter which is present in the string, two substrings get generated, one to the left of the delimiter and the other to its right. As the full stop is the last character in the text, the substring to its right is an empty string. One way to correct this is to remove all empty strings in sentences : 3 4 5 while '' in sentences : sentences . remove ( '' ) print ( f 'There are { len ( sentences ) } sentences in this text.' )","title":"Output"},{"location":"chapter-6/lesson-6.2/#output_1","text":"There are 3 sentences in this text. One problem solved!","title":"Output"},{"location":"chapter-6/lesson-6.2/#number-of-words","text":"To get the number of words, we can split each sentence by space: 6 7 8 9 words = [ ] for sentence in sentences : words_ = sentence . split ( ' ' ) # words_ contains words in sentence words . extend ( words_ ) # words is the collection of all words If we print out len ( words ) , we get the number of words to be 86. Is that correct? wordcounter.net claims that there are 82 words in this text. Clearly, something is wrong with our code. Let us print each word along with its index in separate lines and see what we have: for index , word in enumerate ( words ): print ( index , word ) Sifting through the output, we notice the following offenders: 11 \u2014 23 49 67 \u2014 Indices 11 and 67 are em dashes (\u2014) while 23 and 49 correspond to empty strings. Since we have two different characters to remove, let us clean up the list in the following way: 10 11 12 13 14 proc_words = [ ] for word in words : if not ( word == '' or word == '\u2014' ): proc_words . append ( word ) print ( f 'There are { len ( proc_words ) } words in this text' ) And we have 82 words as expected. One more problem solved!","title":"Number of words"},{"location":"chapter-6/lesson-6.2/#number-of-unique-words","text":"You might be wondering why this lesson has come under Chapter 6 if there are no dictionaries floating around. This section will assuage that worry, because we will now use a dictionary to keep track of the number of unique words along with their frequency. 15 16 17 18 19 20 uniq_words = dict () for word in proc_words : if word not in uniq_words : uniq_words [ word ] = 0 uniq_words [ word ] += 1 print ( f 'There are { len ( uniq_words ) } unique words in this text' ) Apparently, there are 62 unique words in our text. Upon manual inspection, the word \"programmers\" occurs four times in the text. What does our dict have to say? print ( uniq_words [ 'programmers' ]) We get 2 as the output, another wrong answer! Programming doesn't seem like magic after all. We are making mistakes far too often. Note that this is not the exception, but the norm. The nice part of making mistakes is that they are almost always an opportunity to learn something. An error in the code is hidden knowledge, an insight into a flaw in our logic that we are yet to unmask. Now, back to the drawing board. Let us search for all entries in the list proc_words that have the substring \"programmers\" in them: for word in proc_words : if 'programmers' in word : print ( word )","title":"Number of Unique Words"},{"location":"chapter-6/lesson-6.2/#output_2","text":"programmers programmers, programmers programmers, So, the problem is with the special character: comma. Another problem is introduced by the capitalization of words, usually at the beginning of sentences. Now that the problems have been identified, let us go ahead and fix them. Of course, this means we have to go back and modify the code we have already written. This is a perfectly normal process in programming - You start writing your solution, you gain a new insight in the process, you go back and change what you had just written (or sometimes even throw away the whole thing and start from scratch!). Let's now generate proc_words the right way: 10 11 12 13 14 15 16 17 proc_words = [ ] for word_ in words : word = word_ . lower () if not ( word == '' or word == '\u2014' ): if not word_ . isalnum (): word = word_ [: - 1 ] proc_words . append ( word ) print ( f 'There are { len ( proc_words ) } words in this text' ) Several things are happening here. In line 12, every word is converted to lower case. In line , em dashes and empty strings are being ignored. Line 14 checks if a word contains a special character. If it does, then it is unburdened of that dangling character in line 15. Here we assume that special characters usually appear at the end of the word. In this text, there are two cases: \"programmers,\" and \"reason:\". All processed words are finally added to proc_words in line 16. Now that we have a cleaned up proc_words , we can go back and generate uniq_words : 18 19 20 21 22 23 uniq_words = dict () for word in proc_words : if word not in uniq_words : uniq_words [ word ] = 0 uniq_words [ word ] += 1 print ( f 'There are { len ( uniq_words ) } unique words in this text' ) Lovely! There are 58 unique words in the text. We can check if this is right by printing all the words and their counts: for word , freq in uniq_words . items (): print ( word , freq ) We can see that there is no erroneous repetition of any word. As a test, we can also see if the sum of the counts gives back the total number of words: total = 0 for word in uniq_words : total += uniq_words [ word ] assert total == len ( proc_words ) As the code doesn't raise any AssertionError , we are correct!","title":"Output"},{"location":"chapter-6/lesson-6.2/#frequent-words","text":"Now onto the last problem - let us find the top three most frequently occurring words: 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 first_word = second_word = third_word = '' first_val = second_val = third_val = 0 for word , freq in uniq_words . items (): if freq > first_val : first_val , second_val , third_val = freq , first_val , second_val first_word , second_word , third_word = word , first_word , second_word elif freq > second_val and freq < first_val : second_val , third_val = freq , second_val second_word , third_word = word , second_word elif freq > third_val and freq < second_val : third_val = freq third_word = word print ( first_word , first_val ) print ( second_word , second_val ) print ( third_word , third_val )","title":"Frequent Words"},{"location":"chapter-6/lesson-6.2/#output_3","text":"the 6 programmers 4 in 3 We see that \"programmers\" is the second most frequent word. First and third most frequent words are \"the\" and \"in\" respectively. Such common words are called stop-words. If they are removed from the text, \"programmers\" becomes the most frequent non-trivial word. So, without reading this text, one can guess that it should be something about programmers, thanks to Python!","title":"output"},{"location":"chapter-6/lesson-6.2/#summary","text":"The main takeaway from this lesson is the kind of mistakes we made and the way we fixed each one of them. In almost every problem, we started off with a solution, then tested it. We figured out that something was wrong, so we went back and tried to fix the problem.","title":"Summary"},{"location":"chapter-6/lesson-6.3/","text":"Lesson-6.3 Dictionaries Pangrams and Dictionaries Assume that we wish to compute the following mapping between letters of the English alphabet and numbers from 1 to 26: Letter Number a 1 b 2 ... ... z 26 Each letter in the alphabet is mapped to a unique number from 1 to 26. In the table given above, the mapping is a simple linear mapping: 'a' is mapped to 1 , 'b' to 2 and so on. This mapping can be computed in the most uninteresting and lousy way given below: 1 2 3 4 5 6 7 8 9 10 mapping = { 'a' : 1 , 'b' : 2 , 'c' : 3 , 'd' : 4 , 'e' : 5 , 'f' : 6 , 'g' : 7 , 'h' : 8 , 'i' : 9 , 'j' : 10 , 'k' : 11 , 'l' : 12 , 'm' : 13 , 'n' : 14 , 'o' : 15 , 'p' : 16 , 'q' : 17 , 'r' : 18 , 's' : 19 , 't' : 20 , 'u' : 21 , 'v' : 22 , 'w' : 23 , 'x' : 24 , 'y' : 25 , 'z' : 26 } for letter , count in mapping . items (): print ( letter , count ) Phew! If you type the whole thing out, it will take you two full dull minutes. Your finger will curse you for the mechanical key-presses while your eyes will chide you for staring at the screen without blinking. You could cheese your way past the challenge by hitting the clipboard button and pasting it but will you really open up this textbook everytime you need to make this mapping? Let us try a roundabout but interesting way. Consider the following line: the quick brown fox jumps over the lazy dog This sentence is called a pangram. A pangram is a sentence that uses all the letters of the alphabet. Does that ring any bell? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 pangram = 'the quick brown fox jumps over the lazy dog' words = pangram . split ( ' ' ) # get list of words in the sentence letters = '' . join ( words ) # join the words back; eliminates spaces sorted_letters = sorted ( letters ) # sort letters mapping , count = dict (), 0 for letter in sorted_letters : # check if letter is not present in dict # to avoid counting same letter multiple times if letter not in mapping : count += 1 mapping [ letter ] = count # map the letter to count for letter , count in mapping . items (): print ( letter , count ) Plenty of things to learn from those 14 lines of code. Not all diversions are bad. Now that we have an interesting dictionary in place, let us jump into some methods that are bundled along with dict . Dictionary Methods We have already seen keys and items . Both these are methods that return a view object over which we can iterate. According to the Python documentation , [View objects] provide a dynamic view on the dictionary's entries, which means that when the dictionary changes, the view reflects these changes. 15 16 keys = mapping . keys () print ( keys ) This gives the following output: dict_keys(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']) Using the list () function, both the keys and items views can be converted into lists: 17 18 19 20 keys_list = list ( mapping . keys ()) print ( keys ) items_list = list ( mapping . items ()) print ( items ) The output is as follows: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'] [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6), ('g', 7), ('h', 8), ('i', 9), ('j', 10), ('k', 11), ('l', 12), ('m', 13), ('n', 14), ('o', 15), ('p', 16), ('q', 17), ('r', 18), ('s', 19), ('t', 20), ('u', 21), ('v', 22), ('w', 23), ('x', 24), ('y', 25), ('z', 26)] keys_list is a list of keys in the dictionary mapping . items_list is a list of tuples, where each tuple is a key-value pair. Another useful method is values . This returns a view on the values: 21 22 view = mapping . values () view_list = list ( view ) All three views - keys , items , values - support membership tests: 23 24 25 print ( 'a' in mapping . keys ()) print ( 1 in mapping . values ()) print (( 'a' , 1 ) in mapping . items ()) All three return True . Membership tests for keys can be done in a simpler way: 26 27 28 print ( 'a' in mapping ) print ( 'x' in mapping ) print ( 'ab' not in mapping ) Note that we dropped the keys method and it still worked! Now, to delete a key from a dictionary, we use the familiar pop method: 29 30 31 32 mapping [ 'ab' ] = 3 # some noise added to mapping value = mapping . pop ( 'ab' ) print ( value ) print ( 'ab' not in mapping ) If key is a key in a dictionary D , D.pop(key) removes the key key in D and returns the value associated with it. Removing a key naturally removes the value associated with it. Dictionaries are aristocratic data structures: keys are higher up in the hierarchy and values depend on the keys for their existence.","title":"Lesson-6.3"},{"location":"chapter-6/lesson-6.3/#lesson-63","text":"","title":"Lesson-6.3"},{"location":"chapter-6/lesson-6.3/#dictionaries","text":"","title":"Dictionaries"},{"location":"chapter-6/lesson-6.3/#pangrams-and-dictionaries","text":"Assume that we wish to compute the following mapping between letters of the English alphabet and numbers from 1 to 26: Letter Number a 1 b 2 ... ... z 26 Each letter in the alphabet is mapped to a unique number from 1 to 26. In the table given above, the mapping is a simple linear mapping: 'a' is mapped to 1 , 'b' to 2 and so on. This mapping can be computed in the most uninteresting and lousy way given below: 1 2 3 4 5 6 7 8 9 10 mapping = { 'a' : 1 , 'b' : 2 , 'c' : 3 , 'd' : 4 , 'e' : 5 , 'f' : 6 , 'g' : 7 , 'h' : 8 , 'i' : 9 , 'j' : 10 , 'k' : 11 , 'l' : 12 , 'm' : 13 , 'n' : 14 , 'o' : 15 , 'p' : 16 , 'q' : 17 , 'r' : 18 , 's' : 19 , 't' : 20 , 'u' : 21 , 'v' : 22 , 'w' : 23 , 'x' : 24 , 'y' : 25 , 'z' : 26 } for letter , count in mapping . items (): print ( letter , count ) Phew! If you type the whole thing out, it will take you two full dull minutes. Your finger will curse you for the mechanical key-presses while your eyes will chide you for staring at the screen without blinking. You could cheese your way past the challenge by hitting the clipboard button and pasting it but will you really open up this textbook everytime you need to make this mapping? Let us try a roundabout but interesting way. Consider the following line: the quick brown fox jumps over the lazy dog This sentence is called a pangram. A pangram is a sentence that uses all the letters of the alphabet. Does that ring any bell? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 pangram = 'the quick brown fox jumps over the lazy dog' words = pangram . split ( ' ' ) # get list of words in the sentence letters = '' . join ( words ) # join the words back; eliminates spaces sorted_letters = sorted ( letters ) # sort letters mapping , count = dict (), 0 for letter in sorted_letters : # check if letter is not present in dict # to avoid counting same letter multiple times if letter not in mapping : count += 1 mapping [ letter ] = count # map the letter to count for letter , count in mapping . items (): print ( letter , count ) Plenty of things to learn from those 14 lines of code. Not all diversions are bad. Now that we have an interesting dictionary in place, let us jump into some methods that are bundled along with dict .","title":"Pangrams and Dictionaries"},{"location":"chapter-6/lesson-6.3/#dictionary-methods","text":"We have already seen keys and items . Both these are methods that return a view object over which we can iterate. According to the Python documentation , [View objects] provide a dynamic view on the dictionary's entries, which means that when the dictionary changes, the view reflects these changes. 15 16 keys = mapping . keys () print ( keys ) This gives the following output: dict_keys(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']) Using the list () function, both the keys and items views can be converted into lists: 17 18 19 20 keys_list = list ( mapping . keys ()) print ( keys ) items_list = list ( mapping . items ()) print ( items ) The output is as follows: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'] [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6), ('g', 7), ('h', 8), ('i', 9), ('j', 10), ('k', 11), ('l', 12), ('m', 13), ('n', 14), ('o', 15), ('p', 16), ('q', 17), ('r', 18), ('s', 19), ('t', 20), ('u', 21), ('v', 22), ('w', 23), ('x', 24), ('y', 25), ('z', 26)] keys_list is a list of keys in the dictionary mapping . items_list is a list of tuples, where each tuple is a key-value pair. Another useful method is values . This returns a view on the values: 21 22 view = mapping . values () view_list = list ( view ) All three views - keys , items , values - support membership tests: 23 24 25 print ( 'a' in mapping . keys ()) print ( 1 in mapping . values ()) print (( 'a' , 1 ) in mapping . items ()) All three return True . Membership tests for keys can be done in a simpler way: 26 27 28 print ( 'a' in mapping ) print ( 'x' in mapping ) print ( 'ab' not in mapping ) Note that we dropped the keys method and it still worked! Now, to delete a key from a dictionary, we use the familiar pop method: 29 30 31 32 mapping [ 'ab' ] = 3 # some noise added to mapping value = mapping . pop ( 'ab' ) print ( value ) print ( 'ab' not in mapping ) If key is a key in a dictionary D , D.pop(key) removes the key key in D and returns the value associated with it. Removing a key naturally removes the value associated with it. Dictionaries are aristocratic data structures: keys are higher up in the hierarchy and values depend on the keys for their existence.","title":"Dictionary Methods"},{"location":"chapter-6/lesson-6.4/","text":"Lesson-6.4 Dictionaries in Action: LMS The online degree portal \u2014 our virtual classroom \u2014 is called a learning Management system (LMS). In more accessible terms, an LMS is the software application that powers the portal. Have you ever wondered how your assignment submissions get recorded and graded? This is the question that we will try to answer in this lesson. At a high level, the LMS is made of two components: frontend and backend. As a user, your communicate with the frontend. The frontend is the website where you see all the content displayed. When you make an action, say clicking the submit button in a graded assignment, that action is fed to the backend as input. The backend processes this input and returns some output to the frontend, which is then displayed as the outcome of your action. Where does Python come into the picture? It features prominently in the backend. So how do we expect grading to work? It needs two inputs. The assignment and the submission corresponding to this assignment. It will return the result as output: The grader can be expressed as a function: def grader ( assignment , submission ): \"\"\"Grading logic\"\"\" result = 0.0 return result The function is incomplete. We need to decide how an assignment and its corresponding submission are going to be modeled. Assignment Model Let us consider an assignment. It is essentially a list of problems. So, modeling an assignment breaks down to modeling a problem. A problem could have the following attributes: Attribute Type id string question string type string options list answers tuple marks float For grading, we only need two attributes, the problem-id and the answers. With this, the assignment model will look like the following. The entire assignment will now be a list of dictionaries: # assume that the assignment has three problems # the assignment will be a list of dictionaries assignment = [ { 'id' : '10001' , 'answers' : ( 0 , 1 ), 'marks' : 2.0 }, { 'id' : '10002' , 'answers' : ( 1 , ), 'marks' : 1.0 }, { 'id' : '10003' , 'answers' : ( 2 , ), 'marks' : 2.0 } ] A point to note. A singleton tuple is represented as (<item>, ) . The comma cannot be ignored. Coming back to the assignment model, we see that there are several attributes in the table that haven't entered into the assignment dictionary since they are not relevant from the point of view of grading. They have been mentioned so that it gives a better understanding of how assignments can be modeled. Submission Model The submission model is slightly more involved. There are some global attributes like name of the user, the user's roll number and the time of submission. And then there are local attributes like the options selected for each problem. Attribute Type name string roll_number string timestamp string problems list Let us look at a sample submission: submission = { 'name' : 'Kapil Dev' , 'roll_number' : 'BSC1001' , 'time' : 'Sunday 18 April 2021 10:23:30 PM IST' , 'problems' : [ { 'id' : '10001' , 'selected' : ( 0 , 1 )}, { 'id' : '10002' , 'selected' : ( 1 , )}, { 'id' : '10003' , 'selected' : ( 3 , )} ] } submission is a fairly complicated object. To begin with, it is a dictionary. The first three keys do not pose any challenges. The value of the key 'problems' is a list of dictionaries! We could add one more level of complexity. Since a user could make multiple submissions, we could have a list of submissions! But for now, let us not complicate things any further. Grader The assignment is a list of dictionaries. While this is not a bad representation, the grader has to search for the problem id through this list every time it has to grade a problem. Since the problem id is unique, we can come up with a better representation for the assignment: assignment_ = [ { 'id' : '10001' , 'answers' : ( 0 , 1 ), 'marks' : 2.0 }, { 'id' : '10002' , 'answers' : ( 1 , ), 'marks' : 1.0 }, { 'id' : '10003' , 'answers' : ( 2 , ), 'marks' : 2.0 } ] assignment = dict () for problem in assignment_ : problem_id = problem [ 'id' ] answers = problem [ 'answers' ] marks = problem [ 'marks' ] assignment [ problem_id ] = { 'answers' : answers , 'marks' : marks } The assignment now looks like this: assignment = { '10001' : { 'answers' : ( 0 , 1 ), 'marks' : 2.0 }, '10002' : { 'answers' : ( 1 , ), 'marks' : 1.0 }, '10003' : { 'answers' : ( 2 , ), 'marks' : 2.0 }, } We are now ready to complete the grader using this new assignment model: def grader ( assignment , submission ): \"\"\"Grading logic\"\"\" result = 0.0 for problem in submission [ 'problems' ]: problem_id = problem [ 'id' ] selected = problem [ 'selected' ] answers = assignment [ problem_id ][ 'answers' ] if answers == selected : result += assignment [ problem_id ][ 'marks' ] return result","title":"Lesson-6.4"},{"location":"chapter-6/lesson-6.4/#lesson-64","text":"","title":"Lesson-6.4"},{"location":"chapter-6/lesson-6.4/#dictionaries-in-action-lms","text":"The online degree portal \u2014 our virtual classroom \u2014 is called a learning Management system (LMS). In more accessible terms, an LMS is the software application that powers the portal. Have you ever wondered how your assignment submissions get recorded and graded? This is the question that we will try to answer in this lesson. At a high level, the LMS is made of two components: frontend and backend. As a user, your communicate with the frontend. The frontend is the website where you see all the content displayed. When you make an action, say clicking the submit button in a graded assignment, that action is fed to the backend as input. The backend processes this input and returns some output to the frontend, which is then displayed as the outcome of your action. Where does Python come into the picture? It features prominently in the backend. So how do we expect grading to work? It needs two inputs. The assignment and the submission corresponding to this assignment. It will return the result as output: The grader can be expressed as a function: def grader ( assignment , submission ): \"\"\"Grading logic\"\"\" result = 0.0 return result The function is incomplete. We need to decide how an assignment and its corresponding submission are going to be modeled.","title":"Dictionaries in Action: LMS"},{"location":"chapter-6/lesson-6.4/#assignment-model","text":"Let us consider an assignment. It is essentially a list of problems. So, modeling an assignment breaks down to modeling a problem. A problem could have the following attributes: Attribute Type id string question string type string options list answers tuple marks float For grading, we only need two attributes, the problem-id and the answers. With this, the assignment model will look like the following. The entire assignment will now be a list of dictionaries: # assume that the assignment has three problems # the assignment will be a list of dictionaries assignment = [ { 'id' : '10001' , 'answers' : ( 0 , 1 ), 'marks' : 2.0 }, { 'id' : '10002' , 'answers' : ( 1 , ), 'marks' : 1.0 }, { 'id' : '10003' , 'answers' : ( 2 , ), 'marks' : 2.0 } ] A point to note. A singleton tuple is represented as (<item>, ) . The comma cannot be ignored. Coming back to the assignment model, we see that there are several attributes in the table that haven't entered into the assignment dictionary since they are not relevant from the point of view of grading. They have been mentioned so that it gives a better understanding of how assignments can be modeled.","title":"Assignment Model"},{"location":"chapter-6/lesson-6.4/#submission-model","text":"The submission model is slightly more involved. There are some global attributes like name of the user, the user's roll number and the time of submission. And then there are local attributes like the options selected for each problem. Attribute Type name string roll_number string timestamp string problems list Let us look at a sample submission: submission = { 'name' : 'Kapil Dev' , 'roll_number' : 'BSC1001' , 'time' : 'Sunday 18 April 2021 10:23:30 PM IST' , 'problems' : [ { 'id' : '10001' , 'selected' : ( 0 , 1 )}, { 'id' : '10002' , 'selected' : ( 1 , )}, { 'id' : '10003' , 'selected' : ( 3 , )} ] } submission is a fairly complicated object. To begin with, it is a dictionary. The first three keys do not pose any challenges. The value of the key 'problems' is a list of dictionaries! We could add one more level of complexity. Since a user could make multiple submissions, we could have a list of submissions! But for now, let us not complicate things any further.","title":"Submission Model"},{"location":"chapter-6/lesson-6.4/#grader","text":"The assignment is a list of dictionaries. While this is not a bad representation, the grader has to search for the problem id through this list every time it has to grade a problem. Since the problem id is unique, we can come up with a better representation for the assignment: assignment_ = [ { 'id' : '10001' , 'answers' : ( 0 , 1 ), 'marks' : 2.0 }, { 'id' : '10002' , 'answers' : ( 1 , ), 'marks' : 1.0 }, { 'id' : '10003' , 'answers' : ( 2 , ), 'marks' : 2.0 } ] assignment = dict () for problem in assignment_ : problem_id = problem [ 'id' ] answers = problem [ 'answers' ] marks = problem [ 'marks' ] assignment [ problem_id ] = { 'answers' : answers , 'marks' : marks } The assignment now looks like this: assignment = { '10001' : { 'answers' : ( 0 , 1 ), 'marks' : 2.0 }, '10002' : { 'answers' : ( 1 , ), 'marks' : 1.0 }, '10003' : { 'answers' : ( 2 , ), 'marks' : 2.0 }, } We are now ready to complete the grader using this new assignment model: def grader ( assignment , submission ): \"\"\"Grading logic\"\"\" result = 0.0 for problem in submission [ 'problems' ]: problem_id = problem [ 'id' ] selected = problem [ 'selected' ] answers = assignment [ problem_id ][ 'answers' ] if answers == selected : result += assignment [ problem_id ][ 'marks' ] return result","title":"Grader"},{"location":"chapter-6/lesson-6.5/","text":"Lesson-6.5 Sets Introduction A set is an unordered collection with no duplicate elements [ refer ]. Unlike lists and tuples, there is no notion of order in a set. This is why it is called an unordered collection as opposed to a sequence. A set can be defined as follows: even_nums = { 2 , 4 , 6 , 8 , 10 } print ( type ( even_nums )) print ( isinstance ( even_nums , set )) Output 1 2 <class 'set'> True Notice the similarity in syntax between sets and dictionaries. Both are enclosed within curly braces. While a dictionary has key-value pairs in it, a set just has a collection of values. A set in Python is a remarkably accurate representation of a mathematical set. Therefore, most of the properties that you are used to seeing in mathematical sets nicely carry over to Python sets. This connection is so strong that you can often forget that you are dealing with Python sets. 1 2 3 4 5 nums_1 = { 2 , 4 , 6 , 8 , 10 } nums_2 = { 2 , 2 , 4 , 4 , 6 , 6 , 8 , 8 , 10 , 10 } print ( nums_1 , nums_2 ) print ( nums_1 == nums_2 ) print ( nums_1 is not nums_2 ) Output 1 2 3 {2, 4, 6, 8, 10} {2, 4, 6, 8, 10} True True As stated before, sets do not support duplicate elements. We see that nums_1 and nums_2 are equal sets. However, they don't point to the same object. Sets support membership just like lists, tuples and dictionaries. 1 2 3 nums = { 1 , 2 , 3 , 4 , 5 } print ( 1 in nums ) print ( 6 not in nums ) The number of elements in a set, which is the same as its cardinality, is given by the len () function: 1 2 nums = { 1 , 2 , 3 , 4 , 5 } print ( f 'Cardinality of nums is { len ( nums ) } ' ) Sets cannot be indexed. This is quite reasonable as they are not ordered collections. The following code will throw an error: 1 2 3 4 ##### Alarm! Wrong code snippet! ##### some_set = { 'this' , 'is' , 'a' , 'set' } print ( some_set [ 0 ]) ##### Alarm! Wrong code snippet! ##### Any hashable object can be added to sets. This means most of the immutable types such as int , float , str and tuple can be added to sets. A small caveat as far as tuples are concerned: a tuple of lists is unhashable and therefore cannot be added to sets. 1 2 a_set = { 1.0 , 'one' , 1 , True , ( 1 , )} # valid set not_a_set = {([ 1 , 2 ], [ 3 , 4 ])} # not a valid set not_a_set returns a TypeError as expected. Iterating through Sets Though a set is not a sequence, iterating through the elements of a set is supported. 1 2 3 nums = { 1 , 2 , 3 , 4 , 5 } for num in nums : print ( num ) Growing Sets How do we define an empty set? 1 2 3 4 5 ##### Alarm! Be careful about the variable name! ##### empty_set = { } print ( isinstance ( empty_set , set )) print ( isinstance ( empty_set , dict )) ##### Alarm! Be careful about the variable name! ##### We see that empty_set is in fact an empty dictionary. Computers are precise machines, which makes them very faithful. Few lessons back we used { } to initialize an empty dictionary. It hasn't changed. { } is still an empty dictionary. So, how do we define an empty set then? empty_set = set () print ( isinstance ( empty_set , set )) Simple enough! With the empty set and set-iteration defined, we can now grow sets from scratch. Consider the first 100 powers of 7: $$ 7^1, 7^2, \\cdots, 7^{100} $$ Note down the last digit of each of these powers. How many of them are unique? What are these numbers? This problem has a simple mathematical solution. But humor me and assume that you don't know how to solve this problem. Let us go for a computational solution. num = 1 digits = set () for i in range ( 100 ): num *= 7 last = num % 10 digits . add ( last ) print ( digits ) add is a method used to add elements to a set. The solution to this problem is a typical use case of sets. When you expect duplicate elements to come up often and if you are not concerned with duplicates, then sets are ideal objects for storage. The same problem can be solved using lists: num = 1 digits = [ ] for i in range ( 100 ): num *= 7 last = num % 10 if last not in digits : digits . append ( last ) print ( digits ) Set Operations Mathematical sets are friendly objects. They routinely interact with each other through one of the following operations: Subset Superset Union Intersection Difference Python sets strive to be as friendly as their mathematical counterparts. We will see how each of these operations are represented: Subset: \\(A\\) is a subset of \\(B\\) if every element of \\(A\\) is present in \\(B\\) . It is denoted by \\(A \\subseteq B\\) . This is a binary relationship and its outcome can be determined in one of the two ways: A = { 1 , 3 , 5 } B = { 1 , 2 , 3 , 4 , 5 } print ( A . issubset ( B )) # method-1 print ( A <= B ) # method-2 Both lines return the value True . A set \\(A\\) is a proper subset of \\(B\\) if every element in \\(A\\) is present in \\(B\\) and \\(A \\neq B\\) . It is denoted by \\(A \\subset B\\) . That is, there is at least one element in \\(B\\) which is not in \\(A\\) : A = { 1 , 2 , 3 } B = { 1 , 2 , 3 } print ( A <= B ) # method-1 print ( A < B ) # method-2 The A < B operator checks if A is a proper subset of B . In this case A is not a proper subset of B , so the second print statement returns False . Superset: \\(A\\) is a superset of \\(B\\) if every element of \\(B\\) is present in \\(A\\) . It is denoted by \\(A \\supset B\\) : A = { 1 , 3 , 5 } B = { 1 , 2 , 3 , 4 , 5 } B . issuperset ( A ) # method-1 print ( B >= A ) # method-2 Union: The union of two sets \\(A\\) and \\(B\\) is the set of elements that are present in either \\(A\\) or \\(B\\) or both. It is denoted by \\(A \\cup B\\) . A = { 1 , 3 , 5 } B = { 2 , 4 , 6 } C1 = A . union ( B ) # method-1 C2 = A | B # method-2 print ( C1 , C2 ) print ( C1 == C2 ) When there are multiple sets, we could do the following: A1 , A2 , A3 , A4 = { 1 }, { 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 , 10 } B1 = A1 . union ( A2 , A3 , A4 ) # method-1 B2 = A1 | A2 | A3 | A4 # method-2 print ( B1 , B2 ) print ( B1 == B2 ) Intersection: The intersection of two sets \\(A\\) and \\(B\\) is the set of elements common to both. It is denoted by \\(A \\cap B\\) . A = { 2 , 4 , 6 } B = { 2 , 4 } C1 = A . intersection ( B ) # method-1 C2 = A & B # method-2 print ( C1 , C2 ) print ( C1 == C2 ) What happens if there are no elements in common? We should get the empty set: even , odd = { 2 , 4 , 6 }, { 1 , 3 , 5 } common = even & odd assert common == set () We have used an assert statement just to introduce some variation. As it doesn't raise an AssertionError , we are right on target. Difference: The difference between two sets \\(A\\) and \\(B\\) is the set of elements present in one set but not in the other. It is denoted by \\(A - B\\) or \\(B - A\\) , and the two are not the same! \\(A - B\\) is the set of elements in \\(A\\) which are not in \\(B\\) . \\(B - A\\) is the set of elements in \\(B\\) which are not in \\(A\\) . A = { 1 , 2 , 3 , 4 } B = { 2 , 4 , 5 } C1 = A . difference ( B ) # method-1 C2 = A - B # method-2 print ( C1 , C2 ) print ( C1 == C2 ) D1 = B . difference ( A ) # method-1 D2 = B - A # method-2 print ( D1 , D2 ) print ( D1 == D2 ) Other Set Methods The methods that we saw in the previous section had a mathematical flavor. Now, we shall look at those methods that have a computational flavor! To remove an element from the set, we can use the remove method: A = { 'this' , 'is' , 'a' , 'set' } print ( 'Before' , A ) A . remove ( 'this' ) print ( 'After' , A ) If we try to remove an element that is not present in the set, the interpreter will throw a KeyError : A = { 'this' , 'is' , 'a' , 'set' } A . remove ( 'cool' ) # error! Consider the following problem: Given a list L , extract all unique elements from it and store the result in another list, L_uniq . The order of elements does not matter. Let us first look at a solution that doesn't use sets: L = [ 1 , 2 , 3 , 3 , 4 , 5 , 6 , 1 , 2 , 2 ] L_uniq = [ ] for elem in L : if elem not in L_uniq : L_uniq . append ( elem ) print ( L_uniq ) Now, for some set magic: L = [ 1 , 2 , 3 , 3 , 4 , 5 , 6 , 1 , 2 , 2 ] S = set ( L ) L_uniq = list ( S ) print ( L_uniq ) Passing a list to the set function removes all duplicates and returns the unique elements. Mutability Sets are mutable entities. A = { 1 , 2 , 3 } B = A B . add ( 4 ) print ( A , B ) print ( A is B ) A and B are the same objects. As before, there are two ways to do a shallow copy: A = { 1 , 2 , 3 } B1 = A . copy () B2 = set ( A ) B1 . add ( 4 ) B2 . add ( 0 ) print ( A , B1 , B2 ) print ( A is not B1 ) print ( A is not B2 )","title":"Lesson-6.5"},{"location":"chapter-6/lesson-6.5/#lesson-65","text":"","title":"Lesson-6.5"},{"location":"chapter-6/lesson-6.5/#sets","text":"","title":"Sets"},{"location":"chapter-6/lesson-6.5/#introduction","text":"A set is an unordered collection with no duplicate elements [ refer ]. Unlike lists and tuples, there is no notion of order in a set. This is why it is called an unordered collection as opposed to a sequence. A set can be defined as follows: even_nums = { 2 , 4 , 6 , 8 , 10 } print ( type ( even_nums )) print ( isinstance ( even_nums , set ))","title":"Introduction"},{"location":"chapter-6/lesson-6.5/#output","text":"1 2 <class 'set'> True Notice the similarity in syntax between sets and dictionaries. Both are enclosed within curly braces. While a dictionary has key-value pairs in it, a set just has a collection of values. A set in Python is a remarkably accurate representation of a mathematical set. Therefore, most of the properties that you are used to seeing in mathematical sets nicely carry over to Python sets. This connection is so strong that you can often forget that you are dealing with Python sets. 1 2 3 4 5 nums_1 = { 2 , 4 , 6 , 8 , 10 } nums_2 = { 2 , 2 , 4 , 4 , 6 , 6 , 8 , 8 , 10 , 10 } print ( nums_1 , nums_2 ) print ( nums_1 == nums_2 ) print ( nums_1 is not nums_2 )","title":"Output"},{"location":"chapter-6/lesson-6.5/#output_1","text":"1 2 3 {2, 4, 6, 8, 10} {2, 4, 6, 8, 10} True True As stated before, sets do not support duplicate elements. We see that nums_1 and nums_2 are equal sets. However, they don't point to the same object. Sets support membership just like lists, tuples and dictionaries. 1 2 3 nums = { 1 , 2 , 3 , 4 , 5 } print ( 1 in nums ) print ( 6 not in nums ) The number of elements in a set, which is the same as its cardinality, is given by the len () function: 1 2 nums = { 1 , 2 , 3 , 4 , 5 } print ( f 'Cardinality of nums is { len ( nums ) } ' ) Sets cannot be indexed. This is quite reasonable as they are not ordered collections. The following code will throw an error: 1 2 3 4 ##### Alarm! Wrong code snippet! ##### some_set = { 'this' , 'is' , 'a' , 'set' } print ( some_set [ 0 ]) ##### Alarm! Wrong code snippet! ##### Any hashable object can be added to sets. This means most of the immutable types such as int , float , str and tuple can be added to sets. A small caveat as far as tuples are concerned: a tuple of lists is unhashable and therefore cannot be added to sets. 1 2 a_set = { 1.0 , 'one' , 1 , True , ( 1 , )} # valid set not_a_set = {([ 1 , 2 ], [ 3 , 4 ])} # not a valid set not_a_set returns a TypeError as expected.","title":"Output"},{"location":"chapter-6/lesson-6.5/#iterating-through-sets","text":"Though a set is not a sequence, iterating through the elements of a set is supported. 1 2 3 nums = { 1 , 2 , 3 , 4 , 5 } for num in nums : print ( num )","title":"Iterating through Sets"},{"location":"chapter-6/lesson-6.5/#growing-sets","text":"How do we define an empty set? 1 2 3 4 5 ##### Alarm! Be careful about the variable name! ##### empty_set = { } print ( isinstance ( empty_set , set )) print ( isinstance ( empty_set , dict )) ##### Alarm! Be careful about the variable name! ##### We see that empty_set is in fact an empty dictionary. Computers are precise machines, which makes them very faithful. Few lessons back we used { } to initialize an empty dictionary. It hasn't changed. { } is still an empty dictionary. So, how do we define an empty set then? empty_set = set () print ( isinstance ( empty_set , set )) Simple enough! With the empty set and set-iteration defined, we can now grow sets from scratch. Consider the first 100 powers of 7: $$ 7^1, 7^2, \\cdots, 7^{100} $$ Note down the last digit of each of these powers. How many of them are unique? What are these numbers? This problem has a simple mathematical solution. But humor me and assume that you don't know how to solve this problem. Let us go for a computational solution. num = 1 digits = set () for i in range ( 100 ): num *= 7 last = num % 10 digits . add ( last ) print ( digits ) add is a method used to add elements to a set. The solution to this problem is a typical use case of sets. When you expect duplicate elements to come up often and if you are not concerned with duplicates, then sets are ideal objects for storage. The same problem can be solved using lists: num = 1 digits = [ ] for i in range ( 100 ): num *= 7 last = num % 10 if last not in digits : digits . append ( last ) print ( digits )","title":"Growing Sets"},{"location":"chapter-6/lesson-6.5/#set-operations","text":"Mathematical sets are friendly objects. They routinely interact with each other through one of the following operations: Subset Superset Union Intersection Difference Python sets strive to be as friendly as their mathematical counterparts. We will see how each of these operations are represented: Subset: \\(A\\) is a subset of \\(B\\) if every element of \\(A\\) is present in \\(B\\) . It is denoted by \\(A \\subseteq B\\) . This is a binary relationship and its outcome can be determined in one of the two ways: A = { 1 , 3 , 5 } B = { 1 , 2 , 3 , 4 , 5 } print ( A . issubset ( B )) # method-1 print ( A <= B ) # method-2 Both lines return the value True . A set \\(A\\) is a proper subset of \\(B\\) if every element in \\(A\\) is present in \\(B\\) and \\(A \\neq B\\) . It is denoted by \\(A \\subset B\\) . That is, there is at least one element in \\(B\\) which is not in \\(A\\) : A = { 1 , 2 , 3 } B = { 1 , 2 , 3 } print ( A <= B ) # method-1 print ( A < B ) # method-2 The A < B operator checks if A is a proper subset of B . In this case A is not a proper subset of B , so the second print statement returns False . Superset: \\(A\\) is a superset of \\(B\\) if every element of \\(B\\) is present in \\(A\\) . It is denoted by \\(A \\supset B\\) : A = { 1 , 3 , 5 } B = { 1 , 2 , 3 , 4 , 5 } B . issuperset ( A ) # method-1 print ( B >= A ) # method-2 Union: The union of two sets \\(A\\) and \\(B\\) is the set of elements that are present in either \\(A\\) or \\(B\\) or both. It is denoted by \\(A \\cup B\\) . A = { 1 , 3 , 5 } B = { 2 , 4 , 6 } C1 = A . union ( B ) # method-1 C2 = A | B # method-2 print ( C1 , C2 ) print ( C1 == C2 ) When there are multiple sets, we could do the following: A1 , A2 , A3 , A4 = { 1 }, { 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 , 10 } B1 = A1 . union ( A2 , A3 , A4 ) # method-1 B2 = A1 | A2 | A3 | A4 # method-2 print ( B1 , B2 ) print ( B1 == B2 ) Intersection: The intersection of two sets \\(A\\) and \\(B\\) is the set of elements common to both. It is denoted by \\(A \\cap B\\) . A = { 2 , 4 , 6 } B = { 2 , 4 } C1 = A . intersection ( B ) # method-1 C2 = A & B # method-2 print ( C1 , C2 ) print ( C1 == C2 ) What happens if there are no elements in common? We should get the empty set: even , odd = { 2 , 4 , 6 }, { 1 , 3 , 5 } common = even & odd assert common == set () We have used an assert statement just to introduce some variation. As it doesn't raise an AssertionError , we are right on target. Difference: The difference between two sets \\(A\\) and \\(B\\) is the set of elements present in one set but not in the other. It is denoted by \\(A - B\\) or \\(B - A\\) , and the two are not the same! \\(A - B\\) is the set of elements in \\(A\\) which are not in \\(B\\) . \\(B - A\\) is the set of elements in \\(B\\) which are not in \\(A\\) . A = { 1 , 2 , 3 , 4 } B = { 2 , 4 , 5 } C1 = A . difference ( B ) # method-1 C2 = A - B # method-2 print ( C1 , C2 ) print ( C1 == C2 ) D1 = B . difference ( A ) # method-1 D2 = B - A # method-2 print ( D1 , D2 ) print ( D1 == D2 )","title":"Set Operations"},{"location":"chapter-6/lesson-6.5/#other-set-methods","text":"The methods that we saw in the previous section had a mathematical flavor. Now, we shall look at those methods that have a computational flavor! To remove an element from the set, we can use the remove method: A = { 'this' , 'is' , 'a' , 'set' } print ( 'Before' , A ) A . remove ( 'this' ) print ( 'After' , A ) If we try to remove an element that is not present in the set, the interpreter will throw a KeyError : A = { 'this' , 'is' , 'a' , 'set' } A . remove ( 'cool' ) # error! Consider the following problem: Given a list L , extract all unique elements from it and store the result in another list, L_uniq . The order of elements does not matter. Let us first look at a solution that doesn't use sets: L = [ 1 , 2 , 3 , 3 , 4 , 5 , 6 , 1 , 2 , 2 ] L_uniq = [ ] for elem in L : if elem not in L_uniq : L_uniq . append ( elem ) print ( L_uniq ) Now, for some set magic: L = [ 1 , 2 , 3 , 3 , 4 , 5 , 6 , 1 , 2 , 2 ] S = set ( L ) L_uniq = list ( S ) print ( L_uniq ) Passing a list to the set function removes all duplicates and returns the unique elements.","title":"Other Set Methods"},{"location":"chapter-6/lesson-6.5/#mutability","text":"Sets are mutable entities. A = { 1 , 2 , 3 } B = A B . add ( 4 ) print ( A , B ) print ( A is B ) A and B are the same objects. As before, there are two ways to do a shallow copy: A = { 1 , 2 , 3 } B1 = A . copy () B2 = set ( A ) B1 . add ( 4 ) B2 . add ( 0 ) print ( A , B1 , B2 ) print ( A is not B1 ) print ( A is not B2 )","title":"Mutability"},{"location":"chapter-7/lesson-7.1/","text":"Lesson 7.1 File Handling Why files The best way to motivate files is to take the human example. Consider our memory. There is a certain volume of information that we can retain in our working memory. A popular claim is that we can retain around seven chunks of information in our short-term memory. Anything that exceeds this volume of information, we have to resort to external aids such as notebooks. Something similar happens in computers. Modern day computers are quite powerful and can retain several chunks of information at a time. Though computers are machines, the amount of short-term memory that they possess is still finite. This is where the idea of external storage comes in. Files are to computers what books are to humans. A file is used to record information in a permanent location so that it can be retrieved as and when needed. File handling We are all used to opening files in our computers by simply double clicking on an icon. Let us take the example of a simple file having the following contents: Income Expenditure 12,000 10,000 50,000 45,000 75,000 35,000 14,000 12,000 60,000 40,000 This file has the income-expenditure details of a family for five months. We wish to create a new file that has the savings details added as a third column. That is, we wish to generate the following file: Income Expenditure Savings 12,000 10,000 2,000 50,000 45,000 5,000 75,000 35,000 40,000 14,000 12,000 2,000 60,000 40,000 20,000 This seems like a simple task. Open this file, plug the numbers in the calculator, get the result and paste it in a new column and we are done. But what if the number of entries in the file increases? For example, let us say we wish to perform this operation for all families in the neighborhood. If we have 10 years worth data for 1000 families, we are looking at \\(1000 * 10 * 12 = 120,000\\) entries! Our calculator will break down and so will we out of exhaustion. This is where Python comes to our rescue. We can write a piece of code to automate the whole process. And all it is going to take is a few lines of code! In the next few lessons, we will see how to process files. We will learn the following operations: opening a file and closing it reading from a file writing to a file File handling is an umbrella term that denotes all these operations.","title":"Lesson 7.1"},{"location":"chapter-7/lesson-7.1/#lesson-71","text":"","title":"Lesson 7.1"},{"location":"chapter-7/lesson-7.1/#file-handling","text":"","title":"File Handling"},{"location":"chapter-7/lesson-7.1/#why-files","text":"The best way to motivate files is to take the human example. Consider our memory. There is a certain volume of information that we can retain in our working memory. A popular claim is that we can retain around seven chunks of information in our short-term memory. Anything that exceeds this volume of information, we have to resort to external aids such as notebooks. Something similar happens in computers. Modern day computers are quite powerful and can retain several chunks of information at a time. Though computers are machines, the amount of short-term memory that they possess is still finite. This is where the idea of external storage comes in. Files are to computers what books are to humans. A file is used to record information in a permanent location so that it can be retrieved as and when needed.","title":"Why files"},{"location":"chapter-7/lesson-7.1/#file-handling_1","text":"We are all used to opening files in our computers by simply double clicking on an icon. Let us take the example of a simple file having the following contents: Income Expenditure 12,000 10,000 50,000 45,000 75,000 35,000 14,000 12,000 60,000 40,000 This file has the income-expenditure details of a family for five months. We wish to create a new file that has the savings details added as a third column. That is, we wish to generate the following file: Income Expenditure Savings 12,000 10,000 2,000 50,000 45,000 5,000 75,000 35,000 40,000 14,000 12,000 2,000 60,000 40,000 20,000 This seems like a simple task. Open this file, plug the numbers in the calculator, get the result and paste it in a new column and we are done. But what if the number of entries in the file increases? For example, let us say we wish to perform this operation for all families in the neighborhood. If we have 10 years worth data for 1000 families, we are looking at \\(1000 * 10 * 12 = 120,000\\) entries! Our calculator will break down and so will we out of exhaustion. This is where Python comes to our rescue. We can write a piece of code to automate the whole process. And all it is going to take is a few lines of code! In the next few lessons, we will see how to process files. We will learn the following operations: opening a file and closing it reading from a file writing to a file File handling is an umbrella term that denotes all these operations.","title":"File handling"},{"location":"chapter-7/lesson-7.2/","text":"Lesson-7.2 File Handling Creating a file in Replit Let us use Replit and use the Add File button to create a file. Each file should be given a name. Let us call our file examples.txt . Now, we shall add the following lines to the file: 1 2 3 4 5 one two three four five After creating the file, this is how it should look in Replit when we click on examples.txt : examples.txt is called a text file. We can identify this from the extension \u2014 txt that comes at the end of files. Don't worry too much about the extension. It is enough if you know that different files come with different extensions. In fact, main.py is itself a file with py as the extension. This is why it gets listed along with examples.txt under the Files tab in Replit. Opening and reading from a file Now, it is time to open the file and print the contents on to the console. For this, we head to main.py and type the following lines. 1 2 3 4 f = open ( 'examples.txt' , 'r' ) for line in f : print ( line ) f . close () open () is a built-in function in Python that accepts two arguments: file name mode The first argument is the file name, which is 'examples.txt' in our case. The second argument corresponds to the mode in which we want to process the file. In this case, we want to read the file. So, we open the file in read-mode. The single character 'r' is used to denote this mode. Notice that both the arguments passed to open () are strings. The open () function returns a file object. Do no worry about the terminology for now. We will discuss it in detail in the next lesson. For now, it is enough to know that the open () function returns a file object that we have called f in our code. In lines 2-3, we loop through each line in the file and print it. As simple as that. Finally, in line 4, we close the file using the method close () . It is a good practice to close the file once we are done with processing it. Let us now see the output at the end of execution of this code block: 1 2 3 4 5 6 7 8 9 one two three four five Now that doesn't seem right. We have all the contents of the file, but for whatever reason, there is an extra line between successive lines in the file. To suppress these new lines, we have to modify our print function slightly: 1 2 3 4 f = open ( 'examples.txt' , 'r' ) for line in f : print ( line , end = '' ) # there is NO SPACE between the quotes f . close () Note the change in line 3. By default, print () appends a newline character ( ' \\n ' ) at the end of whatever it is printing. By using end = '' , we are just appending the empty string. Therefore, the extra line that was appearing in the output will no longer bother us when we execute the code we have just written: 1 2 3 4 5 one two three four five Opening and writing to a file Consider the following code-block: 1 2 3 4 5 6 7 f = open ( 'writing.txt' , 'w' ) f . write ( 'one ' ) f . write ( 'two ' ) f . write ( 'three ' ) f . write ( 'four ' ) f . write ( 'five' ) f . close () Here, we have opened the file in write mode. When this code is executed, it creates a file in Replit called writing.txt . We have used what is called the write () method to write to the file. We pass the content we wish to write as a string argument to the method. Notice that, even though we have used the write () method to write five different words on five lines in the code, all of them get written to the same line in the file. The way to tell the file object to go to a new line is using the ' \\n ' character. Let us now, try the following piece of code: 1 2 3 4 5 6 7 8 9 10 11 f = open ( 'writing.txt' , 'w' ) f . write ( 'one' ) f . write ( ' \\n ' ) f . write ( 'two' ) f . write ( ' \\n ' ) f . write ( 'three' ) f . write ( ' \\n ' ) f . write ( 'four' ) f . write ( ' \\n ' ) f . write ( 'five' ) f . close () A better way of achieving this in fewer lines of code is to append the \\n character to every line of the file we wish to write: f = open ( 'writing.txt' , 'w' ) f . write ( 'one \\n ' ) f . write ( 'two \\n ' ) f . write ( 'three \\n ' ) f . write ( 'four \\n ' ) f . write ( 'five' ) f . close () This results in the same file but with fewer lines of code! In the next lesson, we will take a closer look at the idea of a file object. Notice that we didn't add a ' \\n ' after five . Why do you think that is the case? Try running the code with ' \\n ' after five .","title":"Lesson-7.2"},{"location":"chapter-7/lesson-7.2/#lesson-72","text":"","title":"Lesson-7.2"},{"location":"chapter-7/lesson-7.2/#file-handling","text":"","title":"File Handling"},{"location":"chapter-7/lesson-7.2/#creating-a-file-in-replit","text":"Let us use Replit and use the Add File button to create a file. Each file should be given a name. Let us call our file examples.txt . Now, we shall add the following lines to the file: 1 2 3 4 5 one two three four five After creating the file, this is how it should look in Replit when we click on examples.txt : examples.txt is called a text file. We can identify this from the extension \u2014 txt that comes at the end of files. Don't worry too much about the extension. It is enough if you know that different files come with different extensions. In fact, main.py is itself a file with py as the extension. This is why it gets listed along with examples.txt under the Files tab in Replit.","title":"Creating a file in Replit"},{"location":"chapter-7/lesson-7.2/#opening-and-reading-from-a-file","text":"Now, it is time to open the file and print the contents on to the console. For this, we head to main.py and type the following lines. 1 2 3 4 f = open ( 'examples.txt' , 'r' ) for line in f : print ( line ) f . close () open () is a built-in function in Python that accepts two arguments: file name mode The first argument is the file name, which is 'examples.txt' in our case. The second argument corresponds to the mode in which we want to process the file. In this case, we want to read the file. So, we open the file in read-mode. The single character 'r' is used to denote this mode. Notice that both the arguments passed to open () are strings. The open () function returns a file object. Do no worry about the terminology for now. We will discuss it in detail in the next lesson. For now, it is enough to know that the open () function returns a file object that we have called f in our code. In lines 2-3, we loop through each line in the file and print it. As simple as that. Finally, in line 4, we close the file using the method close () . It is a good practice to close the file once we are done with processing it. Let us now see the output at the end of execution of this code block: 1 2 3 4 5 6 7 8 9 one two three four five Now that doesn't seem right. We have all the contents of the file, but for whatever reason, there is an extra line between successive lines in the file. To suppress these new lines, we have to modify our print function slightly: 1 2 3 4 f = open ( 'examples.txt' , 'r' ) for line in f : print ( line , end = '' ) # there is NO SPACE between the quotes f . close () Note the change in line 3. By default, print () appends a newline character ( ' \\n ' ) at the end of whatever it is printing. By using end = '' , we are just appending the empty string. Therefore, the extra line that was appearing in the output will no longer bother us when we execute the code we have just written: 1 2 3 4 5 one two three four five","title":"Opening and reading from a file"},{"location":"chapter-7/lesson-7.2/#opening-and-writing-to-a-file","text":"Consider the following code-block: 1 2 3 4 5 6 7 f = open ( 'writing.txt' , 'w' ) f . write ( 'one ' ) f . write ( 'two ' ) f . write ( 'three ' ) f . write ( 'four ' ) f . write ( 'five' ) f . close () Here, we have opened the file in write mode. When this code is executed, it creates a file in Replit called writing.txt . We have used what is called the write () method to write to the file. We pass the content we wish to write as a string argument to the method. Notice that, even though we have used the write () method to write five different words on five lines in the code, all of them get written to the same line in the file. The way to tell the file object to go to a new line is using the ' \\n ' character. Let us now, try the following piece of code: 1 2 3 4 5 6 7 8 9 10 11 f = open ( 'writing.txt' , 'w' ) f . write ( 'one' ) f . write ( ' \\n ' ) f . write ( 'two' ) f . write ( ' \\n ' ) f . write ( 'three' ) f . write ( ' \\n ' ) f . write ( 'four' ) f . write ( ' \\n ' ) f . write ( 'five' ) f . close () A better way of achieving this in fewer lines of code is to append the \\n character to every line of the file we wish to write: f = open ( 'writing.txt' , 'w' ) f . write ( 'one \\n ' ) f . write ( 'two \\n ' ) f . write ( 'three \\n ' ) f . write ( 'four \\n ' ) f . write ( 'five' ) f . close () This results in the same file but with fewer lines of code! In the next lesson, we will take a closer look at the idea of a file object. Notice that we didn't add a ' \\n ' after five . Why do you think that is the case? Try running the code with ' \\n ' after five .","title":"Opening and writing to a file"},{"location":"chapter-7/lesson-7.3/","text":"Lesson 7.3 File Object As mentioned earlier, the open () function returns a file object. The following image gives a better picture of the whole setup. What is a file object? Let us use the following analogy: You are the CEO of a tech company. Even though you are good at multi-tasking, there are simply too many things for you to keep track of. To help you manage the mounting load of activities, you hire a personal assistant (PA). Think about the kind of work you generally assign to a PA. Let us say that you are meeting delegates from another company at 5:00 PM next Tuesday. The typical instruction to your PA would be this: \"make a note of this meeting\". Your PA would dutifully record this information in a file. Few days later, you might be suddenly reminded of this important meeting. At this point, this would be your instruction: \"fetch me the details of the meeting with those delegates\". In both cases, notice that it is your PA who is interacting with a file. In the first instruction, your PA noted down the details of a meeting in a file. In the second instruction, your PA retrieved the information from the file. The file object is your PA who mediates between you, the coder, and the file that resides on the hard disk of your computer. You pass an instruction to your file object, which does the job of reading and writing to a file. All communication between you and the file is routed through the file object. Mode In the following sections, we will briefly discuss about the two modes that a file can be opened in. We will go in depth in later lessons. Read mode The dotted line in the image given below corresponds to the mode in which you wish to process the file. This instruction always originates from you and is directed at the file object. When you are reading from a file, information flows from the file, through the file object and reaches you. This represented by the solid arrow. To read a file, we open it in the read mode: 1 2 3 4 5 f = open ( '<file_name>' , 'r' ) # ... # code for reading something from file # ... f . close () Write mode When you are writing to a file, information flows from you, through the file object and to the file. To write to a file, we open it in the write mode: f = open ( '<file_name>' , 'w' ) # ... # code for writing something into the file # ... f . close () In the next lesson, we will see some more aspects of file handling.","title":"Lesson 7.3"},{"location":"chapter-7/lesson-7.3/#lesson-73","text":"","title":"Lesson 7.3"},{"location":"chapter-7/lesson-7.3/#file-object","text":"As mentioned earlier, the open () function returns a file object. The following image gives a better picture of the whole setup. What is a file object? Let us use the following analogy: You are the CEO of a tech company. Even though you are good at multi-tasking, there are simply too many things for you to keep track of. To help you manage the mounting load of activities, you hire a personal assistant (PA). Think about the kind of work you generally assign to a PA. Let us say that you are meeting delegates from another company at 5:00 PM next Tuesday. The typical instruction to your PA would be this: \"make a note of this meeting\". Your PA would dutifully record this information in a file. Few days later, you might be suddenly reminded of this important meeting. At this point, this would be your instruction: \"fetch me the details of the meeting with those delegates\". In both cases, notice that it is your PA who is interacting with a file. In the first instruction, your PA noted down the details of a meeting in a file. In the second instruction, your PA retrieved the information from the file. The file object is your PA who mediates between you, the coder, and the file that resides on the hard disk of your computer. You pass an instruction to your file object, which does the job of reading and writing to a file. All communication between you and the file is routed through the file object.","title":"File Object"},{"location":"chapter-7/lesson-7.3/#mode","text":"In the following sections, we will briefly discuss about the two modes that a file can be opened in. We will go in depth in later lessons.","title":"Mode"},{"location":"chapter-7/lesson-7.3/#read-mode","text":"The dotted line in the image given below corresponds to the mode in which you wish to process the file. This instruction always originates from you and is directed at the file object. When you are reading from a file, information flows from the file, through the file object and reaches you. This represented by the solid arrow. To read a file, we open it in the read mode: 1 2 3 4 5 f = open ( '<file_name>' , 'r' ) # ... # code for reading something from file # ... f . close ()","title":"Read mode"},{"location":"chapter-7/lesson-7.3/#write-mode","text":"When you are writing to a file, information flows from you, through the file object and to the file. To write to a file, we open it in the write mode: f = open ( '<file_name>' , 'w' ) # ... # code for writing something into the file # ... f . close () In the next lesson, we will see some more aspects of file handling.","title":"Write mode"},{"location":"chapter-7/lesson-7.4/","text":"Lesson 7.4 File methods read () Let us continue working with examples.txt that we created in the previous lesson. If you recall, examples.txt has the following contents: 1 2 3 4 5 one two three four five Let us now look at a different way of reading from a file, using the read () method. 1 2 3 4 f = open ( 'examples.txt' , 'r' ) content = f . read () print ( content ) f . close () This gives the following output: 1 2 3 4 5 one two three four five read () is a method defined for the file object. When it is called without any argument, it returns a string that contains the entire content of the file. If you head to the console (it is to the right of the editor in Replit) and type the string content , this is what you get: 'one\\ntwo\\nthree\\nfour\\nfive' Notice that content is a single string. It contains the contents of the file, but between consecutive lines in the file, there is a ' \\n ' : Except for the last line, every line in the file ends with a ' \\n ' character. When this string is printed to the console \u2014 print ( content ) \u2014 we get five separate lines even though we are only passing a single string to the print () function. This is because of the presence of the newline character in the string. Whenever a newline character is encountered, the Python interpreter moves to the next line. Now, it is clear why the following piece of code printed an extra line between consecutive lines in the file: f = open ( 'examples.txt' , 'r' ) for line in f : print ( line ) # line ends with a \\n character for all lines except the last one # this is why we get an empty line between consecutive lines in the console f . close () readline () As its name suggests, the readline () method reads from the file one line at a time: 1 2 3 4 5 6 7 f = open ( 'examples.txt' , 'r' ) line1 = f . readline () line2 = f . readline () line3 = f . readline () line4 = f . readline () line5 = f . readline () f . close () The variables line1 , line2 , \u2026, line5 will hold the following values at the end of execution of the code given above: Variable Value line1 'one \\n ' line2 'two \\n ' line3 'three \\n ' line4 'four \\n ' line5 'five' Notice that line5 doesn't have a ' \\n ' at the end as it is the last line in the file. Here, we know that there are five lines in the file. This helped us define five separate variables. But what if there are more lines? Generally, we read a file so as to see what its contents are because we don't know what is there in it. Clearly, we need a way to figure out when the file ends. Now, consider the following code. What happens if we try to read the file using readline () after all the lines in the file have been read? 1 2 3 4 5 6 7 8 f = open ( 'examples.txt' , 'r' ) line1 = f . readline () line2 = f . readline () line3 = f . readline () line4 = f . readline () line5 = f . readline () line = f . readline () f . close () If we execute this and head to the console, we see that the variable line defined in line 7 is an empty string! This gives us a way to determine when a file is empty: Keep reading lines from the file until an empty string is encountered. Let us implement this: 1 2 3 4 5 6 f = open ( 'examples.txt' , 'r' ) line = f . readline () while line != '' : print ( line , end = '' ) line = f . readline () f . close () Here, we have managed to read the file using just one string variable. Let us make few more changes to this code: 1 2 3 4 5 6 f = open ( 'examples.txt' , 'r' ) line = f . readline () while line : print ( line . strip ()) line = f . readline () f . close () In this code, we have made two changes. One in line 3 and another in line 4. The loop condition in line-3 checks for the empty string. If line is an empty string, it evaluates to False and the loop will be terminated. This is a compact way of writing line != '' . Python treats empty sequences as False . If this is confusing, execute the following code and check the output: 1 2 3 line = '' if not line : print ( 'It works!' ) In line 4, we are using the strip () method to strip the string line of all the whitespace characters at the beginning and at the end. In this way, the trailing newline at the end of line will be stripped. This way, we don't need to use the end argument. readlines () Finally, Python also provides a way to read the file and store it as a list of lines: 1 2 3 4 5 f = open ( 'examples.txt' , 'r' ) lines = f . readlines () for line in lines : print ( line . strip ()) f . close () Here, lines is a list of lines. Notice that each element in lines corresponds to one line in the file. It is always a string: ['one\\n', 'two\\n', 'three\\n', 'four\\n', 'five'] write () We already saw the write () method earlier. There, we used the write () method five times to write five lines. Let us now use a loop with the help of the lines list. First, we run the code: 1 2 3 4 5 f = open ( 'writing.txt' , 'w' ) lines = [ 'one' , 'two' , 'three' , 'four' , 'five' ] for line in lines : f . write ( line + ' \\n ' ) f . close () When we execute this, the following file is created: We see that there are six lines in the file and not five, though we seem to have written only five lines. The problem is with line-4, where we are adding ' \\n ' after every string in the list lines . We should make sure that we don't add a ' \\n ' after the last string in the list: f = open ( 'writing.txt' , 'w' ) lines = [ 'one' , 'two' , 'three' , 'four' , 'five' ] for i in range ( len ( lines )): line = lines [ i ] if i != len ( lines ) - 1 : f . write ( line + ' \\n ' ) else : f . write ( line ) f . close () Now, check the file, you will see that it has exactly five lines! Let us now try to write an integer to the file: f = open ( 'writing.txt' , 'w' ) f . write ( 1 ) f . close () This throws the following error: Traceback (most recent call last): File \"main.py\" , line 2 , in <module> f . write ( 1 ) TypeError : write() argument must be str, not int We see that write () method accepts only string arguments. If we want to write integers to a file, we have to first convert them to strings: 1 2 3 f = open ( 'writing.txt' , 'w' ) f . write ( str ( 1 )) f . close () As an exercise, try to run the following code. What do you observe? Why do you think this happens? 1 2 3 f = open ( 'writing.txt' , 'w' ) f . writeline ( str ( 1 )) f . close () writelines () We can write a list of lines to a file using the writelines () method: 1 2 3 4 f = open ( 'writing.txt' , 'w' ) lines = [ '1 \\n ' , '2 \\n ' , '3 \\n ' , '4 \\n ' , '5' ] f . writelines ( lines ) f . close () Note that the argument passed to the writelines () method is a list of strings. This will create a file having the following contents: 1 2 3 4 5 1 2 3 4 5","title":"Lesson 7.4"},{"location":"chapter-7/lesson-7.4/#lesson-74","text":"","title":"Lesson 7.4"},{"location":"chapter-7/lesson-7.4/#file-methods","text":"","title":"File methods"},{"location":"chapter-7/lesson-7.4/#read","text":"Let us continue working with examples.txt that we created in the previous lesson. If you recall, examples.txt has the following contents: 1 2 3 4 5 one two three four five Let us now look at a different way of reading from a file, using the read () method. 1 2 3 4 f = open ( 'examples.txt' , 'r' ) content = f . read () print ( content ) f . close () This gives the following output: 1 2 3 4 5 one two three four five read () is a method defined for the file object. When it is called without any argument, it returns a string that contains the entire content of the file. If you head to the console (it is to the right of the editor in Replit) and type the string content , this is what you get: 'one\\ntwo\\nthree\\nfour\\nfive' Notice that content is a single string. It contains the contents of the file, but between consecutive lines in the file, there is a ' \\n ' : Except for the last line, every line in the file ends with a ' \\n ' character. When this string is printed to the console \u2014 print ( content ) \u2014 we get five separate lines even though we are only passing a single string to the print () function. This is because of the presence of the newline character in the string. Whenever a newline character is encountered, the Python interpreter moves to the next line. Now, it is clear why the following piece of code printed an extra line between consecutive lines in the file: f = open ( 'examples.txt' , 'r' ) for line in f : print ( line ) # line ends with a \\n character for all lines except the last one # this is why we get an empty line between consecutive lines in the console f . close ()","title":"read()"},{"location":"chapter-7/lesson-7.4/#readline","text":"As its name suggests, the readline () method reads from the file one line at a time: 1 2 3 4 5 6 7 f = open ( 'examples.txt' , 'r' ) line1 = f . readline () line2 = f . readline () line3 = f . readline () line4 = f . readline () line5 = f . readline () f . close () The variables line1 , line2 , \u2026, line5 will hold the following values at the end of execution of the code given above: Variable Value line1 'one \\n ' line2 'two \\n ' line3 'three \\n ' line4 'four \\n ' line5 'five' Notice that line5 doesn't have a ' \\n ' at the end as it is the last line in the file. Here, we know that there are five lines in the file. This helped us define five separate variables. But what if there are more lines? Generally, we read a file so as to see what its contents are because we don't know what is there in it. Clearly, we need a way to figure out when the file ends. Now, consider the following code. What happens if we try to read the file using readline () after all the lines in the file have been read? 1 2 3 4 5 6 7 8 f = open ( 'examples.txt' , 'r' ) line1 = f . readline () line2 = f . readline () line3 = f . readline () line4 = f . readline () line5 = f . readline () line = f . readline () f . close () If we execute this and head to the console, we see that the variable line defined in line 7 is an empty string! This gives us a way to determine when a file is empty: Keep reading lines from the file until an empty string is encountered. Let us implement this: 1 2 3 4 5 6 f = open ( 'examples.txt' , 'r' ) line = f . readline () while line != '' : print ( line , end = '' ) line = f . readline () f . close () Here, we have managed to read the file using just one string variable. Let us make few more changes to this code: 1 2 3 4 5 6 f = open ( 'examples.txt' , 'r' ) line = f . readline () while line : print ( line . strip ()) line = f . readline () f . close () In this code, we have made two changes. One in line 3 and another in line 4. The loop condition in line-3 checks for the empty string. If line is an empty string, it evaluates to False and the loop will be terminated. This is a compact way of writing line != '' . Python treats empty sequences as False . If this is confusing, execute the following code and check the output: 1 2 3 line = '' if not line : print ( 'It works!' ) In line 4, we are using the strip () method to strip the string line of all the whitespace characters at the beginning and at the end. In this way, the trailing newline at the end of line will be stripped. This way, we don't need to use the end argument.","title":"readline()"},{"location":"chapter-7/lesson-7.4/#readlines","text":"Finally, Python also provides a way to read the file and store it as a list of lines: 1 2 3 4 5 f = open ( 'examples.txt' , 'r' ) lines = f . readlines () for line in lines : print ( line . strip ()) f . close () Here, lines is a list of lines. Notice that each element in lines corresponds to one line in the file. It is always a string: ['one\\n', 'two\\n', 'three\\n', 'four\\n', 'five']","title":"readlines()"},{"location":"chapter-7/lesson-7.4/#write","text":"We already saw the write () method earlier. There, we used the write () method five times to write five lines. Let us now use a loop with the help of the lines list. First, we run the code: 1 2 3 4 5 f = open ( 'writing.txt' , 'w' ) lines = [ 'one' , 'two' , 'three' , 'four' , 'five' ] for line in lines : f . write ( line + ' \\n ' ) f . close () When we execute this, the following file is created: We see that there are six lines in the file and not five, though we seem to have written only five lines. The problem is with line-4, where we are adding ' \\n ' after every string in the list lines . We should make sure that we don't add a ' \\n ' after the last string in the list: f = open ( 'writing.txt' , 'w' ) lines = [ 'one' , 'two' , 'three' , 'four' , 'five' ] for i in range ( len ( lines )): line = lines [ i ] if i != len ( lines ) - 1 : f . write ( line + ' \\n ' ) else : f . write ( line ) f . close () Now, check the file, you will see that it has exactly five lines! Let us now try to write an integer to the file: f = open ( 'writing.txt' , 'w' ) f . write ( 1 ) f . close () This throws the following error: Traceback (most recent call last): File \"main.py\" , line 2 , in <module> f . write ( 1 ) TypeError : write() argument must be str, not int We see that write () method accepts only string arguments. If we want to write integers to a file, we have to first convert them to strings: 1 2 3 f = open ( 'writing.txt' , 'w' ) f . write ( str ( 1 )) f . close () As an exercise, try to run the following code. What do you observe? Why do you think this happens? 1 2 3 f = open ( 'writing.txt' , 'w' ) f . writeline ( str ( 1 )) f . close ()","title":"write()"},{"location":"chapter-7/lesson-7.4/#writelines","text":"We can write a list of lines to a file using the writelines () method: 1 2 3 4 f = open ( 'writing.txt' , 'w' ) lines = [ '1 \\n ' , '2 \\n ' , '3 \\n ' , '4 \\n ' , '5' ] f . writelines ( lines ) f . close () Note that the argument passed to the writelines () method is a list of strings. This will create a file having the following contents: 1 2 3 4 5 1 2 3 4 5","title":"writelines()"},{"location":"chapter-7/lesson-7.5/","text":"Lesson 7.5 Reading CSV files CSV files Now that we are familiar with reading and writing simple files, let us see how to handle slightly more complex files. CSV files 1 are quite common in data science.In a CSV file, adjacent values in each line are separated by commas. A CSV file looks like this: 1 2 3 4 5 6 col0,col1,col2,col3 row1,item11,item12,item13 row2,item21,item22,item23 row3,item31,item32,item33 row4,item41,item42,item43 row5,item51,item52,item53 Such files are a good choice for representing tabular data. For the rest of this lesson, we will assume that CSV files are used to represent some such tabular data. The first line in the file is called the header. The header gives information about the fields or columns in the data. The rest of the lines can be treated as rows in the data. If this file is represented as a table, it would look like this: col0 col1 col2 col3 row1 item11 item12 item13 row2 item21 item22 item23 row3 item31 item32 item33 row4 item41 item42 item43 row5 item51 item52 item53 Reading a CSV file Let us create a CSV file in Replit and name it table.csv : Opening and reading a CSV file is no different from opening a text file. Let us try to print the lines in the file: 1 2 3 4 f = open ( 'table.csv' , 'r' ) for line in f : print ( line . strip ()) f . close () This is the output we get: 1 2 3 4 5 Name,Physics,Mathematics,Chemistry Newton,100,98,90 Einstein,100,85,88 Ramanujan,70,100,70 Gauss,100,100,70 So far so good. Now that we are able to extract the lines from the file, let us start asking some questions. Print the chemistry marks scored by the students, one in each line. This requires us to extract the last column from the file. How do we do this? Consider any one line in the file, say the second one: 1 2 3 # The `\\n` at the end will be present for all lines except the last one line = 'Newton,100,98,90 \\n ' line = line . strip () # removes the \\n character This is a string that corresponds to one row in the file. If we need to separate it into different columns, we need to use the split () method and split the line based on a comma: 1 2 3 4 line = 'Newton,100,98,90 \\n ' line = line . strip () columns = line . split ( ',' ) print ( columns ) This returns a list of strings: [ 'Newton' , '100' , '98' , '90' ] To extract the last column, we just need to take the last element from this list and convert it into an integer: 1 2 3 4 5 line = 'Newton,100,98,90' line = line . strip () columns = line . split ( ',' ) chem_marks = int ( columns [ - 1 ]) print ( chem_marks ) That is all! We have done this for one row. We need to do this for all the rows. Enter loop: 1 2 3 4 5 6 7 f = open ( 'table.csv' , 'r' ) for line in f : line = line . strip () columns = line . split ( ',' ) chem_marks = int ( columns [ - 1 ]) print ( chem_marks ) f . close () Aha, but we get an error: Traceback (most recent call last): File \"main.py\" , line 5 , in <module> chem_marks = int ( columns [ - 1 ]) ValueError : invalid literal for int() with base 10: 'Chemistry' Can you see why? We have tried to convert the last column of the header into an integer as well. The moral of the story is that when we are reading CSV files, we need to find a way to deal with the header. Let us modify our code towards that end: 1 2 3 4 5 6 7 8 9 10 f = open ( 'table.csv' , 'r' ) header = f . readline () # The file object has finished reading the first line # It is now ready to read from the second line onwards for line in f : line = line . strip () columns = line . split ( ',' ) chem_marks = int ( columns [ - 1 ]) print ( chem_marks ) f . close () This works! In the second line, we read the header. Now, when the for loop starts in line 5, we are ready to read from the second line in the file. Consider the following approach that uses the readlines () method alone: f = open ( 'table.csv' , 'r' ) lines = f . readlines () # lines[1: ] is the rest of the list # after ignoring the header for line in lines [ 1 : ]: line = line . strip () # strip the line of \\n columns = line . split ( ',' ) # split based on comma chem_marks = int ( columns [ - 1 ]) # convert last column to int print ( chem_marks ) f . close () readlines () is a reasonable choice for reading small files, say under 1000 lines. We get all the lines of the files in a list. Reading a file reduces to processing a list of strings. If lines is the list of lines, then lines[i] corresponds to the \\((i + 1)^{th}\\) line in the file. Going the other way, the \\(i^{th}\\) line in the file corresponds to the string lines[i - 1] . Processing large files When it comes to large files, readline () is the best method to use. Processing large files is best done by reading one line at a time. Using readlines () for large files is a dangerous idea. This is because, readlines () dumps the entire content of the file into a list of strings. When the file is large, this list will occupy a large amount of memory. Let us try to write the same program given above using the readline method: 1 2 3 4 5 6 7 8 9 10 f = open ( 'table.csv' , 'r' ) header = f . readline () . strip () # this is for the header line = f . readline () # second line; actual rows begin while line : line = line . strip () # strip the line of \\n columns = line . split ( ',' ) # split based on comma chem_marks = int ( columns [ - 1 ]) # convert last column to int print ( chem_marks ) line = f . readline () # read the next line in the file f . close () Files to Collections It is often useful to convert a CSV file and store in a suitable collection. We could do this in several ways. Here, let us try to create the following list of dictionaries from the file: data = [ { 'Name' : 'Newton' , 'Physics' : 100 , 'Mathematics' : 98 , 'Chemistry' : 90 }, { 'Name' : 'Einstein' , 'Physics' : 100 , 'Mathematics' : 85 , 'Chemistry' : 88 }, { 'Name' : 'Ramanujan' , 'Physics' : 70 , 'Mathematics' : 100 , 'Chemistry' : 70 }, { 'Name' : 'Gauss' , 'Physics' : 100 , 'Mathematics' : 100 , 'Chemistry' : 70 }] Couple of points to note. This is a list of dictionaries. Each dictionary in the list corresponds to one row in the file. The elements in the header appear as keys in every dictionary. The values of the dictionary are of different data types. Names are strings, marks are integers. This is going to be a fairly long code. Let us break it down. First, some basic processing to get the list of lines from the file after stripping them of the trailing newlines: 1 2 3 4 5 6 f = open ( 'table.csv' , 'r' ) lines = [ ] for line in f . readlines (): line = line . strip () lines . append ( line ) # Now, we have the list of lines Next, let us get the details of the header: 7 8 9 10 header = lines [ 0 ] . split ( ',' ) # lines[0] is the first row num_cols = len ( header ) # Now, we have the header information # We also know the number of columns in the file Now, it is time to go through the remaining lines in the file: 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ### Block-3 ### data = [ ] # list to store the contents for line in lines [ 1 : ]: # ignore the header cols = line . split ( ',' ) # split the column based on comma row_dict = dict () # create a dict to store this particular row for i in range ( num_cols ): # go through each element (column) in this row key = header [ i ] # key will be this column's name if key == 'Name' : # are we storing a name or a number? value = cols [ i ] # since this is a name, don't convert to int else : value = int ( cols [ i ]) # since this is marks, convert to int row_dict [ key ] = value # update dict data . append ( row_dict ) # append this row to the list data f . close () CSV stands for comma-seperated values. Learn more about this file type here \u21a9","title":"Lesson 7.5"},{"location":"chapter-7/lesson-7.5/#lesson-75","text":"","title":"Lesson 7.5"},{"location":"chapter-7/lesson-7.5/#reading-csv-files","text":"","title":"Reading CSV files"},{"location":"chapter-7/lesson-7.5/#csv-files","text":"Now that we are familiar with reading and writing simple files, let us see how to handle slightly more complex files. CSV files 1 are quite common in data science.In a CSV file, adjacent values in each line are separated by commas. A CSV file looks like this: 1 2 3 4 5 6 col0,col1,col2,col3 row1,item11,item12,item13 row2,item21,item22,item23 row3,item31,item32,item33 row4,item41,item42,item43 row5,item51,item52,item53 Such files are a good choice for representing tabular data. For the rest of this lesson, we will assume that CSV files are used to represent some such tabular data. The first line in the file is called the header. The header gives information about the fields or columns in the data. The rest of the lines can be treated as rows in the data. If this file is represented as a table, it would look like this: col0 col1 col2 col3 row1 item11 item12 item13 row2 item21 item22 item23 row3 item31 item32 item33 row4 item41 item42 item43 row5 item51 item52 item53","title":"CSV files"},{"location":"chapter-7/lesson-7.5/#reading-a-csv-file","text":"Let us create a CSV file in Replit and name it table.csv : Opening and reading a CSV file is no different from opening a text file. Let us try to print the lines in the file: 1 2 3 4 f = open ( 'table.csv' , 'r' ) for line in f : print ( line . strip ()) f . close () This is the output we get: 1 2 3 4 5 Name,Physics,Mathematics,Chemistry Newton,100,98,90 Einstein,100,85,88 Ramanujan,70,100,70 Gauss,100,100,70 So far so good. Now that we are able to extract the lines from the file, let us start asking some questions. Print the chemistry marks scored by the students, one in each line. This requires us to extract the last column from the file. How do we do this? Consider any one line in the file, say the second one: 1 2 3 # The `\\n` at the end will be present for all lines except the last one line = 'Newton,100,98,90 \\n ' line = line . strip () # removes the \\n character This is a string that corresponds to one row in the file. If we need to separate it into different columns, we need to use the split () method and split the line based on a comma: 1 2 3 4 line = 'Newton,100,98,90 \\n ' line = line . strip () columns = line . split ( ',' ) print ( columns ) This returns a list of strings: [ 'Newton' , '100' , '98' , '90' ] To extract the last column, we just need to take the last element from this list and convert it into an integer: 1 2 3 4 5 line = 'Newton,100,98,90' line = line . strip () columns = line . split ( ',' ) chem_marks = int ( columns [ - 1 ]) print ( chem_marks ) That is all! We have done this for one row. We need to do this for all the rows. Enter loop: 1 2 3 4 5 6 7 f = open ( 'table.csv' , 'r' ) for line in f : line = line . strip () columns = line . split ( ',' ) chem_marks = int ( columns [ - 1 ]) print ( chem_marks ) f . close () Aha, but we get an error: Traceback (most recent call last): File \"main.py\" , line 5 , in <module> chem_marks = int ( columns [ - 1 ]) ValueError : invalid literal for int() with base 10: 'Chemistry' Can you see why? We have tried to convert the last column of the header into an integer as well. The moral of the story is that when we are reading CSV files, we need to find a way to deal with the header. Let us modify our code towards that end: 1 2 3 4 5 6 7 8 9 10 f = open ( 'table.csv' , 'r' ) header = f . readline () # The file object has finished reading the first line # It is now ready to read from the second line onwards for line in f : line = line . strip () columns = line . split ( ',' ) chem_marks = int ( columns [ - 1 ]) print ( chem_marks ) f . close () This works! In the second line, we read the header. Now, when the for loop starts in line 5, we are ready to read from the second line in the file. Consider the following approach that uses the readlines () method alone: f = open ( 'table.csv' , 'r' ) lines = f . readlines () # lines[1: ] is the rest of the list # after ignoring the header for line in lines [ 1 : ]: line = line . strip () # strip the line of \\n columns = line . split ( ',' ) # split based on comma chem_marks = int ( columns [ - 1 ]) # convert last column to int print ( chem_marks ) f . close () readlines () is a reasonable choice for reading small files, say under 1000 lines. We get all the lines of the files in a list. Reading a file reduces to processing a list of strings. If lines is the list of lines, then lines[i] corresponds to the \\((i + 1)^{th}\\) line in the file. Going the other way, the \\(i^{th}\\) line in the file corresponds to the string lines[i - 1] . Processing large files When it comes to large files, readline () is the best method to use. Processing large files is best done by reading one line at a time. Using readlines () for large files is a dangerous idea. This is because, readlines () dumps the entire content of the file into a list of strings. When the file is large, this list will occupy a large amount of memory. Let us try to write the same program given above using the readline method: 1 2 3 4 5 6 7 8 9 10 f = open ( 'table.csv' , 'r' ) header = f . readline () . strip () # this is for the header line = f . readline () # second line; actual rows begin while line : line = line . strip () # strip the line of \\n columns = line . split ( ',' ) # split based on comma chem_marks = int ( columns [ - 1 ]) # convert last column to int print ( chem_marks ) line = f . readline () # read the next line in the file f . close ()","title":"Reading a CSV file"},{"location":"chapter-7/lesson-7.5/#files-to-collections","text":"It is often useful to convert a CSV file and store in a suitable collection. We could do this in several ways. Here, let us try to create the following list of dictionaries from the file: data = [ { 'Name' : 'Newton' , 'Physics' : 100 , 'Mathematics' : 98 , 'Chemistry' : 90 }, { 'Name' : 'Einstein' , 'Physics' : 100 , 'Mathematics' : 85 , 'Chemistry' : 88 }, { 'Name' : 'Ramanujan' , 'Physics' : 70 , 'Mathematics' : 100 , 'Chemistry' : 70 }, { 'Name' : 'Gauss' , 'Physics' : 100 , 'Mathematics' : 100 , 'Chemistry' : 70 }] Couple of points to note. This is a list of dictionaries. Each dictionary in the list corresponds to one row in the file. The elements in the header appear as keys in every dictionary. The values of the dictionary are of different data types. Names are strings, marks are integers. This is going to be a fairly long code. Let us break it down. First, some basic processing to get the list of lines from the file after stripping them of the trailing newlines: 1 2 3 4 5 6 f = open ( 'table.csv' , 'r' ) lines = [ ] for line in f . readlines (): line = line . strip () lines . append ( line ) # Now, we have the list of lines Next, let us get the details of the header: 7 8 9 10 header = lines [ 0 ] . split ( ',' ) # lines[0] is the first row num_cols = len ( header ) # Now, we have the header information # We also know the number of columns in the file Now, it is time to go through the remaining lines in the file: 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ### Block-3 ### data = [ ] # list to store the contents for line in lines [ 1 : ]: # ignore the header cols = line . split ( ',' ) # split the column based on comma row_dict = dict () # create a dict to store this particular row for i in range ( num_cols ): # go through each element (column) in this row key = header [ i ] # key will be this column's name if key == 'Name' : # are we storing a name or a number? value = cols [ i ] # since this is a name, don't convert to int else : value = int ( cols [ i ]) # since this is marks, convert to int row_dict [ key ] = value # update dict data . append ( row_dict ) # append this row to the list data f . close () CSV stands for comma-seperated values. Learn more about this file type here \u21a9","title":"Files to Collections"},{"location":"chapter-8/lesson-8.1/","text":"Lesson 8.1 Objects and Classes Objects are at the core of object oriented programming. With minimum jargon, let us try to understand what it all means. The simplest way of understanding the idea of objects is with the help of this wonderful phrase: Unity in diversity What unites all of us? We are all humans. We call this planet home. And yet, each of us is different. Each individual is unique. For example, height and weight are two obvious properties that make each individual stand out. In more philosophical terms, there are two forces in operation here: a global force that unites all of us and a local force that gives each one of us our own special identity. In the terminology of object oriented programming, each human being is an object . But all these objects belong to the class called \"Humanity\". This idea can be extended further. As a more mundane example, think about cars on the road. No two cars are the same. The brand of a car is one obvious point of difference. Even two cars of the same brand could be moving at different speeds. The speed of a car is another point of difference. However, a car is not the same as a train. We know a car when we see one. There are certain global features that are common to all cars and there is no mistaking that. In the terminology of object oriented programming, each car is an object. But all these objects belong to the class called \"Car\". We are now ready to move from the concrete to the abstract. Objects are entities that have certain attributes along with operations associated with them. For example, cars on the road could have the following attributes: speed, fuel level. The operations associated with it could be: start, stop, accelerate, decelerate, fill fuel tank. Given this basic understanding of what we mean by objects, we are now ready to define a class: A class is a blueprint or a template that is used to create objects. The specification of what constitutes a car is present in a class, say Car , note that capital \"C\". The specification of what makes a human is present in another class, say Human . Think about a class as a Google form. A form is nothing but a template. The template is created once and then it is distributed. Each of us fills this form differently hence creating different objects. Object Oriented Programming (OOP) is a paradigm that looks at the world as a collection of objects and the interactions among them. Rather than focusing on more definitions, let us jump in and look at OOP in action. OOP in Python: an example Consider a very simple template for a student that has following information: Name Marks We want to perform the following operations: Update the marks of the student Print student details class Student : def __init__ ( self , name , marks ): self . name = name self . marks = marks def update_marks ( self , marks ): self . marks = marks def print_details ( self ): print ( f ' { self . name } ' ) class is a keyword in Python to define classes. It is similar to the def keyword that is used to define functions. Student is the name of the class that we are creating. Within the class, we see that there are three functions: __init__ , update_marks and print_details . Functions defined inside a class are given a special name, they are called methods of the class. Among the methods that can be defined for a class, __init__ holds a special place and is called the constructor. Let us first see how to create an object of type Student : anish = Student ( 'Anish' , 95 ) anish is now an object of type Student . To verify this, run the following command: print ( type ( anish )) # output should be: <class '__main__.Student'> We shall take up this example in the next lesson and understand various features of a class.","title":"Lesson 8.1"},{"location":"chapter-8/lesson-8.1/#lesson-81","text":"","title":"Lesson 8.1"},{"location":"chapter-8/lesson-8.1/#objects-and-classes","text":"Objects are at the core of object oriented programming. With minimum jargon, let us try to understand what it all means. The simplest way of understanding the idea of objects is with the help of this wonderful phrase: Unity in diversity What unites all of us? We are all humans. We call this planet home. And yet, each of us is different. Each individual is unique. For example, height and weight are two obvious properties that make each individual stand out. In more philosophical terms, there are two forces in operation here: a global force that unites all of us and a local force that gives each one of us our own special identity. In the terminology of object oriented programming, each human being is an object . But all these objects belong to the class called \"Humanity\". This idea can be extended further. As a more mundane example, think about cars on the road. No two cars are the same. The brand of a car is one obvious point of difference. Even two cars of the same brand could be moving at different speeds. The speed of a car is another point of difference. However, a car is not the same as a train. We know a car when we see one. There are certain global features that are common to all cars and there is no mistaking that. In the terminology of object oriented programming, each car is an object. But all these objects belong to the class called \"Car\". We are now ready to move from the concrete to the abstract. Objects are entities that have certain attributes along with operations associated with them. For example, cars on the road could have the following attributes: speed, fuel level. The operations associated with it could be: start, stop, accelerate, decelerate, fill fuel tank. Given this basic understanding of what we mean by objects, we are now ready to define a class: A class is a blueprint or a template that is used to create objects. The specification of what constitutes a car is present in a class, say Car , note that capital \"C\". The specification of what makes a human is present in another class, say Human . Think about a class as a Google form. A form is nothing but a template. The template is created once and then it is distributed. Each of us fills this form differently hence creating different objects. Object Oriented Programming (OOP) is a paradigm that looks at the world as a collection of objects and the interactions among them. Rather than focusing on more definitions, let us jump in and look at OOP in action.","title":"Objects and Classes"},{"location":"chapter-8/lesson-8.1/#oop-in-python-an-example","text":"Consider a very simple template for a student that has following information: Name Marks We want to perform the following operations: Update the marks of the student Print student details class Student : def __init__ ( self , name , marks ): self . name = name self . marks = marks def update_marks ( self , marks ): self . marks = marks def print_details ( self ): print ( f ' { self . name } ' ) class is a keyword in Python to define classes. It is similar to the def keyword that is used to define functions. Student is the name of the class that we are creating. Within the class, we see that there are three functions: __init__ , update_marks and print_details . Functions defined inside a class are given a special name, they are called methods of the class. Among the methods that can be defined for a class, __init__ holds a special place and is called the constructor. Let us first see how to create an object of type Student : anish = Student ( 'Anish' , 95 ) anish is now an object of type Student . To verify this, run the following command: print ( type ( anish )) # output should be: <class '__main__.Student'> We shall take up this example in the next lesson and understand various features of a class.","title":"OOP in Python: an example"},{"location":"chapter-8/lesson-8.2/","text":"Lesson 8.2 Classes and Objects Let us continue with the Student class. For now, don't bother too much about the variable self . We will get to that soon. 1 2 3 4 5 6 7 8 9 10 class Student : def __init__ ( self , name , marks ): self . name = name self . marks = marks def update_marks ( self , marks ): self . marks = marks def print_details ( self ): print ( f ' { self . name } : { self . marks } ' ) As we saw at the end of the previous lesson, an object of the class Student can be created like this: 11 anish = Student ( 'Anish' , 80 ) Notice that we have used the name of the class in the RHS of the assignment statement. This invokes what is called the constructor \u2014 __init__ () method \u2014 of the class. Since the constructor has two parameters (ignore self for now) name and marks , we have to pass them as arguments while creating the object. The two arguments are then assigned to self . name and self . marks respectively. These two variables are called the attributes of the object. Attributes can be accessed using the . operator: 12 13 print ( anish . name ) print ( anish . marks ) __init__ () , update_marks () and print_details () are called methods . A method is effectively just a function that is defined in a class. Methods can be accessed using an object. If we wish to update Anish's marks to \\(95\\) , then we invoke the method using the object anish : 14 anish . update_marks ( 95 ) When anish . update_marks ( 95 ) is called, the attribute marks that is tied to the object anish is updated to \\(95\\) . To summarize, anish is an object of type Student having two attributes \u2014 name and marks \u2014 that can be accessed using the . operator. This object is also equipped with two methods (ignoring the constructor), one to update the marks and the other to print the details of the object. Attributes define the state of an object. Different objects of the same class could have different attributes. Naively speaking, methods help to update the values of the attributes. Therefore, the methods capture the behaviour of the object. self Some of you might be wondering about the variable self that crops in so many places in the definition of the class. The variable self is used to point to the current object. To get a better understanding, let us create two different Student objects: 1 2 anish = Student ( 'Anish' , 90 ) lakshmi = Student ( 'Lakshmi' , 95 ) How do we print the details of the student Lakshmi? lakshmi . print_details () When this method is called, Python actually ends up invoking the following function: Student . print_details ( lakshmi ) That is, it passes the current object as an argument. So, the variable self points to the current object. Another example: anish . update_marks ( 95 ) This is equivalent to the function call: Student . update_marks ( anish , 95 ) This is a mechanism that Python uses to know the object that it is dealing with. And for this reason, the first parameter in every method defined in a class will be self , and it will point to the object calling the method i.e., the current object. This should also clear up any confusion that lines 3 and 4 could have caused: 1 2 3 4 class Student : def __init__ ( self , name , marks ): self . name = name self . marks = marks self . name = name is the following operation: assign the value of the argument name to the current object's attribute self . name . A similar operation follows for self . marks . Class Attributes vs Object Attributes So far all attributes that we have seen are object attributes. Given an attribute, say name or marks , it is different for different objects. The name attribute of anish is different from the corresponding attribute fo the object lakshmi . Now, we shall see another kind of attribute. Let us say that we wish to keep track of the number students in our program. That is, when a new student joins our program, we need to update a counter. How do we do that? We need an attribute that is common to all objects and is not tied to any individual object. At the same time, we should be able to update this attribute whenever a new object is created. This is where the concept of class attributes comes in: 1 2 3 4 5 6 7 8 9 10 11 12 class Student : counter = 0 def __init__ ( self , name , marks ): self . name = name self . marks = marks Student . counter += 1 def update_marks ( self , marks ): self . marks = marks def print_details ( self ): print ( f ' { self . name } : { self . marks } ' ) Now, let us say that three students join the program: 13 14 15 16 17 18 madhavan = Student ( 'Madhavan' , 90 ) print ( 'Number of students in the program =' , Student . counter ) andrew = Student ( 'Andrew' , 85 ) print ( 'Number of students in the program =' , Student . counter ) usha = Student ( 'Usha' , 95 ) print ( 'Number of students in the program =' , Student . counter ) This gives the following output: 1 2 3 Number of students in the program = 1 Number of students in the program = 2 Number of students in the program = 3 Notice that we have used Student . counter to access the attribute counter . Such attributes are called class attributes . All objects of the class share this attribute. At this stage, we can try the following exercise. What do you think the output will be? 19 print ( madhavan . counter ) OUTPUT 4 3 A class attribute can be accessed by any of the objects. But, now, try to run this code: 20 21 22 madhavan . counter = - 1 print ( \"Student counter:\" , Student . counter ) print ( \"Madhavan counter:\" , madhavan . counter ) OUTPUT 5 6 Student counter: 3 Madhavan counter: -1 This seems confusing! But a moment's thought will convince you that it is not so hard. In line 20, we are creating an object attribute with the same name as the class attribute! If the same attribute name occurs in both an object and a class, then Python prioritizes the object attribute. In other words, when we change madhavan . counter , Student . counter remains unchanged because madhavan . counter gets delinked from Student . counter and becomes a new object attribute specific to madhavan . To change Student.counter : 23 24 Student . counter = 0 print ( Student . counter ) OUTPUT 7 Student counter: 0 Now try this as an exercise and try to figure out why the output is the way it is: 25 26 27 28 29 30 print ( \"Usha counter:\" , usha . counter ) print ( \"Madhavan counter:\" , madhavan . counter ) Rohan = Student ( 'Rohan' , 40 ) print ( \"Student counter:\" , Student . counter ) print ( \"Usha counter:\" , usha . counter ) print ( \"Madhavan counter:\" , madhavan . counter ) OUTPUT 8 9 10 11 12 Usha counter: 0 Madhavan counter: -1 Student counter: 1 Usha counter: 1 Madhavan counter: -1 This demonstrates an important fact: class attributes cannot be updated by an object! At best, they can be referenced or accessed using an object This also introduces another important point: object attributes can be created dynamically during runtime. So far, we have seen object attributes being created within the constructor. This is not binding. For example, consider the following snippet: class Student : def __init__ ( self , name ): self . name = name anish = Student ( 'Anish' ) anish . maths = 100 anish . physics = 90 anish . chem = 70 We have created three more object attributes on the fly. It is interesting to note the subtle difference between the attribute name and the three new attributes maths , physics and chem . Any object of Student will have the attribute name when it is initially created, of course with a different value for name depending on the object. But the attributes maths , physics and chem are unique to the object anish .","title":"Lesson 8.2"},{"location":"chapter-8/lesson-8.2/#lesson-82","text":"","title":"Lesson 8.2"},{"location":"chapter-8/lesson-8.2/#classes-and-objects","text":"Let us continue with the Student class. For now, don't bother too much about the variable self . We will get to that soon. 1 2 3 4 5 6 7 8 9 10 class Student : def __init__ ( self , name , marks ): self . name = name self . marks = marks def update_marks ( self , marks ): self . marks = marks def print_details ( self ): print ( f ' { self . name } : { self . marks } ' ) As we saw at the end of the previous lesson, an object of the class Student can be created like this: 11 anish = Student ( 'Anish' , 80 ) Notice that we have used the name of the class in the RHS of the assignment statement. This invokes what is called the constructor \u2014 __init__ () method \u2014 of the class. Since the constructor has two parameters (ignore self for now) name and marks , we have to pass them as arguments while creating the object. The two arguments are then assigned to self . name and self . marks respectively. These two variables are called the attributes of the object. Attributes can be accessed using the . operator: 12 13 print ( anish . name ) print ( anish . marks ) __init__ () , update_marks () and print_details () are called methods . A method is effectively just a function that is defined in a class. Methods can be accessed using an object. If we wish to update Anish's marks to \\(95\\) , then we invoke the method using the object anish : 14 anish . update_marks ( 95 ) When anish . update_marks ( 95 ) is called, the attribute marks that is tied to the object anish is updated to \\(95\\) . To summarize, anish is an object of type Student having two attributes \u2014 name and marks \u2014 that can be accessed using the . operator. This object is also equipped with two methods (ignoring the constructor), one to update the marks and the other to print the details of the object. Attributes define the state of an object. Different objects of the same class could have different attributes. Naively speaking, methods help to update the values of the attributes. Therefore, the methods capture the behaviour of the object.","title":"Classes and Objects"},{"location":"chapter-8/lesson-8.2/#self","text":"Some of you might be wondering about the variable self that crops in so many places in the definition of the class. The variable self is used to point to the current object. To get a better understanding, let us create two different Student objects: 1 2 anish = Student ( 'Anish' , 90 ) lakshmi = Student ( 'Lakshmi' , 95 ) How do we print the details of the student Lakshmi? lakshmi . print_details () When this method is called, Python actually ends up invoking the following function: Student . print_details ( lakshmi ) That is, it passes the current object as an argument. So, the variable self points to the current object. Another example: anish . update_marks ( 95 ) This is equivalent to the function call: Student . update_marks ( anish , 95 ) This is a mechanism that Python uses to know the object that it is dealing with. And for this reason, the first parameter in every method defined in a class will be self , and it will point to the object calling the method i.e., the current object. This should also clear up any confusion that lines 3 and 4 could have caused: 1 2 3 4 class Student : def __init__ ( self , name , marks ): self . name = name self . marks = marks self . name = name is the following operation: assign the value of the argument name to the current object's attribute self . name . A similar operation follows for self . marks .","title":"self"},{"location":"chapter-8/lesson-8.2/#class-attributes-vs-object-attributes","text":"So far all attributes that we have seen are object attributes. Given an attribute, say name or marks , it is different for different objects. The name attribute of anish is different from the corresponding attribute fo the object lakshmi . Now, we shall see another kind of attribute. Let us say that we wish to keep track of the number students in our program. That is, when a new student joins our program, we need to update a counter. How do we do that? We need an attribute that is common to all objects and is not tied to any individual object. At the same time, we should be able to update this attribute whenever a new object is created. This is where the concept of class attributes comes in: 1 2 3 4 5 6 7 8 9 10 11 12 class Student : counter = 0 def __init__ ( self , name , marks ): self . name = name self . marks = marks Student . counter += 1 def update_marks ( self , marks ): self . marks = marks def print_details ( self ): print ( f ' { self . name } : { self . marks } ' ) Now, let us say that three students join the program: 13 14 15 16 17 18 madhavan = Student ( 'Madhavan' , 90 ) print ( 'Number of students in the program =' , Student . counter ) andrew = Student ( 'Andrew' , 85 ) print ( 'Number of students in the program =' , Student . counter ) usha = Student ( 'Usha' , 95 ) print ( 'Number of students in the program =' , Student . counter ) This gives the following output: 1 2 3 Number of students in the program = 1 Number of students in the program = 2 Number of students in the program = 3 Notice that we have used Student . counter to access the attribute counter . Such attributes are called class attributes . All objects of the class share this attribute. At this stage, we can try the following exercise. What do you think the output will be? 19 print ( madhavan . counter ) OUTPUT 4 3 A class attribute can be accessed by any of the objects. But, now, try to run this code: 20 21 22 madhavan . counter = - 1 print ( \"Student counter:\" , Student . counter ) print ( \"Madhavan counter:\" , madhavan . counter ) OUTPUT 5 6 Student counter: 3 Madhavan counter: -1 This seems confusing! But a moment's thought will convince you that it is not so hard. In line 20, we are creating an object attribute with the same name as the class attribute! If the same attribute name occurs in both an object and a class, then Python prioritizes the object attribute. In other words, when we change madhavan . counter , Student . counter remains unchanged because madhavan . counter gets delinked from Student . counter and becomes a new object attribute specific to madhavan . To change Student.counter : 23 24 Student . counter = 0 print ( Student . counter ) OUTPUT 7 Student counter: 0 Now try this as an exercise and try to figure out why the output is the way it is: 25 26 27 28 29 30 print ( \"Usha counter:\" , usha . counter ) print ( \"Madhavan counter:\" , madhavan . counter ) Rohan = Student ( 'Rohan' , 40 ) print ( \"Student counter:\" , Student . counter ) print ( \"Usha counter:\" , usha . counter ) print ( \"Madhavan counter:\" , madhavan . counter ) OUTPUT 8 9 10 11 12 Usha counter: 0 Madhavan counter: -1 Student counter: 1 Usha counter: 1 Madhavan counter: -1 This demonstrates an important fact: class attributes cannot be updated by an object! At best, they can be referenced or accessed using an object This also introduces another important point: object attributes can be created dynamically during runtime. So far, we have seen object attributes being created within the constructor. This is not binding. For example, consider the following snippet: class Student : def __init__ ( self , name ): self . name = name anish = Student ( 'Anish' ) anish . maths = 100 anish . physics = 90 anish . chem = 70 We have created three more object attributes on the fly. It is interesting to note the subtle difference between the attribute name and the three new attributes maths , physics and chem . Any object of Student will have the attribute name when it is initially created, of course with a different value for name depending on the object. But the attributes maths , physics and chem are unique to the object anish .","title":"Class Attributes vs Object Attributes"},{"location":"chapter-8/lesson-8.3/","text":"Lesson 8.3 Inheritance Let us get back to the fundamental philosophical idea with which we began the study of object oriented programming. Unity in diversity. The idea of a class represents the unity, the idea of objects represent the diversity. But this diversity that we see around us is not chaotic and unordered. On the contrary, there is an organized hierarchy that we see almost everywhere around us. Consider the following image: We humans take up different roles. Some of us are students, others are working professionals. The beauty of this program is that we have working professionals who are at the same time students. Getting back to the point, we see that there is a hierarchy. All college students are students. All students are humans. In the other branch of this directed graph, all full-stack developers are software developers, all software developers are working professionals. The basic idea behind the concept of inheritance is this: Classes that are lower in the hierarchy inherit features or attributes from their ancestors. There are certain features of a class higher up in the hierarchy that can be inherited by classes lower in the hierarchy. For example, all working professionals draw a salary every month. All software developers also draw some monthly salary, because they belong to the class of working professionals. So, salary is an attribute that is common to all classes that are derived from the class of working professionals. Needless to say, a full stack developer inherits this attribute of salary from his ancestors in the graph. We shall take up a concrete example and see inheritance in action. Concrete Example By now you would have worked on plenty of assignments across multiple courses. Each assignment is a collection of questions. Questions come in different types, some are NAT, some MCQ. So, a NAT question is not of the same type as a MCQ question. Yet, both are questions. So, we see that there is a hierarchy of relationships here: Parents always come first in the hierarchy. So, let us first define a class to represent a question: 1 2 3 4 5 6 7 8 9 10 class Question : def __init__ ( self , statement , marks ): self . statement = statement self . marks = marks def print_question ( self ): print ( self . statement ) def update_marks ( self , marks ): self . marks = marks Note that we have only retained those elements as attributes that are common to all questions, irrespective of the type: statement of the question marks for the question The next step is to define two new classes for the children of Question , one for MCQ and the other for NAT. It is here that we make use of the relationship that we just diagrammed: 11 12 13 14 15 16 17 class NAT ( Question ): def __init__ ( self , statement , marks , answer ): super () . __init__ ( statement , marks ) self . answer = answer def update_answer ( self , answer ): self . answer = answer NAT is also a Question , but a specialized question. Specifically, it has an additional feature, answer , and a new method, update_answer . But all the other attributes and methods of Question are inherited by it, since NAT is just another Question . We say that NAT is derived from Question . Question becomes the parent-class or base-class , and NAT is a child-class or derived-class. In Python, the syntax used to make this dependency explicit is as follows: class Derived ( Base ): def __init__ ( self , ... ): pass #### OR #### class Child ( Parent ): def __init__ ( self , ... ): ... In our specific example, we have: class NAT ( Question ): def __init__ ( self , ... ): pass Parent-child relationship Note that something interesting happens within the constructor of the derived class: 11 12 13 14 15 16 17 class NAT ( Question ): def __init__ ( self , statement , marks , answer ): super () . __init__ ( statement , marks ) self . answer = answer def update_answer ( self , answer ): self . answer = answer The super () function points to the parent class, in this case Question . So, in line 13, we are effectively calling the constructor of the parent class. If we need to update the marks, we can just invoke the method update_marks () that is inherited from Question : 18 19 20 q_nat = NAT ( 'What is 1 + 1?' , 1 , 2 ) q_nat . update_marks ( 4 ) print ( q_nat . marks ) OUTPUT 4 Method Overriding Let us now turn our attention to methods. Pasting the parent-class here for easy reference: 1 2 3 4 5 6 7 8 9 10 class Question : def __init__ ( self , statement , marks ): self . statement = statement self . marks = marks def print_question ( self ): print ( self . statement ) def update_marks ( self , marks ): self . marks = marks Sometimes we may want to modify the behaviour of existing methods in the parent class. For example, take the case of a MCQ question. For questions of this type, the statement of a problem is incomplete without the options. The print_question () method in the parent class just prints the statement, but it makes more sense to print the options as well for a MCQ question. So, we want the print_question () to behave differently. Though we have inherited this method from the parent class, we can override the behaviour of the method in the following way: 11 12 13 14 15 16 17 18 19 20 21 22 class MCQ ( Question ): def __init__ ( self , statement , marks , ops , c_ops ): super () . __init__ ( statement , marks ) self . ops = ops # list of all options self . c_ops = c_ops # list of correct options def print_question ( self ): super () . print_question () # Assume there are only four options op_index = [ '(a)' , '(b)' , '(c)' , '(d)' ] for i in range ( 4 ): print ( op_index [ i ], self . ops [ i ]) Note that the parent class Question already prints the statement. So, we piggy-back on this behaviour using the super () function in line-8. In addition, we also print the options. Let us create a MCQ question object and see how it all works: 23 24 25 26 27 q_mcq = MCQ ( 'What is the capital of India?' , 2 , [ 'Chennai' , 'Mumbai' , 'Kolkota' , 'New Delhi' ], [ 'New Delhi' ]) q_mcq . print_question () This returns the output: OUTPUT 1 2 3 4 5 What is the capital of India? (a) Chennai (b) Mumbai (c) Kolkota (d) New Delhi","title":"Lesson 8.3"},{"location":"chapter-8/lesson-8.3/#lesson-83","text":"","title":"Lesson 8.3"},{"location":"chapter-8/lesson-8.3/#inheritance","text":"Let us get back to the fundamental philosophical idea with which we began the study of object oriented programming. Unity in diversity. The idea of a class represents the unity, the idea of objects represent the diversity. But this diversity that we see around us is not chaotic and unordered. On the contrary, there is an organized hierarchy that we see almost everywhere around us. Consider the following image: We humans take up different roles. Some of us are students, others are working professionals. The beauty of this program is that we have working professionals who are at the same time students. Getting back to the point, we see that there is a hierarchy. All college students are students. All students are humans. In the other branch of this directed graph, all full-stack developers are software developers, all software developers are working professionals. The basic idea behind the concept of inheritance is this: Classes that are lower in the hierarchy inherit features or attributes from their ancestors. There are certain features of a class higher up in the hierarchy that can be inherited by classes lower in the hierarchy. For example, all working professionals draw a salary every month. All software developers also draw some monthly salary, because they belong to the class of working professionals. So, salary is an attribute that is common to all classes that are derived from the class of working professionals. Needless to say, a full stack developer inherits this attribute of salary from his ancestors in the graph. We shall take up a concrete example and see inheritance in action.","title":"Inheritance"},{"location":"chapter-8/lesson-8.3/#concrete-example","text":"By now you would have worked on plenty of assignments across multiple courses. Each assignment is a collection of questions. Questions come in different types, some are NAT, some MCQ. So, a NAT question is not of the same type as a MCQ question. Yet, both are questions. So, we see that there is a hierarchy of relationships here: Parents always come first in the hierarchy. So, let us first define a class to represent a question: 1 2 3 4 5 6 7 8 9 10 class Question : def __init__ ( self , statement , marks ): self . statement = statement self . marks = marks def print_question ( self ): print ( self . statement ) def update_marks ( self , marks ): self . marks = marks Note that we have only retained those elements as attributes that are common to all questions, irrespective of the type: statement of the question marks for the question The next step is to define two new classes for the children of Question , one for MCQ and the other for NAT. It is here that we make use of the relationship that we just diagrammed: 11 12 13 14 15 16 17 class NAT ( Question ): def __init__ ( self , statement , marks , answer ): super () . __init__ ( statement , marks ) self . answer = answer def update_answer ( self , answer ): self . answer = answer NAT is also a Question , but a specialized question. Specifically, it has an additional feature, answer , and a new method, update_answer . But all the other attributes and methods of Question are inherited by it, since NAT is just another Question . We say that NAT is derived from Question . Question becomes the parent-class or base-class , and NAT is a child-class or derived-class. In Python, the syntax used to make this dependency explicit is as follows: class Derived ( Base ): def __init__ ( self , ... ): pass #### OR #### class Child ( Parent ): def __init__ ( self , ... ): ... In our specific example, we have: class NAT ( Question ): def __init__ ( self , ... ): pass","title":"Concrete Example"},{"location":"chapter-8/lesson-8.3/#parent-child-relationship","text":"Note that something interesting happens within the constructor of the derived class: 11 12 13 14 15 16 17 class NAT ( Question ): def __init__ ( self , statement , marks , answer ): super () . __init__ ( statement , marks ) self . answer = answer def update_answer ( self , answer ): self . answer = answer The super () function points to the parent class, in this case Question . So, in line 13, we are effectively calling the constructor of the parent class. If we need to update the marks, we can just invoke the method update_marks () that is inherited from Question : 18 19 20 q_nat = NAT ( 'What is 1 + 1?' , 1 , 2 ) q_nat . update_marks ( 4 ) print ( q_nat . marks ) OUTPUT 4","title":"Parent-child relationship"},{"location":"chapter-8/lesson-8.3/#method-overriding","text":"Let us now turn our attention to methods. Pasting the parent-class here for easy reference: 1 2 3 4 5 6 7 8 9 10 class Question : def __init__ ( self , statement , marks ): self . statement = statement self . marks = marks def print_question ( self ): print ( self . statement ) def update_marks ( self , marks ): self . marks = marks Sometimes we may want to modify the behaviour of existing methods in the parent class. For example, take the case of a MCQ question. For questions of this type, the statement of a problem is incomplete without the options. The print_question () method in the parent class just prints the statement, but it makes more sense to print the options as well for a MCQ question. So, we want the print_question () to behave differently. Though we have inherited this method from the parent class, we can override the behaviour of the method in the following way: 11 12 13 14 15 16 17 18 19 20 21 22 class MCQ ( Question ): def __init__ ( self , statement , marks , ops , c_ops ): super () . __init__ ( statement , marks ) self . ops = ops # list of all options self . c_ops = c_ops # list of correct options def print_question ( self ): super () . print_question () # Assume there are only four options op_index = [ '(a)' , '(b)' , '(c)' , '(d)' ] for i in range ( 4 ): print ( op_index [ i ], self . ops [ i ]) Note that the parent class Question already prints the statement. So, we piggy-back on this behaviour using the super () function in line-8. In addition, we also print the options. Let us create a MCQ question object and see how it all works: 23 24 25 26 27 q_mcq = MCQ ( 'What is the capital of India?' , 2 , [ 'Chennai' , 'Mumbai' , 'Kolkota' , 'New Delhi' ], [ 'New Delhi' ]) q_mcq . print_question () This returns the output: OUTPUT 1 2 3 4 5 What is the capital of India? (a) Chennai (b) Mumbai (c) Kolkota (d) New Delhi","title":"Method Overriding"},{"location":"chapter-8/lesson-8.4/","text":"Lesson 8.4 We will take up one final example of classes in action. This is to demonstrate few important points about OOP along the way. Vector: Mathematical Preliminaries To each point \\(P(x, y)\\) in 2D space, we can associate what is called a vector. Geometrically, this is a directed arrow from the origin to the point \\(P\\) . That is, one tip of the vector will always be the origin and the other tip, also called the head of the vector, will be at the point \\(P\\) . Here, \\(P_1\\) and \\(P_2\\) are two vectors: Some operations on vectors: Magnitude The magnitude of a vector \\(P(x, y)\\) is the length of the line segment \\(OP\\) : $$ |OP| = \\sqrt{x^2 + y^2} $$ Scale A vector can be scaled by a value \\(s\\) . Scaling modifies the length of the vector without changing the direction in which it is pointing at. This is equivalent to the following transformation: $$ s \\cdot (x, y) \\rightarrow (sx, sy) $$ Add Two vectors \\(P_1(x_1, y_1)\\) and \\(P_2(x_2, y_2)\\) can be added in the following manner: $$ (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2) $$ For example: Reflect A vector can be rotated about the origin. A particular instance of rotation is reflection about an axis. For example, \\(P_r\\) is the reflection of \\(P\\) about the X-axis: This corresponds to the transformation: $$ (x, y) \\rightarrow (x, -y) $$ Vector: Specification From the mathematical vector, we need to transition to the programmatic vector. The bridge between these two states is the specification . In this step, we come up with a written description of the attributes and methods that our Vector class should possess. The source for this information comes from the mathematical vector that we just studied. The following is the specification of the Vector class: Attributes x : the x-coordinate of the vector y : the y-coordinate of the vector This choice is sufficient as any mathematical vector in 2D space can be completely defined with these two attributes. Methods __init__ () : constructor of the class; populate the attributes based on the arguments __str__ () : return the coordinates of the vector in the form (x,y) when you call the str () or print () functions on a Vector object. magnitude () : return the magnitude of the vector scale () : scale the vector by some number, \\(s\\) ; this transformation should be applied on the current vector rotate_xaxis () : reflect the vector about the X-axis; this transformation should be applied on the current vector rotate_yaxis () : reflect the vector about the Y-axis; this transformation should be applied on the current vector add () : accept a vector as argument; return the sum of this argument with the current vector Vector: Definition The stage is now set to define the class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Vector : def __init__ ( self , x , y ): self . x , self . y = x , y def print ( self ): return f '( { self . x } , { self . y } )' def magnitude ( self ): return ( self . x ** 2 + self . y ** 2 ) ** 0.5 def scale ( self , s ): self . x , self . y = self . x * s , self . y * s def rotate_xaxis ( self ): self . y = - self . y def rotate_yaxis ( self ): self . x = - self . x def add ( self , P ): result = Vector ( 0 , 0 ) result . x , result . y = self . x + P . x , self . y + P . y return result Most methods are self-explanatory. Some require closer attention. Note that all methods except add () and __str__ () do not return any value. These are methods that transform the vector itself. The method add () however is interesting. It accepts a vector P as an argument! Within the method, a new Vector object is defined, it is the zero-vector. The current vector is added with P and result is stored in the newly created vector result . This is finally returned. Collection of Vectors The whole point of having a class is to have objects. The class is just a template. Consider the following use case of a collection of objects: triangle = [ Vector ( 0 , 1 ), Vector ( 3 , 1 ), Vector ( 3 , 0 )] The list triangle is a collection of objects of type Vector . In this instance, triangle represents the following triangle: We could now ask various questions here, one of which is this: how do we compute the lengths of the sides of this triangle? def dist ( P1 , P2 ): return (( P1 . x - P2 . x ) ** 2 + ( P1 . y - P2 . y ) ** 2 ) ** 0.5 def side_lengths ( triangle ): la = dist ( triangle [ 0 ], triangle [ 1 ]) lb = dist ( triangle [ 1 ], triangle [ 2 ]) lc = dist ( triangle [ 2 ], triangle [ 0 ]) return la , lb , lc In this way, we could also define a square to be a list of four vectors. That brings to a close the discussion on object oriented programming in Python. We will cover these concepts in greater detail when we study Java.","title":"Lesson 8.4"},{"location":"chapter-8/lesson-8.4/#lesson-84","text":"We will take up one final example of classes in action. This is to demonstrate few important points about OOP along the way.","title":"Lesson 8.4"},{"location":"chapter-8/lesson-8.4/#vector-mathematical-preliminaries","text":"To each point \\(P(x, y)\\) in 2D space, we can associate what is called a vector. Geometrically, this is a directed arrow from the origin to the point \\(P\\) . That is, one tip of the vector will always be the origin and the other tip, also called the head of the vector, will be at the point \\(P\\) . Here, \\(P_1\\) and \\(P_2\\) are two vectors: Some operations on vectors:","title":"Vector: Mathematical Preliminaries"},{"location":"chapter-8/lesson-8.4/#magnitude","text":"The magnitude of a vector \\(P(x, y)\\) is the length of the line segment \\(OP\\) : $$ |OP| = \\sqrt{x^2 + y^2} $$","title":"Magnitude"},{"location":"chapter-8/lesson-8.4/#scale","text":"A vector can be scaled by a value \\(s\\) . Scaling modifies the length of the vector without changing the direction in which it is pointing at. This is equivalent to the following transformation: $$ s \\cdot (x, y) \\rightarrow (sx, sy) $$","title":"Scale"},{"location":"chapter-8/lesson-8.4/#add","text":"Two vectors \\(P_1(x_1, y_1)\\) and \\(P_2(x_2, y_2)\\) can be added in the following manner: $$ (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2) $$ For example:","title":"Add"},{"location":"chapter-8/lesson-8.4/#reflect","text":"A vector can be rotated about the origin. A particular instance of rotation is reflection about an axis. For example, \\(P_r\\) is the reflection of \\(P\\) about the X-axis: This corresponds to the transformation: $$ (x, y) \\rightarrow (x, -y) $$","title":"Reflect"},{"location":"chapter-8/lesson-8.4/#vector-specification","text":"From the mathematical vector, we need to transition to the programmatic vector. The bridge between these two states is the specification . In this step, we come up with a written description of the attributes and methods that our Vector class should possess. The source for this information comes from the mathematical vector that we just studied. The following is the specification of the Vector class:","title":"Vector: Specification"},{"location":"chapter-8/lesson-8.4/#attributes","text":"x : the x-coordinate of the vector y : the y-coordinate of the vector This choice is sufficient as any mathematical vector in 2D space can be completely defined with these two attributes.","title":"Attributes"},{"location":"chapter-8/lesson-8.4/#methods","text":"__init__ () : constructor of the class; populate the attributes based on the arguments __str__ () : return the coordinates of the vector in the form (x,y) when you call the str () or print () functions on a Vector object. magnitude () : return the magnitude of the vector scale () : scale the vector by some number, \\(s\\) ; this transformation should be applied on the current vector rotate_xaxis () : reflect the vector about the X-axis; this transformation should be applied on the current vector rotate_yaxis () : reflect the vector about the Y-axis; this transformation should be applied on the current vector add () : accept a vector as argument; return the sum of this argument with the current vector","title":"Methods"},{"location":"chapter-8/lesson-8.4/#vector-definition","text":"The stage is now set to define the class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Vector : def __init__ ( self , x , y ): self . x , self . y = x , y def print ( self ): return f '( { self . x } , { self . y } )' def magnitude ( self ): return ( self . x ** 2 + self . y ** 2 ) ** 0.5 def scale ( self , s ): self . x , self . y = self . x * s , self . y * s def rotate_xaxis ( self ): self . y = - self . y def rotate_yaxis ( self ): self . x = - self . x def add ( self , P ): result = Vector ( 0 , 0 ) result . x , result . y = self . x + P . x , self . y + P . y return result Most methods are self-explanatory. Some require closer attention. Note that all methods except add () and __str__ () do not return any value. These are methods that transform the vector itself. The method add () however is interesting. It accepts a vector P as an argument! Within the method, a new Vector object is defined, it is the zero-vector. The current vector is added with P and result is stored in the newly created vector result . This is finally returned.","title":"Vector: Definition"},{"location":"chapter-8/lesson-8.4/#collection-of-vectors","text":"The whole point of having a class is to have objects. The class is just a template. Consider the following use case of a collection of objects: triangle = [ Vector ( 0 , 1 ), Vector ( 3 , 1 ), Vector ( 3 , 0 )] The list triangle is a collection of objects of type Vector . In this instance, triangle represents the following triangle: We could now ask various questions here, one of which is this: how do we compute the lengths of the sides of this triangle? def dist ( P1 , P2 ): return (( P1 . x - P2 . x ) ** 2 + ( P1 . y - P2 . y ) ** 2 ) ** 0.5 def side_lengths ( triangle ): la = dist ( triangle [ 0 ], triangle [ 1 ]) lb = dist ( triangle [ 1 ], triangle [ 2 ]) lc = dist ( triangle [ 2 ], triangle [ 0 ]) return la , lb , lc In this way, we could also define a square to be a list of four vectors. That brings to a close the discussion on object oriented programming in Python. We will cover these concepts in greater detail when we study Java.","title":"Collection of Vectors"},{"location":"extras/limits/","text":"Shorts Before we close this chapter, let us spend some time at the intersection of mathematics and programming. Consider the following number: $$ \\sqrt{2} - 1 $$ It is known that \\(1 < \\sqrt{2} < 2\\) . From this, it follows that \\(0 < \\sqrt{2} - 1 < 1\\) . Now, consider the following sequence: $$ a_n = \\left( \\sqrt{2} - 1 \\right)^n $$ As \\(n\\) becomes very large, the values in this sequence will become smaller and smaller. This is because, if you keep multiplying a fraction with itself, it becomes smaller and smaller. In mathematical terms, the limit of this sequence as \\(n\\) tends to infinity is zero. Let us verify this programmatically: n = int ( input ()) # sequence length CONST = 2 ** 0.5 - 1 # basic term in the sequence a_n = 1 # zeroth term for i in range ( n ): a_n = a_n * CONST print ( a_n ) Try this out for a few values of \\(n\\) . For \\(n = 100\\) , the value is \\(5.27 \\times 10^{-39}\\) , which is so small that for all practical purposes, it is as good as zero. Now, here is another fact. For every number \\(n\\) , there are unique integers \\(x\\) and \\(y\\) such that: $$ (\\sqrt{2} - 1)^n = x + y \\cdot \\sqrt{2} $$ This can be verified for the first few values of \\(n\\) . The following is a sketch of an inductive proof that this is indeed the case. If \\((\\sqrt{2} - 1)^n = x_n + y_n \\cdot \\sqrt{2}\\) , then: $$ \\begin{align} (\\sqrt{2} - 1)^{n + 1} &= (x_n + y_n \\cdot \\sqrt{2}) \\cdot (\\sqrt{2} - 1)\\ &= (2y_n - x_n) + (x_n - y_n) \\cdot \\sqrt{2}\\ &= x_{n + 1} + y_{n + 1} \\cdot \\sqrt{2} \\end{align} $$ This gives us a programmatic way to compute the \\(n^{th}\\) power of \\(\\sqrt{2} - 1\\) in the above form: n = int ( input ()) # sequence length x_n , y_n = - 1 , 1 # x_1 and y_1 for i in range ( n ): x_n , y_n = 2 * y_n - x_n , x_n - y_n This in turn provides a way to approximate \\(\\sqrt{2}\\) using rational numbers: $$ \\sqrt{2} \\approx \\frac{-x_n}{y_n} $$ As \\(n\\) becomes large, this approximation will become increasingly accurate. For example, here is an approximation after 100 iterations. It is accurate up to several decimal places! $$ \\frac{228725309250740208744750893347264645481}{161733217200188571081311986634082331709} $$ Is any of this useful? I don't know. But honestly, who cares? We don't do things because they are useful. We do them because they are interesting. And all interesting things will find their use at some point of time in the future.","title":"Shorts"},{"location":"extras/limits/#shorts","text":"Before we close this chapter, let us spend some time at the intersection of mathematics and programming. Consider the following number: $$ \\sqrt{2} - 1 $$ It is known that \\(1 < \\sqrt{2} < 2\\) . From this, it follows that \\(0 < \\sqrt{2} - 1 < 1\\) . Now, consider the following sequence: $$ a_n = \\left( \\sqrt{2} - 1 \\right)^n $$ As \\(n\\) becomes very large, the values in this sequence will become smaller and smaller. This is because, if you keep multiplying a fraction with itself, it becomes smaller and smaller. In mathematical terms, the limit of this sequence as \\(n\\) tends to infinity is zero. Let us verify this programmatically: n = int ( input ()) # sequence length CONST = 2 ** 0.5 - 1 # basic term in the sequence a_n = 1 # zeroth term for i in range ( n ): a_n = a_n * CONST print ( a_n ) Try this out for a few values of \\(n\\) . For \\(n = 100\\) , the value is \\(5.27 \\times 10^{-39}\\) , which is so small that for all practical purposes, it is as good as zero. Now, here is another fact. For every number \\(n\\) , there are unique integers \\(x\\) and \\(y\\) such that: $$ (\\sqrt{2} - 1)^n = x + y \\cdot \\sqrt{2} $$ This can be verified for the first few values of \\(n\\) . The following is a sketch of an inductive proof that this is indeed the case. If \\((\\sqrt{2} - 1)^n = x_n + y_n \\cdot \\sqrt{2}\\) , then: $$ \\begin{align} (\\sqrt{2} - 1)^{n + 1} &= (x_n + y_n \\cdot \\sqrt{2}) \\cdot (\\sqrt{2} - 1)\\ &= (2y_n - x_n) + (x_n - y_n) \\cdot \\sqrt{2}\\ &= x_{n + 1} + y_{n + 1} \\cdot \\sqrt{2} \\end{align} $$ This gives us a programmatic way to compute the \\(n^{th}\\) power of \\(\\sqrt{2} - 1\\) in the above form: n = int ( input ()) # sequence length x_n , y_n = - 1 , 1 # x_1 and y_1 for i in range ( n ): x_n , y_n = 2 * y_n - x_n , x_n - y_n This in turn provides a way to approximate \\(\\sqrt{2}\\) using rational numbers: $$ \\sqrt{2} \\approx \\frac{-x_n}{y_n} $$ As \\(n\\) becomes large, this approximation will become increasingly accurate. For example, here is an approximation after 100 iterations. It is accurate up to several decimal places! $$ \\frac{228725309250740208744750893347264645481}{161733217200188571081311986634082331709} $$ Is any of this useful? I don't know. But honestly, who cares? We don't do things because they are useful. We do them because they are interesting. And all interesting things will find their use at some point of time in the future.","title":"Shorts"},{"location":"extras/resources/","text":"Resources This section provides additional resources in the form of articles and blogs that are scattered around the web: Dropbox | Dynamic typing Python's Functions are First-Class Memory address of a Function Understanding slicing Migration to Python 3","title":"Resources"},{"location":"extras/resources/#resources","text":"This section provides additional resources in the form of articles and blogs that are scattered around the web: Dropbox | Dynamic typing Python's Functions are First-Class Memory address of a Function Understanding slicing Migration to Python 3","title":"Resources"}]}